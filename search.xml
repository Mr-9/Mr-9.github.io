<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue.js笔记四]]></title>
    <url>%2F2021%2F05%2F25%2Fvue.js%E7%AC%94%E8%AE%B0%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[一、slot插槽]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js笔记三]]></title>
    <url>%2F2021%2F05%2F21%2Fvue.js%E7%AC%94%E8%AE%B0%E4%B8%89%2F</url>
    <content type="text"><![CDATA[1、组件化开发1.1、注册组件的基本步骤 创建组件构造器 组测组件 使用组件 123456789101112131415161718192021&lt;div id="app"&gt; &lt;m-cpn&gt;&lt;/m-cpn&gt; &lt;m-cpn&gt;&lt;/m-cpn&gt;&lt;/div&gt;&lt;!--导入vue.js--&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;script&gt; // 创建组件构造器对象 const cpnC = Vue.extend(&#123; template:` &lt;div&gt; &lt;h2&gt;modi nobis omnis &lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet!&lt;/p&gt; &lt;p&gt;Lorem ipsum dolor sit amet!&lt;/p&gt; &lt;p&gt;Lorem ipsum dolor sit amet!&lt;/p&gt; &lt;/div&gt;` &#125;); // 注册主键 Vue.component('m-cpn',cpnC)&lt;/script&gt; 说明：组件必须定义在某个vue实例下，否则不生效 1.2、全局组件和局部组件当用Vue.component()注册主键的时候，组件的注册是全局的。意味着可以在任意的vue下使用 123456789101112131415161718192021222324252627&lt;div id="app1"&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt;&lt;/div&gt;&lt;div id="app2"&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt;&lt;/div&gt;&lt;!--导入vue.js--&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;script&gt; const cpn = Vue.extend(&#123; template:` &lt;div&gt; &lt;h2&gt;Lorem ipsum dolor sit amet&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Accusamus, architecto dolorum eaque est hic ipsam, laudantium magni modi mollitia quibusdam reiciendis repudiandae saepe sapiente totam, velit veritatis voluptate? Alias, hic.&lt;/p&gt; &lt;/div&gt; ` &#125;) Vue.component('my-cpn',cpn) let app1 = new Vue(&#123; el:'#app1', &#125;); let app2 = new Vue(&#123; el:'#app2' &#125;)&lt;/script&gt; 如果挂载在某个实例中，则这就是一个局部组件 123456789101112131415161718192021222324252627282930&lt;div id="app1"&gt; &lt;my-cnf&gt;&lt;/my-cnf&gt;&lt;/div&gt;&lt;div id="app2"&gt;&lt;!-- 不起作用--&gt; &lt;my-cnf&gt;&lt;/my-cnf&gt;&lt;/div&gt;&lt;!--导入vue.js--&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;script&gt; let cnf = Vue.extend(&#123; template:` &lt;div&gt; &lt;h2&gt;Lorem ipsum dolor sit amet&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Accusamus, architecto dolorum eaque est hic ipsam, laudantium magni modi mollitia quibusdam reiciendis repudiandae saepe sapiente totam, velit veritatis voluptate? Alias, hic.&lt;/p&gt; &lt;/div&gt; ` &#125;) const app1 = new Vue(&#123; el:'#app1', components:&#123; 'my-cnf':cnf &#125; &#125;); const app2 = new Vue(&#123; el:'#app2', &#125;)&lt;/script&gt; 1.3、父组件和子组件一个组件中，定义另一个组件 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id="app"&gt; &lt;parent-cpn&gt;&lt;/parent-cpn&gt;&lt;/div&gt;&lt;!--导入vue.js--&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;script&gt; let childCpn = Vue.extend(&#123; template:` &lt;div&gt; &lt;h2&gt;Lorem ipsum dolor sit amet&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Accusamus, architecto dolorum eaque est hic ipsam, laudantium magni modi mollitia quibusdam reiciendis repudiandae saepe sapiente totam, velit veritatis voluptate? Alias, hic.&lt;/p&gt; &lt;/div&gt; ` &#125;) let parentCpn = Vue.extend(&#123; template:` &lt;div&gt; &lt;h1&gt;Lorem ipsum dolor sit amet&lt;/h1&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Accusamus, architecto dolorum eaque est hic ipsam, laudantium magni modi mollitia quibusdam reiciendis repudiandae saepe sapiente totam, velit veritatis voluptate? Alias, hic.&lt;/p&gt; &lt;child-cpn&gt;&lt;/child-cpn&gt; &lt;/div&gt; `, components:&#123; 'child-cpn':childCpn &#125; &#125;) Vue.component('parent-cpn',parentCpn) const app = new Vue(&#123; el:'#app', data:&#123; message:"hello vue" &#125; &#125;);&lt;/script&gt; 1.4、注册主键语法糖简单写法中省去了Vue.extend()的步骤 可以直接用一个对象来代替 123456789101112131415161718192021222324252627282930313233&lt;div id="app"&gt; &lt;parent-cpn&gt;&lt;/parent-cpn&gt;&lt;/div&gt;&lt;!--导入vue.js--&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;script&gt; Vue.component('parent-cpn',&#123; template:` &lt;div&gt; &lt;h1&gt;Lorem ipsum dolor sit amet&lt;/h1&gt; &lt;p&gt;Lorem ipsum dolor sit amet&lt;/p&gt; &lt;child-cpn&gt;&lt;/child-cpn&gt; &lt;/div&gt; `, components:&#123; 'child-cpn': &#123; template:` &lt;div&gt; &lt;h2&gt;Lorem ipsum dolor sit amet&lt;/h2&gt; &lt;p&gt;Lorem ipsum &lt;/p&gt; &lt;/div&gt; ` &#125; &#125; &#125;) const app = new Vue(&#123; el:'#app', data:&#123; message:"hello vue" &#125; &#125;);&lt;/script&gt; 1.5、模板的分离 组件中数据存放问题：需要用函数返回，而不是数组。因为为了调用组件时每次调用都是一个新的组件，并且组件中相互不影响，则需要用函数表示。 12345678910111213141516171819202122232425262728293031323334353637&lt;div id="app"&gt; &lt;parent-cpn&gt;&lt;/parent-cpn&gt;&lt;/div&gt;&lt;script type="text/x-template" id="myCpn"&gt;&lt;div&gt; &lt;h1&gt; Lorem ipsum dolor sit amet1&lt;/h1&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/p&gt; &lt;child-cpn&gt;&lt;/child-cpn&gt;&lt;/div&gt;&lt;/script&gt;&lt;template id="myCpn2"&gt; &lt;div&gt; &lt;h2&gt; Lorem ipsum dolor sit amet&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit1.&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;!--导入vue.js--&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el:'#app', data:&#123; message:"hello vue" &#125;, components: &#123; 'parent-cpn':&#123; template: `#myCpn`, components: &#123; 'child-cpn':&#123; template: '#myCpn2' &#125; &#125; &#125; &#125; &#125;);&lt;/script&gt; 1.6、组件不能直接访问Vue的实例123456789101112131415161718192021222324252627282930313233343536373839404142&lt;div id="app"&gt; &lt;parent-cpn&gt;&lt;/parent-cpn&gt;&lt;/div&gt;&lt;script type="text/x-template" id="myCpn"&gt;&lt;div&gt; &lt;h1&gt; &#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/p&gt; &lt;child-cpn&gt;&lt;/child-cpn&gt;&lt;/div&gt;&lt;/script&gt;&lt;template id="myCpn2"&gt; &lt;div&gt; &lt;h2&gt; Lorem ipsum dolor sit amet&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit1.&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;!--导入vue.js--&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el:'#app', data:&#123; message:"hello vue" &#125;, components: &#123; 'parent-cpn':&#123; data()&#123; return &#123; title:'hhh' &#125; &#125;, template: `#myCpn`, components: &#123; 'child-cpn':&#123; template: '#myCpn2' &#125; &#125; &#125; &#125; &#125;);&lt;/script&gt; 1.7、组件通信——父组件向子组件发消息 在组件中，使用选项props来声明需要从父级接收到的数据 props的值有两种方式 方式一：字符串数组，数组中的字符串就是传递时的名称 方式二：对象，对象可以设置传递时的类型，也可以设置默认值等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;div id="app"&gt; &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt; &lt;parent v-bind:cmovie="movie" v-bind:cmessage = "message"&gt;&lt;/parent&gt;&lt;/div&gt;&lt;!--注意。模板要放在根组件中--&gt;&lt;template id="parent"&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt; &lt;p&gt;&#123;&#123;cmessage&#125;&#125;&lt;/p&gt; &lt;p&gt; &lt;ul&gt; &lt;li v-for="item in cmovie"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/p&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. At autem, consequuntur cumque earum est ex incidunt iusto, magni pariatur provident rerum sequi temporibus veritatis. Commodi ea itaque iure placeat voluptas!&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;!--导入vue.js--&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el:'#app', data:&#123; message:"这是一个测试", movie:['mov1','mov2','mov3'] &#125;, components:&#123; 'parent': &#123; // props:['cmovie'], //第一种写法 // props:&#123; // cmovie:Array, //第二种写法，对传递的数据进行验证 // cmessage:'aaaaa' // &#125;, // props:&#123; //第二种写法，可以增加增加类型和默认值 cmovie:&#123; type:Array, default:['aaaa'] &#125;, cmessage:&#123; type:String, default: 'sss' &#125; &#125;, template:`#parent`, data()&#123; return &#123; title:'标题2' &#125; &#125; &#125; &#125; &#125;);&lt;/script&gt; 1.8、组件通信——子组件向父组件传递数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;div id="app"&gt; &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; &lt;!--通过子组件item-click的监听，用父组件中cpnclick进行操作--&gt; &lt;cpn v-on:item-click="cpnclick"&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id="cpn"&gt; &lt;div&gt; &lt;button v-for="item in categories" @click="btnClick(item)"&gt;&#123;&#123;item.name&#125;&#125;&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;!--导入vue.js--&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;script&gt; //子组件 const cpn = &#123; template: '#cpn', data()&#123; return &#123; categories:[ &#123;id:1,name:'n1'&#125;, &#123;id:2,name:'n2'&#125;, &#123;id:3,name:'n3'&#125;, &#123;id:4,name:'n4'&#125;, ] &#125; &#125;, methods:&#123; btnClick(item)&#123; // console.log(item); // 通过@emit()事件发送数据到父组件 this.$emit('item-click',item) &#125; &#125; &#125; const app = new Vue(&#123; el:'#app', data:&#123; message:"hello vue" &#125;, components:&#123; cpn &#125;, methods:&#123; cpnclick(item)&#123; console.log(item); &#125; &#125; &#125;);&lt;/script&gt; 1.9、父子组件的访问方式：$children 父组件访问子组件：使用$children 或者$refs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;div id="app"&gt; &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; &lt;button @click="btnClick"&gt;按钮&lt;/button&gt; &lt;cpn ref="aaa"&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id="cpn"&gt; &lt;div&gt; &lt;div&gt;我是子组件&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;!--导入vue.js--&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el:'#app', data:&#123; message:"hello vue" &#125;, methods:&#123; btnClick(item) &#123; //1 $child console.log(this.$children); this.$children[0].showMessage(); console.log(this.$children[0].name); //2 定义ref this.$refs.aaa.showMessage() console.log(this.$refs.aaa.name); &#125; &#125;, components:&#123; cpn:&#123; template:`#cpn`, data()&#123; return &#123; name:'我是子组件name' &#125; &#125;, methods:&#123; showMessage()&#123; console.log('showMessage'); &#125; &#125; &#125; &#125; &#125;);&lt;/script&gt; 子组件访问父组件：使用$parent 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;div id="app"&gt;&lt;cpn&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id="cpn"&gt; &lt;div&gt; &lt;div&gt;我是子组件&lt;/div&gt; &lt;button @click="btnClick"&gt;按钮&lt;/button&gt; &lt;ccpn&gt;&lt;/ccpn&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id="ccpn"&gt; &lt;button @click="btnClick2"&gt;按钮2&lt;/button&gt;&lt;/template&gt;&lt;!--导入vue.js--&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el:'#app', data:&#123; message:"hello vue" &#125;, components:&#123; cpn:&#123; template:`#cpn`, data()&#123; return &#123; 'name':'eee' &#125; &#125;, methods:&#123; btnClick()&#123; // 1访问父组件 console.log(this.$parent); console.log(this.$parent.message); &#125; &#125;, components: &#123; ccpn:&#123; template: `#ccpn`, methods: &#123; btnClick2()&#123; this.$parent.btnClick() console.log(this.$parent.name) console.log(this.$root.message) &#125; &#125; &#125; &#125; &#125; &#125; &#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js笔记二]]></title>
    <url>%2F2021%2F05%2F19%2Fvue.js%E7%AC%94%E8%AE%B0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[1、Es6一些基础语法及增强1.1、let/varlet可以看作是更完美的var,js在使用var声明变量的时候，变量的作用域主要是和函数的定义有关.而对于没有作用域的比如if/for等会出现问题。 12345678910111213141516//es5 var btns = document.getElementsByTagName('button'); for (var i=0; i&lt;btns.length; i++) &#123; (function (num) &#123; // 0 btns[i].addEventListener('click', function () &#123; console.log('第' + num + '个按钮被点击'); &#125;) &#125;)(i) &#125;//es6 let btns = document.getElementsByTagName('button') for (let i = 0; i &lt; btns.length; i++) &#123; btns[i].addEventListener('click', function () &#123; console.log('第' + i + '个按钮被点击'); &#125;) &#125; 1.2、const的使用const修饰的标识符为常量，不可以再次赋值，但是可以修改const内部的属性 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; // 1.注意一: 一旦给const修饰的标识符被赋值之后, 不能修改 // const name = 'why'; // name = 'abc'; // 2.注意二: 在使用const定义标识符,必须进行赋值 // const name; // 3.注意三: 常量的含义是指向的对象不能修改, 但是可以改变对象内部的属性. const obj = &#123; name: 'why', age: 18, height: 1.88 &#125; // obj = &#123;&#125; console.log(obj); obj.name = 'kobe'; obj.age = 40; obj.height = 1.87; console.log(obj);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.3、ES6中的对象增强的写法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; // const obj = new Object() // const obj = &#123; // name: 'why', // age: 18, // run: function () &#123; // console.log('在奔跑'); // &#125;, // eat: function () &#123; // console.log('在次东西'); // &#125; // &#125; // 1.属性的增强写法 const name = 'why'; const age = 18; const height = 1.88 // ES5的写法 // const obj = &#123; // name: name, // age: age, // height: height // &#125; // const obj = &#123; // name, // age, // height, // &#125; // // console.log(obj); // 2.函数的增强写法 // ES5的写法 // const obj = &#123; // run: function () &#123; // // &#125;, // eat: function () &#123; // // &#125; // &#125; const obj = &#123; run() &#123; &#125;, eat() &#123; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.4、v-on详细说明1.4.1、参数 如果该方法不需要额外参数，那么方法后的()可以不添加。但是注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去 如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;!--1.事件调用的方法没有参数--&gt; &lt;button @click="btn1Click()"&gt;按钮1&lt;/button&gt; &lt;button @click="btn1Click"&gt;按钮1&lt;/button&gt; &lt;!--2.在事件定义时, 写方法时省略了小括号, 但是方法本身是需要一个参数的, 这个时候, Vue会默认将浏览器生产的event事件对象作为参数传入到方法--&gt; &lt;!--&lt;button @click="btn2Click(123)"&gt;按钮2&lt;/button&gt;--&gt; &lt;!--&lt;button @click="btn2Click()"&gt;按钮2&lt;/button&gt;--&gt; &lt;button @click="btn2Click"&gt;按钮2&lt;/button&gt; &lt;!--3.方法定义时, 我们需要event对象, 同时又需要其他参数--&gt; &lt;!-- 在调用方式, 如何手动的获取到浏览器参数的event对象: $event--&gt; &lt;button @click="btn3Click(abc, $event)"&gt;按钮3&lt;/button&gt;&lt;/div&gt;&lt;script src="../js/vue.js"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; message: '你好啊', abc: 123 &#125;, methods: &#123; btn1Click() &#123; console.log("btn1Click"); &#125;, btn2Click(event) &#123; console.log('--------', event); &#125;, btn3Click(abc, event) &#123; console.log('++++++++', abc, event); &#125; &#125; &#125;) // 如果函数需要参数,但是没有传入, 那么函数的形参为undefined // function abc(name) &#123; // console.log(name); // &#125; // // abc()&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.4.2、修饰符 Vue提供了修饰符来帮助我们方便的处理一些事件： .stop - 调用 event.stopPropagation()。 .prevent - 调用 event.preventDefault()。 .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。 .native - 监听组件根元素的原生事件。 .once - 只触发一次回调。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;!--1. .stop修饰符的使用--&gt; &lt;div @click="divClick"&gt; aaaaaaa &lt;button @click.stop="btnClick"&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;!--2. .prevent修饰符的使用--&gt; &lt;br&gt; &lt;form action="baidu"&gt; &lt;input type="submit" value="提交" @click.prevent="submitClick"&gt; &lt;/form&gt; &lt;!--3. .监听某个键盘的键帽--&gt; &lt;input type="text" @keyup.enter="keyUp"&gt; &lt;!--4. .once修饰符的使用--&gt; &lt;button @click.once="btn2Click"&gt;按钮2&lt;/button&gt;&lt;/div&gt;&lt;script src="../js/vue.js"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: '#app', data: &#123; message: '你好啊' &#125;, methods: &#123; btnClick() &#123; console.log("btnClick"); &#125;, divClick() &#123; console.log("divClick"); &#125;, submitClick() &#123; console.log('submitClick'); &#125;, keyUp() &#123; console.log('keyUp'); &#125;, btn2Click() &#123; console.log('btn2Click'); &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1-5、v-if/v-else/v-else-if1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;div v-if="isShow"&gt; &lt;div&gt;&#123;&#123; message + 'hello1' &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;div v-else-if="isHappy"&gt;hhhhh&lt;/div&gt; &lt;div v-else&gt;&#123;&#123; message +'2'&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;!--导入vue.js--&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el:'#app', data:&#123; message:"hello vue", isShow:false, isHappy:true &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.5.1、原理v-if 后面的条件为false 的时候，对应的元素以及子元素不会渲染 1.5.2、案例 vue在进行DOM渲染的时候，处于性能考虑，会尽可能的复用已经存在的元素，而不是重新创建新的元素，如果我们不希望Vue出现重复利用的问题，可以给对应的input添加key,并且保证key的不同 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;form action="#"&gt; &lt;span v-if="isY"&gt; &lt;label for="username"&gt;用户登录&lt;/label&gt; &lt;!-- 防止复用之前缓存 --&gt; &lt;input type="text" id="username" placeholder="用户登录" key="username"&gt; &lt;/span&gt; &lt;span v-else&gt; &lt;label for="email"&gt;邮箱登录&lt;/label&gt; &lt;input type="text" id="email" placeholder="邮箱登录" key="email" key="email"&gt; &lt;/span&gt; &lt;button @click="changeMy()"&gt;切换用户&lt;/button&gt; &lt;/form&gt;&lt;/div&gt;&lt;!--导入vue.js--&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el:'#app', data:&#123; message:"hello vue", isY:true &#125;, methods:&#123; changeMy()&#123; this.isY = !this.isY &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1-6、v-show的使用 v-show当条件为false的时候仅仅是将元素的display的属性设置为none，而v-if 则是压根不会渲染DOM 开发中，当现实与隐藏很频繁的时候，使用v-show当只有一次显示的时候使用v-if 1-7、v-for遍历对象/数组12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; &lt;ul&gt;&lt;!-- 普通的用法--&gt;&lt;!-- &lt;li v-for="item in books"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;--&gt;&lt;!-- 获取序列号--&gt;&lt;!-- &lt;li v-for="(item,index) in books"&gt;&#123;&#123;item&#125;&#125;&amp;#45;&amp;#45;&#123;&#123;index&#125;&#125;&lt;/li&gt;--&gt;&lt;!-- 获取id和序列号--&gt; &lt;li v-for="(item,key,index) in salary" :key="item"&gt;&#123;&#123;item&#125;&#125;--&#123;&#123;key&#125;&#125;--&#123;&#123;index&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;!--导入vue.js--&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el:'#app', data:&#123; message:"hello vue", books:['西游记','三国演义','水浒传','红楼梦'], salary:&#123; 'no1': 100, 'no2': 200, 'no3': 300, &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 官方推荐我们在使用v-for时，给对应的元素或组件添加上一个:key属性。并保证这个属性是唯一的，这样Diff算法可以正确的识别此节点，找到正确的位置区插入新的节点，所以说key的作用是为了高效的更新虚拟DOM 1-8、检测数据更新 push() 向数组末尾添加数据 pop() 删除数组最后的数据 shift() 删除数组开头的数据 unshift() 从开始位置添加数据 splice() 从第几的位置删除数据，或者添加数据插入 sort() 正序排序(按照数组) reverse() 反转数组 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="item in data"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;button @click="updateData()"&gt;按钮&lt;/button&gt;&lt;/div&gt;&lt;!--导入vue.js--&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el:'#app', data:&#123; message:"hello vue", data:['a','c','b','d'] &#125;, methods:&#123; updateData()&#123; // 1、push() 向数组末尾添加数据 // this.data.push('aaa','ddd') //2、pop() 删除数组最后的数据 // this.data.pop() //3、shift() 删除数组开头的数据 // this.data.shift() //4、unshift() 从开始位置添加数据 // this.data.unshift('why') //5、splice() 从第几的位置删除数据，或者添加数据插入 // this.data.splice(1,0,'hello')//从第二的位置插入数据 // this.data.splice(1,1,'hello')//从第二的位置修改数据 // this.data.splice(1,2)//从第二的位置删除两个数据 //6、sort() 正序排序(按照数组) // this.data.sort() //7、reverse() 反转数组 this.data.reverse() &#125; &#125; &#125;);&lt;/script&gt; 1.9、图书购物车（案例）123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="main.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;div v-if="books.length"&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;书籍名称&lt;/th&gt; &lt;th&gt;出版日期&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;购买数量&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tbody&gt; &lt;tr v-for="(item,index) in books"&gt; &lt;th&gt;&#123;&#123;item['id']&#125;&#125;&lt;/th&gt; &lt;th&gt;&#123;&#123;item['name']&#125;&#125;&lt;/th&gt; &lt;th&gt;&#123;&#123;item['date']&#125;&#125;&lt;/th&gt; &lt;th&gt;&#123;&#123;item['price'] | showPrice&#125;&#125;&lt;/th&gt; &lt;th&gt; &lt;button @click="decrement(index)" v-bind:disabled="item.number&lt;=1"&gt;-&lt;/button&gt; &#123;&#123;item['number']&#125;&#125; &lt;button @click=increment(index)&gt;+&lt;/button&gt; &lt;/th&gt; &lt;th&gt;&lt;button @click=removeHandle(index)&gt;删除&lt;/button&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div&gt;总价格&#123;&#123;totalPrice | showPrice&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;div v-else&gt;购物车为空&lt;/div&gt;&lt;/div&gt;&lt;!--导入vue.js--&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;script src="main.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516table&#123; border:1px solid #e9e9e9; border-collapse: collapse; border-spacing: 0;&#125;th,td&#123; padding:8px 16px; border:1px solid #e9e9e9; text-align: left;&#125;th&#123; background-color: #f7f7f7; color:#5c6b77; font-weight: 600;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const app = new Vue(&#123; el:'#app', data:&#123; books:[&#123; "id":1, "name":"《算法导论》", "date":'2006-01', "price":85.00, "number":1 &#125;,&#123; "id":2, "name":"《算法导论》", "date":'2006-01', "price":85.00, "number":1 &#125;,&#123; "id":3, "name":"《算法导论》", "date":'2006-01', "price":85.00, "number":1 &#125;,&#123; "id":4, "name":"《算法导论》", "date":'2006-01', "price":85.00, "number":1 &#125;] &#125;, methods:&#123; decrement(index)&#123; this.books[index].number-- &#125;, increment(index)&#123; this.books[index].number++ &#125;, removeHandle(index) &#123; this.books.splice(index, 1) &#125; &#125;, computed:&#123; totalPrice()&#123; let totalPrice = 0 for (let i = 0; i &lt; this.books.length; i++) &#123; totalPrice += this.books[i].price * this.books[i].number &#125; return totalPrice &#125; &#125;, filters:&#123; showPrice(price)&#123; return '￥'+price.toFixed(2) &#125; &#125;&#125;) 2.0、高阶函数的js123456789101112131415161718192021222324//高阶函数的使用//filter函数 返回true则会把n加到新数组中。false则不会const num = [20,30,40,21,22,40]let nums = num.filter(function (n) &#123; return n&lt;30&#125;)//map函数 便利数组，返回计算后的值let nums = num.map(function (n) &#123; return n*2&#125;)//reduce函数let nums = num.reduce(function (previousValue,n) &#123; return previousValue+n&#125;,0)//函数式编程链式操作let nums = num.filter(function (n) &#123; return n&lt;30&#125;).map(function (n) &#123; return n*2&#125;).reduce(function (previousValue,n) &#123; return previousValue+n&#125;,0)let nums = num.filter(n=&gt;n&lt;30).map(n=&gt;n*2).reduce(((previousValue,n)=&gt;previousValue+n),0);console.log(nums); 2.1、v-model 原理2.1.1、基本原理v-model 是 v-bind和v-on 的指令的结合 1234567891011121314151617181920212223242526&lt;body&gt;&lt;div id="app"&gt;&lt;!-- &lt;input type="text" v-model="message"&gt;--&gt;&lt;!-- v-model实际上是两个指令的合计 v-on 和 v-bind:input--&gt;&lt;!-- &lt;input type="text" v-bind:value="message" v-on:input="myChange"&gt;--&gt;&lt;!-- 简便写法--&gt; &lt;input type="text" :value="message" @input="message = $event.target.value"&gt; &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;!--导入vue.js--&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el:'#app', data:&#123; message:"hello vue" &#125;, methods:&#123; myChange(event)&#123; this.message = event.target.value &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt; 2.1.2、v-model在单选/多选/复选框/下拉框 之间的使用 radio 12345678910111213141516171819202122&lt;div id="app"&gt; &lt;label for="mail"&gt; &lt;input type="radio" value="男" v-model="sex" name="sex" id="mail"&gt; &lt;/label&gt; &lt;label for="famail"&gt; &lt;input type="radio" value="女" v-model="sex" name="sex" id="famail"&gt; &lt;/label&gt; &lt;div&gt;&#123;&#123; message &#125;&#125; 您选择的是 &#123;&#123;sex&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;!--导入vue.js--&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el:'#app', data:&#123; message:"hello vue", sex:'女' &#125; &#125;);&lt;/script&gt; 多选框 1234567891011121314151617181920212223242526272829&lt;div id="app"&gt; &lt;!--单选框--&gt;&lt;!-- &lt;label for="agree"&gt;--&gt;&lt;!-- &lt;input type="checkbox" id="agree" v-model="isAgree" &gt; 同意协议--&gt;&lt;!-- &lt;/label&gt;--&gt;&lt;!-- &lt;div&gt;你选择的是：&#123;&#123;isAgree&#125;&#125;&lt;/div&gt;--&gt;&lt;!-- &lt;button v-bind:disabled="!isAgree"&gt;下一步&lt;/button&gt;--&gt;&lt;!-- 多选框--&gt; &lt;label for="id1"&gt; &lt;input id="id1" type="checkbox" value="篮球1" v-model="hobby"&gt;篮球1&lt;/label&gt; &lt;label for="id2"&gt; &lt;input id="id2" type="checkbox" value="篮球2" v-model="hobby"&gt;篮球2&lt;/label&gt; &lt;label for="id3"&gt; &lt;input id="id3" type="checkbox" value="篮球3" v-model="hobby"&gt;篮球3&lt;/label&gt; 您的爱好是：&#123;&#123;hobby&#125;&#125;&lt;/div&gt;&lt;!--导入vue.js--&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el:'#app', data:&#123; message:"hello vue", isAgree:false, hobby:[] &#125; &#125;);&lt;/script&gt; 下拉框 1234567891011121314151617181920212223242526272829303132333435&lt;div id="app"&gt; &lt;select name="abc" id="" v-model="fruit"&gt; &lt;option value="苹果1" &gt;苹果1&lt;/option&gt; &lt;option value="苹果2" &gt;苹果2&lt;/option&gt; &lt;option value="苹果3" &gt;苹果3&lt;/option&gt; &lt;option value="苹果4" &gt;苹果4&lt;/option&gt; &lt;option value="苹果5" &gt;苹果5&lt;/option&gt; &lt;option value="苹果6" &gt;苹果6&lt;/option&gt; &lt;/select&gt; &lt;div&gt;您选择的水果是：&#123;&#123;fruit&#125;&#125;&lt;/div&gt; &lt;select name="abc" v-model="fruits" multiple&gt; &lt;option value="苹果1" &gt;苹果1&lt;/option&gt; &lt;option value="苹果2" &gt;苹果2&lt;/option&gt; &lt;option value="苹果3" &gt;苹果3&lt;/option&gt; &lt;option value="苹果4" &gt;苹果4&lt;/option&gt; &lt;option value="苹果5" &gt;苹果5&lt;/option&gt; &lt;option value="苹果6" &gt;苹果6&lt;/option&gt; &lt;/select&gt; &lt;div&gt;您选择的水果是：&#123;&#123;fruits&#125;&#125;&lt;/div&gt;&lt;/div&gt; &lt;!--导入vue.js--&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el:'#app', data:&#123; message:"hello vue", fruit:'苹果1', fruits:['苹果1','苹果2'] &#125; &#125;);&lt;/script&gt; 2.1.3、值绑定12345678910111213141516171819&lt;div id="app"&gt; &lt;select name="abc" multiple&gt; &lt;option v-for="item in fruits" :value="item" &gt;&#123;&#123;item&#125;&#125;&lt;/option&gt; &lt;/select&gt; &lt;div&gt;您选择的水果是：&#123;&#123;fruits&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;!--导入vue.js--&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el:'#app', data:&#123; message:"hello vue", fruit:'苹果1', fruits:['苹果1','苹果2'] &#125; &#125;);&lt;/script&gt; 2.1.4、v-model修饰符1234567891011121314151617181920212223&lt;div id="app"&gt;&lt;!-- lazy:当失去焦点或者回车的时候才会更新message--&gt; &lt;input type="text" v-model.lazy="message"&gt;&lt;!-- number:更新message的时候类型为number--&gt; &lt;input type="number" v-model.number="message"&gt;&lt;!-- trim:修改输入框中左右两边的空格--&gt; &lt;input type="text" v-model.trim="message"&gt; &lt;br&gt; &#123;&#123;message&#125;&#125;-----&#123;&#123;typeof message&#125;&#125;&lt;/div&gt;&lt;!--导入vue.js--&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el:'#app', data:&#123; message:"hello vue" &#125; &#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js笔记一]]></title>
    <url>%2F2021%2F05%2F18%2Fvue.js%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[No1、构建vue.js项目一、显示数据12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;demo1&lt;/title&gt; &lt;!--导入vue.js--&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;span v-bind:title="message"&gt;鼠标悬浮&lt;/span&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; message:"hello vue" &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 二、条件12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;demo1&lt;/title&gt; &lt;!--导入vue.js--&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;div v-if="ok"&gt;yes&lt;/div&gt; &lt;h1 v-else&gt;no&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; ok:true &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 三、循环1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;demo1&lt;/title&gt; &lt;!--导入vue.js--&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;li v-for="item in items"&gt;&#123;&#123;item.message&#125;&#125;&lt;/li&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; items:[ &#123;message:"11111"&#125;, &#123;message:"22"&#125;, &#123;message:"3333"&#125;, ], ok:true &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 四、事件 语法糖用@表示来替换v-on: 参数问题 不传参数可以省略小括号——btnClick 方法中默认有event参数。。btnClick(event) 方法中有参数，并且需要event。则btnClick(abc,event)-&gt;$event 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;demo1&lt;/title&gt; &lt;!--导入vue.js--&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;button v-on:click="sayHi"&gt;click Me&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; message:"hello" &#125;, methods:&#123; sayHi:function (event)&#123; alert(this.message) &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 五、双向绑定1234567891011121314151617181920212223242526272829303132333435363738&lt;!--双向绑定--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;demo1&lt;/title&gt; &lt;!--导入vue.js--&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;输入的文本：&lt;input type="text" v-model="message"&gt;&#123;&#123;message&#125;&#125; 性别： &lt;input type="radio" name="sex" value="男" v-model="checked" checked&gt; 男 &lt;input type="radio" name="sex" value="女" v-model="checked"&gt; 女 选中了：&#123;&#123;checked&#125;&#125; &lt;select name="" id="" v-model="selectioned"&gt; &lt;option value="A" selected&gt;A&lt;/option&gt; &lt;option value="B" &gt;B&lt;/option&gt; &lt;option value="C" &gt;C&lt;/option&gt; &lt;/select&gt; 多选中了：&#123;&#123;selectioned&#125;&#125;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; message:"123", checked:"男", selectioned:"A" &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 六、定义一个组件12345678910111213141516171819202122232425262728293031&lt;!--组件--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;demo1&lt;/title&gt; &lt;!--导入vue.js--&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;my-component v-for="item in items" v-bind:itemss="item"&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; //定义一个Vue组件component Vue.component("my-component",&#123; props:['itemss'], template:'&lt;li&gt;&#123;&#123;itemss&#125;&#125;&lt;/li&gt;' &#125;) var vm = new Vue(&#123; el:'#app', data:&#123; items:["java","Linux","ddd"] &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 七、Axios异步通信12345678910111213141516171819202122232425262728293031323334353637383940&lt;!--Axios异步通信--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;demo1&lt;/title&gt; &lt;!--导入vue.js--&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="vue"&gt; &lt;div&gt; &#123;&#123;info.name&#125;&#125; &#123;&#123;info.address.city&#125;&#125; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#vue', data()&#123; return&#123; info:&#123; name:null, address:&#123; street:null, city:null &#125;, &#125; &#125; &#125;, mounted()&#123; axios.get('../package.json').then(response=&gt;(this.info = response.data)) &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 八、计算属性 计算属性和methods的对比 计算属性在多次使用时，只会调用一次 他是有缓存的 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!--计算属性--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;demo1&lt;/title&gt; &lt;!--导入vue.js--&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; 1：&#123;&#123;currentTime1()&#125;&#125; 2：&#123;&#123;currentTime2&#125;&#125;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; message:'hello world' &#125;, methods:&#123; currentTime1:function () &#123; return Date.now();//返回一个时间戳 &#125; &#125;, computed:&#123; currentTime2:function () &#123; return Date.now(); &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 九、插槽123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!--slot--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;demo1&lt;/title&gt; &lt;!--导入vue.js--&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;todo&gt; &lt;todo-title slot="todo-title" :title="title"&gt;&lt;/todo-title&gt; &lt;todo-items slot="todo-items" v-for="item1 in todoItems" :item2="item1"&gt;&lt;/todo-items&gt; &lt;/todo&gt;&lt;/div&gt;&lt;script&gt; //slot：插槽 Vue.component("todo",&#123; template: '&lt;div&gt;\ &lt;slot name="todo-title"&gt;&lt;/slot&gt;\ &lt;ul&gt;\ &lt;slot name="todo-items"&gt;&lt;/slot&gt;\ &lt;/ul&gt;\ &lt;/div&gt;' &#125;) Vue.component("todo-title",&#123; props:['title'], template: '&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;' &#125;) Vue.component("todo-items",&#123; props:['item2'], template: '&lt;div&gt;&#123;&#123;item2&#125;&#125;&lt;/div&gt;' &#125;) var vm = new Vue(&#123; el:'#app', data:&#123; title:"sss", todoItems:['hello world','dddddd'] &#125;, &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 十、自定义内容分发123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!--自定义内容分发--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;demo1&lt;/title&gt; &lt;!--导入vue.js--&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;todo&gt; &lt;todo-title slot="todo-title" :title="title"&gt;&lt;/todo-title&gt; &lt;todo-items slot="todo-items" v-for="(item1,index) in todoItems" :item2="item1" :index="index" v-on:remove="removeItems(index)"&gt;&lt;/todo-items&gt; &lt;/todo&gt;&lt;/div&gt;&lt;script&gt; //slot：插槽 Vue.component("todo",&#123; template: '&lt;div&gt;\ &lt;slot name="todo-title"&gt;&lt;/slot&gt;\ &lt;ul&gt;\ &lt;slot name="todo-items"&gt;&lt;/slot&gt;\ &lt;/ul&gt;\ &lt;/div&gt;' &#125;) Vue.component("todo-title",&#123; props:['title'], template: '&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;' &#125;) Vue.component("todo-items",&#123; props:['item2','index'], template: '&lt;li&gt;&#123;&#123;item2&#125;&#125; &lt;button @click="remove()"&gt;删除&lt;/button&gt;&lt;/li&gt;', methods:&#123; remove:function (index) &#123; // vm.removeItems(this.index); this.$emit('remove',index) &#125; &#125; &#125;) var vm = new Vue(&#123; el:'#app', data:&#123; title:"sss", todoItems:['hello world','dddddd'] &#125;, methods: &#123; removeItems:function (index) &#123; console.log("删除了"+this.todoItems[index]+"OK") this.todoItems.splice(index,1);//一次删除一个元素 &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring黑马学习笔记五]]></title>
    <url>%2F2021%2F04%2F28%2FSpring%E9%BB%91%E9%A9%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94%2F</url>
    <content type="text"><![CDATA[打卡第五天。加油。。。。 Spring的AOPAOP的意思是面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP是OOP的延续，是函数式编程的一种衍生泛型，利用AOP可以对业务逻辑的各个部分进行隔离，从而使业务逻辑各部分之间的耦合度降低，提高程序的可用性，同时提高了开发的效率。 作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强 优势：减少重复代码，提高开发效率，并且便于维护 1、AOP的底层实现实际上，AOP的底层是通过Spring提供的动态代理技术实现的，在运行期间，Spring通过动态代理技术动态生成代理对象代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。 2、AOP的动态代理技术常用的动态代理技术 JDK代理：基于接口的动态代理技术 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//Advicepackage com.wwq.proxy.jdk;public class Advice &#123; public void before()&#123; System.out.println("前置增强。。。。。"); &#125; public void afterReturning()&#123; System.out.println("后置增强。。。。。。"); &#125;&#125;//ProxyTestpackage com.wwq.proxy.jdk;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyTest &#123; public static void main(String[] args) &#123; //目标对象 final Target target = new Target(); //增强对象 final Advice advice = new Advice(); //返回值就是动态生成的代理对象 TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance( target.getClass().getClassLoader(),//目标对象类加载器 target.getClass().getInterfaces(),//目标对象相同的接口字节码对象数组 new InvocationHandler() &#123; //去调用代理对象的任何方法，实际执行的都是invoke方法 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //前置增强 advice.before(); //执行目标方法 method.invoke(target, args);//执行目标方法 //后置增强 advice.afterReturning(); return null; &#125; &#125; ); //调用代理对象的方法 proxy.save(); &#125;&#125;//Targetpackage com.wwq.proxy.jdk;public class Target implements TargetInterface &#123; public void save() &#123; System.out.println("save running....."); &#125;&#125;//TargetInterfacepackage com.wwq.proxy.jdk;public interface TargetInterface &#123; public void save();&#125; cglib 代理：基于父类的动态代理技术 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//Advicepackage com.wwq.proxy.cglib;public class Advice &#123; public void before()&#123; System.out.println("前置增强。。。。。"); &#125; public void afterReturning()&#123; System.out.println("后置增强。。。。。。"); &#125;&#125;//ProxyTestpackage com.wwq.proxy.cglib;import com.wwq.proxy.jdk.TargetInterface;import org.springframework.cglib.proxy.Enhancer;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.proxy.MethodProxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyTest &#123; public static void main(String[] args) &#123; //目标对象 final Target target = new Target(); //增强对象 final Advice advice = new Advice(); //返回值就是动态生成的代理对象，基于cglib //1、 创建增强器 final Enhancer enhancer = new Enhancer(); //2、 设置父类（目标） enhancer.setSuperclass(Target.class); //3、 设置回调 enhancer.setCallback(new MethodInterceptor() &#123; public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; //执行前置 advice.before(); //执行目标 Object invoke = method.invoke(target, args); //执行后置 advice.afterReturning(); return invoke; &#125; &#125;); //4、 创建代理对象 Target target1 = (Target) enhancer.create(); target1.save(); &#125;&#125;//Targetpackage com.wwq.proxy.cglib;public class Target&#123; public void save() &#123; System.out.println("save running....."); &#125;&#125; 下面是4月29号学习的。昨天啥也没干。打卡第六天 3、基于XML的AOP开发3.1快速入门 导入AOP相关坐标 创建目标接口和目标类（内部有切点） 创建切面类（内部有增强方法） 将目标类和切面类的对象创建权交给spring 在applicationController.xml中配置织入关系 测试代码 今天是2021年5月10日，中间间断了一些时间。复习之前的一些知识。现在开始，继续学习。打卡第七天 applicationContext.xml 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 目标对象--&gt; &lt;bean id="target" class="com.wwq.aop.Target"/&gt;&lt;!-- 切面对象--&gt; &lt;bean id="myAspect" class="com.wwq.aop.MyAspect"/&gt;&lt;!-- 配置植入，告诉spring框架，哪些方法（切点）--&gt; &lt;aop:config&gt;&lt;!-- 声明切面--&gt;&lt;!----&gt; &lt;aop:aspect ref="myAspect"&gt;&lt;!-- 切面，切点，通知--&gt; &lt;aop:before method="before" pointcut="execution(public void com.wwq.aop.Target.save())" /&gt; &lt;aop:after method="after" pointcut="execution(public void com.wwq.aop.Target.save())" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;context:component-scan base-package="com.wwq"/&gt;&lt;/beans&gt; MyAspect.java 12345678910package com.wwq.aop;public class MyAspect &#123; public void before()&#123; System.out.println("前置增强。。。。。。"); &#125; public void after()&#123; System.out.println("后置增强。。。。"); &#125;&#125; 3.2 XML配置AOP详解1、切点表达式的写法 表达式语法： execution([修饰符]返回值类型 报名，类名，方法名（参数）) 访问修饰符可以省略 返回值类型，包名，类名，方法名可以使用星号*代表任意 包名与类名之间的一个点，代表当前包下的类，两个点表示当前包及其子包下的类 参数列表可以使用两个点..表示任意个数，任意类型的参数列表 例如 12exection(* com.itheima.aop.*.*(..))exection(* *..*.*(..)) 2、增强的一些配置 123456789101112 &lt;aop:aspect ref="myAspect"&gt;&lt;!-- 切面，切点，通知--&gt;&lt;!-- &lt;aop:before method="before" pointcut="execution(public void com.wwq.aop.Target.save())" /&gt;--&gt;&lt;!-- 前置增强--&gt; &lt;aop:before method="before" pointcut="execution(* com.wwq.aop.*.*(..))" /&gt;&lt;!-- 后置增强--&gt; &lt;aop:after method="after" pointcut="execution(public void com.wwq.aop.Target.save())" /&gt;&lt;!-- 环绕--&gt; &lt;aop:around method="around" pointcut="execution(* com.wwq.aop.*.*(..))"/&gt;&lt;!-- 异常--&gt; &lt;aop:after-throwing method="afterThrowing" pointcut="execution(* com.wwq.aop.*.*(..))"/&gt; &lt;/aop:aspect&gt; 3、通知的配置语法 1&lt;aop:通知类型 method="切面类中方法名" pointcut="切点表达式"&gt;&lt;/aop:通知类型&gt; 名称 标签 说明 前置通知 &lt; aop:before &gt; 用于配置前置通知。指定增强的方法在切入点方法之前执行。 后置通知 &lt; aop:after-returning &gt; 用于配置环绕通知。指定增强的方法在切入点方法之后执行。 环绕通知 &lt; aop:around &gt; 用于配置环绕通知。指定增强的方法在切入点方法之前和之后执行 异常抛出通知 &lt; aop:throwing &gt; 用于配置一场抛出通知。执行增强的方法在出现异常的时候执行 最终通知 &lt; aop:after &gt; 用于配置最终通知。无论增强的方式执行是否有异常都会执行 3.3 基于注解的AOP开发1、注解的配置语法 1@通知注解("切点表达式")//通知的配置语法 名称 标签 说明 前置通知 @Before 用于配置前置通知。指定增强的方法在切入点方法之前执行。 后置通知 @AfterReturning 用于配置环绕通知。指定增强的方法在切入点方法之后执行。 环绕通知 @Around 用于配置环绕通知。指定增强的方法在切入点方法之前和之后执行 异常抛出通知 @AfterThrowing 用于配置一场抛出通知。执行增强的方法在出现异常的时候执行 最终通知 @After 用于配置最终通知。无论增强的方式执行是否有异常都会执行]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring黑马学习笔记四]]></title>
    <url>%2F2021%2F04%2F26%2FSpring%E9%BB%91%E9%A9%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[打卡第四天。加油。。。。 第四天发现，复习完之前学的，啥也没做。。。。 1、Spring注解开发1）Spring原始注解主要是替代&lt; bean &gt;的配置 注解 说明 @Component 使用在类上用于实例化Bean @Controller 使用在web层类上用实例化Bean @Service 使用在service层类上用于实例化Bean @Repository 使用在dao层类上用于实例化Bean @Autowired 使用在字段上用于根据类型依赖注入 @Qualifier 结合@Autowired一起使用用于根据名称进行依赖注入 @Resource 相当于@Autowired+@Qualifier,按照名称进行注入 @Value 注入普通属性 @Scope 注入Bean的作用范围 @PostConstruct 使用在方法上标注该方法时Bean的初始化方法 @PreDestroy 使用在方法上标注该方法时Bean的销毁方法 UserDaoImpl.java 1234567891011package com.wwq.dao;import org.springframework.stereotype.Component;// &lt;bean id="userDao" class="com.wwq.dao.UserDaoImpl"/&gt;@Component("userDao")public class UserDaoImpl implements UserDao &#123; public void save() &#123; System.out.println("save Running...."); &#125;&#125; UserServiceImpl.java 123456789101112131415161718192021222324252627package com.wwq.service;import com.wwq.dao.UserDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Component;import javax.annotation.Resource;// &lt;bean id="userService" class="com.wwq.service.UserServiceImpl"&gt;@Component("userService")public class UserServiceImpl implements UserService &#123; // &lt;property name="userDao" ref="userDao"/&gt; //如果只按照类型注入则，只写@Autowired就行，如果需要按照名称注入则需要加上@Qualifier @Autowired @Qualifier("userDao")// 相当于@Autowired+Qualifier// @Resource private UserDao userDao; //xml方式必须要写set方法，注解方式可以省略 //public void setUserDao(UserDao userDao)&#123; // this.userDao = userDao; //&#125; public void save() &#123; userDao.save(); &#125;&#125; applicationContext.xml 12&lt;!-- 配置组件扫描--&gt;&lt;context:component-scan base-package="com.wwq"/&gt; 2）Spring的新注解 注释 说明 @Configuration 用于指定当前类是一个Spring配置类，当创建容器时会从该类上加载注释 @ComponentScan 用于指定Spring在初始化容器时要扫描的包。作用和在Spring的xml配置文件中的&lt;context:component-scan base-package=”com.itheima”/&gt;一样 @Bean 使用在方法上，标注将该方法的返回值存储至Spring容器中 @PropertySource 用于加载properties文件中的配置 @import 用于导入其他配置类 需要替换的注解包括： 非定义的Bean的配置：&lt; bean &gt; 加载properties文件的配置：&lt; context:property-placeholder &gt; 组件扫描的配置：&lt; context:component-scan &gt; 引入其他文件：&lt; import &gt; SpringConfiguration.java 1234567891011121314151617package com.wwq.config;import com.mchange.v2.c3p0.ComboPooledDataSource;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.*;import java.beans.PropertyVetoException;//标志该类是Spring的核心配置文件@Configuration//&lt;context:component-scan base-package="com.wwq"/&gt;@ComponentScan("com.wwq")//&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;@PropertySource("classpath:jdbc.properties")@Import(&#123;DataSourceConfiguration.class&#125;)public class SpringConfiguration &#123;&#125; DataSourceConfiguration.java 123456789101112131415161718192021222324252627282930313233package com.wwq.config;import com.mchange.v2.c3p0.ComboPooledDataSource;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.PropertySource;import java.beans.PropertyVetoException;//&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;@PropertySource("classpath:jdbc.properties")public class DataSourceConfiguration &#123; @Value("$&#123;jdbc.driver&#125;") private String driver; @Value("$&#123;jdbc.url&#125;") private String url; @Value("$&#123;jdbc.username&#125;") private String username; @Value("$&#123;jdbc.password&#125;") private String password; @Bean("dataSource")//Spring会将当前方法的返回值以指定名称，存储到Spring容器中 public ComboPooledDataSource getDataSource() throws PropertyVetoException &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(username); dataSource.setPassword(password); return dataSource; &#125;&#125; 测试代码（UserController.java） 123456789101112131415package com.wwq.web;import com.wwq.config.SpringConfiguration;import com.wwq.service.UserService;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class UserController &#123; public static void main(String[] args) &#123; //ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext("applicationContext.xml"); ApplicationContext app = new AnnotationConfigApplicationContext(SpringConfiguration.class); UserService userService = app.getBean(UserService.class); userService.save(); &#125;&#125; 2、Spring整合Junit1、Spring集成Junit步骤 导入spring集成Junit的坐标 使用@Runwith注解替换原来的运行期 使用@ContextConfiguration指定配置文件或配置类 使用@Autowired注入需要测试的对象 创建测试方法进行测试]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring黑马学习笔记三]]></title>
    <url>%2F2021%2F04%2F25%2FSpring%E9%BB%91%E9%A9%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89%2F</url>
    <content type="text"><![CDATA[中途休息两天，有事情耽误了，果然成年人的世界，是不能好好学习的。打卡第三天。。。。继续加油。！！ Spring 配置数据源1、数据源（连接池）的作用提高程序性能 常见的数据源：DBCP,C3P0,BoneCp,Druid等 2、数据源的配置和使用 引入jar包 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;spring_anno&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.35&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; DataSourceTest 123456789101112131415161718192021222324252627282930313233343536package com.wwq;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.pool.DruidPooledConnection;import com.mchange.v2.c3p0.ComboPooledDataSource;import org.junit.Test;import java.sql.Connection;public class DataSourceTest &#123; @Test //手动创建druid数据源 public void test2() throws Exception &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql://localhost:3306/test"); dataSource.setName("root"); dataSource.setPassword(""); DruidPooledConnection connection = dataSource.getConnection(); System.out.println(connection); connection.close(); &#125; @Test //手动创建c2p0数据源 public void test1() throws Exception &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass("com.mysql.jdbc.Driver"); dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/"); dataSource.setUser("root"); dataSource.setPassword(""); Connection connection = dataSource.getConnection(); System.out.println(connection); connection.close(); &#125;&#125; 3、Spring配置数据源 applicationContext.xml 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 加载外部的properties文件 --&gt; &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;bean id="dataSouse" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/bean&gt;&lt;/beans&gt; jdbc.properties 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testjdbc.username=rootjdbc.password= DataSourceTest 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.wwq;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.pool.DruidPooledConnection;import com.mchange.v2.c3p0.ComboPooledDataSource;import javafx.application.Application;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import javax.annotation.Resource;import javax.sql.DataSource;import java.sql.Connection;import java.util.ResourceBundle;public class DataSourceTest &#123; @Test //测试Spring容器产生数据源对象 public void test4() throws Exception &#123; ApplicationContext app = new ClassPathXmlApplicationContext("applicationContext.xml"); DataSource dataSouse = app.getBean("dataSouse", DataSource.class); Connection connection = dataSouse.getConnection(); System.out.println(connection); connection.close(); &#125; @Test //手动创建c2p0数据源(加载properties配置文件) public void test3() throws Exception &#123; ResourceBundle rb = ResourceBundle.getBundle("jdbc"); String driver = rb.getString("jdbc.driver"); String url = rb.getString("jdbc.url"); String username = rb.getString("jdbc.username"); String password = rb.getString("jdbc.password"); //创建数据源对象 ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(username); dataSource.setPassword(password); Connection connection = dataSource.getConnection(); System.out.println(connection); connection.close(); &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring黑马学习笔记二]]></title>
    <url>%2F2021%2F04%2F22%2FSpring%E9%BB%91%E9%A9%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[计划一周时间，学习javaspring 不知道能学习到什么水平，坚持，也是对自己的一点肯定。第二天打卡。 一、Spring 配置文件1、Bean的标签范围 singleton 默认值，单例 bean的实例化个数为1 当加载配置文件的时候，Bean就会被创建 prototype 多例的 实例化对象为多个 当使用getBean()方法的时候，Bean才会创建 2、Bean生命周期配置 init-method:指定类中的初始化方法名称 对象创建完成后，通过对象调用初始化方法 destory-method:指定类中销毁方法名称1&lt;bean id="userDao" class="com.wwq.dao.impl.UserDaoImpl" init-method="init" destroy-method="destory"/&gt; 3、Bean实例化的三种方式 无参构造方法实例化 工厂静态方法实例化 工厂实例方法实例化 4、Bean的依赖注入分析因为UserService和UserDao都在Spring容器中，而最终程序直接使用的是UserService,所以在Spring容器中，将UserDao设置到UserService内部 5、Bean的依赖注入概念依赖注入（Dependency Injection）:它是Spring框架核心Ioc的具体实现。 在编写程序时，通过控制反转，把对象的创建交给Spring。但是代码中不可能出现没有依赖的情况，IOC解耦只是降低他们的依赖关系，但不会消除，例如：业务层仍然会调用持久层的方法 那这种业务层和持久层的依赖关系，在使用Spring之后，就让Spring来维护了。简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取 6、Bean依赖注入的方式 构造方法 set方法 123456789101112131415//UserServiceImpl.javapublic class UserServiceImpl implements UserService&#123; private UserDao userDao; //set方法注入 //public void setUserDao(UserDao userDao) &#123; // this.userDao = userDao; //&#125; //构造方法注入 public UserServiceImpl(UserDao userDao) &#123; this.userDao = userDao; &#125; public UserServiceImpl() &#123; &#125; 123456 //set方法注入配置 &lt;bean id="userDao" class="com.wwq.dao.impl.UserDaoImpl"/&gt; &lt;bean id="userService" class="com.wwq.service.UserServiceImpl"&gt; //name的值是UserServiceImpl中set方法setUserDao的set后面的值UserDao U小写得来的。 &lt;property name="userDao" ref="userDao"/&gt; &lt;/bean&gt; 12345//构造方法注入&lt;bean id="userDao" class="com.wwq.dao.impl.UserDaoImpl"/&gt;&lt;bean id="userService" class="com.wwq.service.UserServiceImpl"&gt; &lt;constructor-arg ref="userDao"/&gt; &lt;/bean&gt; p方法注入（本质也是set方法注入） 配置文件中要引入P命名空间 1xmlns:p="http://www.springframework.org/schema/p" 12&lt;!--p方法注入--&gt;&lt;bean id="userService" class="com.wwq.service.UserServiceImpl" p:userDao-ref="userDao"/&gt; 发现打卡是真的难啊，刚过两天就没能坚持下来，不说了。继续。。。。今天是2021年4月25日。。。感谢五一长假。 7、Bean的依赖注入的数据类型bean除了对象的引用可以注入，普通的数据类型，集合都可以在容器中进行注入。 普通数据类型 applicationContext.xml 12345678&lt;bean id="userDao" class="com.wwq.dao.impl.UserDaoImpl"&gt; &lt;property name="username" value="xx"/&gt; &lt;property name="age" value="14"/&gt; &lt;/bean&gt; &lt;bean id="userService" class="com.wwq.service.UserServiceImpl"&gt; &lt;constructor-arg ref="userDao"/&gt;&lt;/bean&gt; UserDaoImpl.java 123456789101112131415private String username;private int age; public void setUsername(String username) &#123; this.username = username;&#125; public void setAge(int age) &#123; this.age = age;&#125; public void save() &#123; System.out.println(username+"======="+age); System.out.println("save running.....");&#125; 引用数据类型 applicationContext.xml 1234567&lt;bean id="userDao" class="com.wwq.dao.impl.UserDaoImpl"/&gt; &lt;bean id="userService" class="com.wwq.service.UserServiceImpl"&gt; &lt;property name="userDao" ref="userDao"/&gt;&lt;/bean&gt;&lt;bean id="userService" class="com.wwq.service.UserServiceImpl"&gt; &lt;constructor-arg ref="userDao"/&gt;&lt;/bean&gt; UserServiceImpl.java 12345678private UserDao userDao; //set方法注入 public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void save() &#123; userDao.save(); &#125; 集合数据类型 list map properties application.xml 123456789101112131415161718192021222324252627282930313233343536&lt;bean id="userDao" class="com.wwq.dao.impl.UserDaoImpl"&gt; &lt;property name="strList"&gt; &lt;!-- list --&gt; &lt;list&gt; &lt;value&gt;小王1&lt;/value&gt; &lt;value&gt;小王2&lt;/value&gt; &lt;value&gt;小王3&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- map --&gt; &lt;property name="useMap"&gt; &lt;map&gt; &lt;entry key="u1" value-ref="user1"/&gt; &lt;entry key="u2" value-ref="user2"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- properties --&gt; &lt;property name="properties"&gt; &lt;props&gt; &lt;prop key="p1"&gt;pp1&lt;/prop&gt; &lt;prop key="p2"&gt;pp2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="user1" class="com.wwq.domain.User"&gt; &lt;property name="name" value="汤姆"/&gt; &lt;property name="addr" value="北京"/&gt; &lt;/bean&gt; &lt;bean id="user2" class="com.wwq.domain.User"&gt; &lt;property name="name" value="汤姆"/&gt; &lt;property name="addr" value="北京"/&gt; &lt;/bean&gt; &lt;bean id="userService" class="com.wwq.service.UserServiceImpl"&gt; &lt;constructor-arg ref="userDao"/&gt; &lt;/bean&gt; &lt;/beans&gt; UserDaoImpl.java 12345678910private List&lt;String&gt; strList;private Map&lt;String, User&gt; useMap;private Properties properties;public void save() &#123; System.out.println(strList); System.out.println(useMap); System.out.println(properties); System.out.println("save running.....");&#125; 8、引入其他配置文件（分模块开发）实际开发中。配置文件很繁杂其体积强大，所以将配置文件拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载 1&lt;import resource="applicationContext-xxx.xml" 9、知识要点Spring的重点配置 &lt; bean &gt;标签 id属性：在容器中Bean实例的唯一标识，不允许重复 class属性：要实例化的Bean的全限定名 scopre属性：Bean的作用范围，常用的是singleton（默认）和prototype &lt; property &gt;标签：属性注入 name属性：属性名称 value属性：注入的普通属性值 ref属性：注入对象的引用值 &lt; list &gt;标签 &lt; map &gt; 标签 &lt; properties &gt; 标签 &lt; constructor-arg &gt; 标签 &lt; import &gt;标签：导入其他的Spring的分文件]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring黑马学习笔记一]]></title>
    <url>%2F2021%2F04%2F21%2FSpring%E9%BB%91%E9%A9%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[计划一周时间，学习javaspring 不知道能学习到什么水平，坚持，也是对自己的一点肯定。第一天打卡。 Spring 简介 Spring是分层的java SE/EE应用full-stack轻量级开源框架，以Ioc（Inverse Of Control:反转控制）和AOP（Aspect Oriented Programming:面向切面编程）为内核 Ioc：反转bin的创建权 优势 方便解耦，简化开发 通过Spring提供的Ioc容器可以将对象间的依赖关系由Spring进行控制 Aop编程的支持 通过Spring的AOP功能，方便进行面向切面编程 声明事务的支持 可以将我们从单调烦闷的事务代码中解脱出来，通过声明方式灵活的进行事务管理，提高开发效率和质量 方便程序的测试 方便集成各种优秀的框架 降低javaEE API的使用难度 例如（JDBC,JavaMail,远程调用等） Java源码是经典学习范例 Spring 快速入门 读取xml配置文件，根据id标识获得Bean全限定名，通过反射创建Bean对象，返回对象。 1、导入所需要jar包（位置 porn.xml）1、创建UserDao接口（位置com.wwq.dao.UserDao）12345package com.wwq.dao;public interface UserDao &#123; void save();&#125; 2、创建实现类（com.wwq.dao.impl.UserDaoImpl）12345678910package com.wwq.dao.impl;import com.wwq.dao.UserDao;public class UserDaoImpl implements UserDao &#123; public void save() &#123; System.out.println("save running....."); &#125;&#125; 3、创建配置文件（resxources/applicationContext.xml）123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="userDao" class="com.wwq.dao.impl.UserDaoImpl"/&gt;&lt;/beans&gt; 4、创建测试类1234567891011import com.wwq.dao.UserDao;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext app = new ClassPathXmlApplicationContext("applicationContext.xml"); UserDao userDao = app.getBean("userDao", UserDao.class); userDao.save(); &#125;&#125; 5、结果 1save running.....]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Head First Java》——笔记]]></title>
    <url>%2F2020%2F12%2F15%2FHead%20First%20Java%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、基本概念1、Java的工作方式 编写源代码 用编译器运行源代码 输出字节码（任何装置都能把他转移运行） Java虚拟机执行 2、Java的程序结构》 类存在于源文件中》方法存在于类中》语句存在于方法中 （1）源文件​ 扩展名为.Java 类用来表示程序的一个组件，类的内容必须包含在花括号里面 123//类public class Dog &#123;&#125; （2）类​ 类中带有一个或者多个方法，方法必须在类中声明 12345public class Dog &#123;//方法 void bark() &#123; &#125; &#125; （3）方法​ 一组语句构成，可以把方法想象成一个函数或者过程 1234567public class Dog &#123; void bark() &#123; //语句 statement1; statement2; &#125; &#125; 3、Java的类​ 当Java虚拟机启动时，他会寻找你在命令中指定的类。 （1）编写带有main的类​ Java中所有的东西都属于这个类，你会建立源文件.java，然后将他编译成类文件.class，真正执行的是类文件 （2）语句，循环，分支 声明，设定，调用方法等普通语句 12345int x = 3;String name = “Dirk”;x = x * 17;System.out.print(“x is ” + x);double d = Math.random(); 反复做某件事for和while 123456while (x &gt; 12) &#123; x = x -1;&#125;for (int x = 0; x &lt; 10; x = x + 1) &#123; System.out.print(“x is now ” + x);&#125; 适当条件下做某事if/else 123456789if (x == 10) &#123; System.out.print(“x must be 10”);&#125; else &#123; System.out.print(“x isn’t 10”);&#125;if ((x &lt; 3) &amp; (name.equals(“Dirk”))) &#123; System.out.println(“Gently”);&#125;System.out.print(“this line runs no matter what”); （3）习题 啤酒瓶童谣程序 1234567891011121314151617181920212223package day1;public class beerDemo &#123; public static void main(String[] args)&#123; int beerNum = 10; String word = "bottles"; while (beerNum&gt;0)&#123; if (beerNum==1)&#123; word = "bootle"; &#125; System.out.println(beerNum+" "+word+" of beer on the wall"); System.out.println(beerNum+" "+word+" of beer."); System.out.println("Take one down."); System.out.println("Pass it around."); beerNum = beerNum - 1; if(beerNum&lt;=0)&#123; System.out.println("No more bottles of beer on the wall.");// System.out.println(beerNum+" "+word+" of beer on the wall"); &#125; &#125; &#125;&#125; 排排看 123456789101112131415161718192021222324package day1;public class Shuffle1 &#123; public static void main(String[] args)&#123; int x =3; while (x&gt;0)&#123; if(x&gt;2)&#123; System.out.print("a"); &#125; if(x==2)&#123; System.out.print("b c"); &#125; x = x-1; System.out.print("-"); if(x==1)&#123; System.out.print("d"); x = x-1; &#125; &#125; &#125;&#125;// 输出// % java Shuffle1// a-b c-d 泳池迷宫 123456789101112131415161718192021222324252627282930class PoolPuzzleOne &#123; public static void main(String [] args) &#123; int x = 0; while ( X &lt; 4 ) &#123; System.out.print(“a”); if ( x &lt; 1 ) &#123; System.out.print(“ “); &#125; System.out.print(“n”); if ( X &gt; 1 ) &#123; System.out.print(“ oyster”); x = x + 2; &#125; if ( x == 1 ) &#123; System.out.print(“noys”); &#125; if ( X &lt; 1 ) &#123; System.out.print(“oise”); &#125; System.out.println(““); X = X + 1; &#125; &#125;&#125;// 输出// %java PoolPuzzleOne// a noise// annoys// an oyster 二、类与对象1、对象的特性​ 当你在设计类时，要记得对象是靠类的模型塑造出来的 对象是已知事物 对象会执行动作 对象本身已知的事务称为实例变量 对象可以执行的动作称为方法 2、类与对象的区别 类是创建对象的蓝图 根据某类创建出的对象都会有自己的实例变量 3、main()方法 main的两种用途 测试真正的类 启动你的java应用 4、猜数字游戏 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Player &#123; int number=0; public void guess()&#123; number = (int) (Math.random()*10); System.out.println("I guess "+number); &#125;&#125;class GuessGame &#123; Player p1; Player p2; Player p3; public void startGame()&#123; p1 = new Player(); p2 = new Player(); p3 = new Player(); int guessp1 = 0; int guessp2 = 0; int guessp3 = 0; boolean p1isRight = false; boolean p2isRight = false; boolean p3isRight = false; int targetNumber = (int) (Math.random()*10); System.out.println("I am thinking of a number between 0 and 9..."); while(true)&#123; System.out.println("Number to Guess is "+targetNumber); p1.guess(); p2.guess(); p3.guess(); guessp1 = p1.number; System.out.println("Player one guessed "+guessp1); guessp2 = p2.number; System.out.println("Player one guessed "+guessp2); guessp3 = p3.number; System.out.println("Player one guessed "+guessp3); if(guessp1==targetNumber)&#123; p1isRight = true; &#125; if(guessp2==targetNumber)&#123; p2isRight = true; &#125; if(guessp3==targetNumber)&#123; p3isRight = true; &#125; if(p1isRight||p2isRight||p3isRight)&#123; System.out.println("We have a winner"); System.out.println("Player 1 is right?"+p1isRight); System.out.println("Player 2 is right?"+p2isRight); System.out.println("Player 3 is right?"+p3isRight); System.out.println("Game is over!"); break; &#125;else&#123; System.out.println("都没猜中，游戏继续"); &#125; &#125; &#125;&#125;public static void main(String[] args)&#123; GuessGame game = new GuessGame(); game.startGame();&#125; （1）创建对象时，它会被存放在称为堆的内存区域中，不管对象如何创建都会放在此区域中。 （2）在Java的面向对象概念中并没有全局变量这回事，然而实际上会有需要方法或者常量（constant）可被任何的程序存取。任何变量只要加上public，static和final，基本上都会变成全局变量取用的常数。 5、要点 面向对象设计扩展功能不需改动之前已经测试好的程序代码。 所有的Java程序都定义在类中。类如同蓝图描述该类型的对象要如何创建。 对象自治﹔你无需在意它如何完成任务。 对象有已知的事物，并能执行工作。对象本身已知道的事物称为实例变量，它代表对象的状态。 对象可执行的动作称为方法，它代表对象的行为。 创建类时,可能同时会需要创建独立、测试用的类。 类可以继承自较为抽象的父类。J av a的程序在执行期是一组会互相交谈的对象。 三、primitive主数据类型和引入1、认识变量 变量有两种：primitive主数据类型和引入 变量必须要有类型，另外必须要有名称 存放数值的primitive主数据类型有 向6种： byte(8) short(16) int(32)long(64) float(32) double(64) 1float f = 32.5f 小数后面加上f，否则Java对带小数点的值都会被当作double处理 2、避开关键字 名称必须以字母、下划线(_）或$符号开头，不能用数字开头。 除了第一个字符之外，后面就可以用数字。反正不要用在第一个字符就行。 要避开Java的保留字。 ​ 3、对象引用 事实上没有对象变量这样的东西存在。只有引用（reference)到对象的变量。对象引用变量保存的是存取对象的方法。 它并不是对象的容器，而是类似指向对象的指针。或者可以说是地址。但在Java中我们不会也不该知道引用变量中实际装载的是什么，它只是用来代表单一的对象。只有Java虚拟机才会知道如何使用引用来取得该对象。 对primitive主数据类型中的变量来说，变量值就是所代表的值（如5、-26.7或‘a’)。对引用变量来说，变量值是取得特定对象的位表示法。 4、数组也是对象 数组也是对象，不管里面放着是不是primitive主数据类型 记得引用变量只会保留引用，而不是对象本身 5、创建一个对象12345678910111213141516171819202122232425262728293031323334353637383940414243package day3;class Dog &#123; String name; void bark()&#123; System.out.println("dog back!"); &#125; void eat()&#123; &#125; void chaseCat()&#123; &#125;&#125;class DogTest&#123; public static void main(String[] args)&#123; //创建Dog对象 Dog fido = new Dog(); fido.name = "Fido"; //创建Dog数组 Dog[] myDogs = new Dog[3]; //数组里面放置Dog对象 myDogs[0] = new Dog(); myDogs[1] = new Dog(); myDogs[2] = fido; //通过数组引用 myDogs[0].name = "Fred"; myDogs[1].name = "Marge"; System.out.println("last gog`s name is "); System.out.println(myDogs[2].name); int x = 0; while (x&lt;myDogs.length)&#123; System.out.print(myDogs[x].name+" "); myDogs[x].bark(); x = x+1; &#125; &#125;&#125; 6、要点 变量有两种：proimitive主数据类型和引用 变量的声明必须有类型和名称 primitive主数据类型变量值是该值的字节所表示的。 引用变量的值代表位于堆之对象的存取方法。 变量有两种:primitive主数据类型和引用变量的声明必须有类型和名称。primitive主数据类型变量值是该值的字节所表示的。 引用变量的值代表位于堆之对象的存取方法。 引用变量如同遥控器，对引用变量使用圆点运算符可以如同按下遥控器按钮般地存取它的方法或实例变量。 没有引用到任何对象的引用变量的值为null值。 数组一定是个对象，不管所声明的元素是否为primitive主数据类型，并且没有primitive主数据类型的数组，只有装载primitive主数据类型的数组。 四、方法操作实例变量1、对象的行为状态影响行为，行为影响状态。对象有状态和行为两种属性，分别由实例变量与方法来表示。 类所描述的是对象知道什么与执行什么 12345678910111213141516171819202122232425262728class Dog &#123; int size; String name; void bark()&#123; if(size&gt;60)&#123; System.out.println("Woof! Woof!"); &#125;else if(size&gt;14)&#123; System.out.println("Ruff!Ruff!"); &#125;else&#123; System.out.println("Yip!Yip!"); &#125; &#125;&#125;class DogTest&#123; public static void main(String[] args)&#123; Dog one = new Dog(); one.size = 70; Dog two = new Dog(); two.size = 8; Dog three = new Dog(); three.size = 35; one.bark(); two.bark(); three.bark(); &#125;&#125; 2、传值给方法 方法会运用形参。调用的方法传入实参 实参是传给方法的值。当他传入方法后就成了形参。参数跟局部变量是一样的。它有类型与名称，可以在方法内运用。 可以从方法中取返回值 方法可以有返回值，每个方法都声明返回的类型，把方法设定为void类型，代表并没有返回任何东西。 可以向方法中传入一个以上的值 调用需要两个参数的方法，并传入两个参数 将变量当作参数传入，需要设置好类型 Java是通过值传递的，也就是说通过拷贝传递 引用对象的变量所携带的是远程控制而不是对象本身。若你对方法传入参数，实际上传入的是远程控制的拷贝。 3、要点 类定义对象所知及所为 对象所知者是实例变量 对象所为者是方法 方法可依据实例变量来展示不同的行为 方法可使用参数，这代表你可以传入一个或者多个值给方法 传值给方法的参数必须符合声明时的数量，顺序和类型 传入与传出方法的值类型可以隐含的放大或者是明确的缩小 传给方法的参数值可以是直接指定的文字或者数字或者是与所声明参数相同类型的变量。 方法必须声明返回类型。使用void类型代表方法不返回任何东西 如果方法声明了非void返回的类型，那一定要返回与声明类型相同的值。 4、封装将数据从不确定的数据改成受保护的数据，并且能修改数据的方式 封装dog 12345678910111213141516171819202122232425262728293031class GoodDog &#123; private int size; public int getSize()&#123; return size; &#125; public void setSize(int s)&#123; size = s; &#125; void bark()&#123; if(size&gt;60)&#123; System.out.println("woof!woof!"); &#125;else if(size&gt;14)&#123; System.out.println("Ruff! Ruff!"); &#125;else&#123; System.out.println("yip!yiop!"); &#125; &#125;&#125;class GoodDogTest&#123; public static void main(String[] args)&#123; GoodDog one = new GoodDog(); one.setSize(70); GoodDog two = new GoodDog(); two.setSize((8)); System.out.println("Dog one :"+ one.getSize()); System.out.println("Dog two :"+ two.getSize()); one.bark(); two.bark(); &#125;&#125; 5、数组中对象的行为 声明一个装载7个Dog引用的Dog数组 12Dog[] pets;pets = new Dog[7]; 创建两个Dog对象并赋值为数组的前两项元素 12pets[0] = new Dog();pets[1] = new Dog(); 调用两个dog对象的方法 123pets[0].setSize(30);int x = pets[0].getSize();pets[1].setSize(8); 6、声明与初始化实例变量 实例变量永远都会有默认值，integers:0 float:0.0 booleans:false reference:null 局部变量没有默认值如果在变量被初始前就要使用的话，编译器会报错 五、编写程序1、开发类 找出类应该做的事情 列出实例变量和方法 编写方法的伪码 伪码：能够帮助你专注于逻辑而不需要顾虑到程序语法 编写方法的测试用程序 需要在没有可以测试前就先写出测试用的部分，概念来自于“极限编程（XP）方法论” 实现类 测试方法 除错或者重新设计 2、测试代码123456789101112131415161718192021222324252627282930313233343536373839404142public class SimpleDotComTestDrive &#123; public static void main(String[] args)&#123; SimpleDotCom dot = new SimpleDotCom(); int[] locations = &#123;2,3,4&#125;;//假设创建了一个带有位置的数组 dot.setLocationCells(locations);//调用set方法 String userGuess = "4";//假的猜想 String result = dot.checkYourself(userGuess);//验证猜想 String testResult = "failed"; if(result.equals("hit"))&#123;//返回hit则表示成功 testResult = "passed"; &#125; System.out.println(testResult); &#125;&#125;class SimpleDotCom&#123; private int[] locationCells; private int numOfHits; void setLocationCells(int[] locations)&#123; locationCells = locations; &#125; String checkYourself(String userGuess) &#123; int guess = Integer.parseInt(userGuess);//转化字符串为数字 String result = "miss";//默认返回值为miss for (int cell:locationCells)&#123;//循环对每个各自测试 if(guess==cell)&#123;//命中 result = "hit"; numOfHits++; break; &#125; &#125; if(numOfHits==locationCells.length)&#123;//已经离开循环但是判断是否击沉 result = "kill"; &#125; System.out.println(result); System.out.println(numOfHits); return result; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243//游戏代码import javax.imageio.IIOException;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.lang.management.BufferPoolMXBean;public class SimpleDotComGame &#123; public static void main(String[] args)&#123; int numOfGuess = 0; GameHelper helper = new GameHelper(); SimpleDotCom theDotCom = new SimpleDotCom(); int randomNum = (int) (Math.random()*5); int[] locations = &#123;randomNum,randomNum+1,randomNum+2&#125;; theDotCom.setLocationCells(locations); boolean isAlive = true; while (isAlive==true)&#123; String guess = helper.getUserInput("enter a input"); String result = theDotCom.checkYourself(guess); numOfGuess++; if(result.equals("kill"))&#123; isAlive=false; System.out.println("You took "+numOfGuess+" guess"); &#125; &#125; &#125;&#125;class GameHelper&#123; public String getUserInput(String prompt)&#123; String inputLint = null; System.out.print(prompt+" "); try&#123; BufferedReader is = new BufferedReader(new InputStreamReader(System.in)); inputLint = is.readLine(); if(inputLint.length()==0) return null; &#125; catch (IOException e) &#123; System.out.println("IOExcept: "+e); &#125; return inputLint; &#125;&#125; 六、认识Java的API1、ArrayList的操作 创建 1ArrayList&lt;Egg&gt; myList = new ArrayList&lt;Egg&gt;()//&lt;Egg&gt;代表Egg类型的List 加入元素 12Egg s = new Egg();myList.add(s);//此ArrayList会产生一个盒子来放Egg 再加入元素 12Egg b = new Egg();//此ArrayList会再弄出一个盒子来放新的Egg对象myList.add(b); 查询大小 1int theSize = myList.size();//应为myList有两个元素，size()会返回2 查询特定元素 1boolean isIn = myList.contains(s);//因为myList带有s所引用的Egg对象，所以此方法会返回true 查询特定元素的位置 1int idx = myList.indexOf(b);//ArrayList为0基的，所以idx返回的是2 判断集合是否为空 1boolean empty = myList.isEmpty();//因为不是空的，isEmpty()会返回false 删除元素 1myList.remove(s);//删除后myList 被缩小了。 2、比较arrayList与一般数组的区别 一般数组在创建的时间必须确定大小，但对于ArrayList来说，你只需要创建出此类型的对象就行。它不需要指定大小。 在java5.0中，ArrayList是参数化的，ArrayList 其中是类型参数这代表String的集合，比如ArrayList代表了Gog的集合 3、游戏完全码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package day5;import java.util.*;public class DotComBust &#123; //1 声明并初始化变量 private final GameHelper helper = new GameHelper(); private final ArrayList&lt;DotCom&gt; dotComsList = new ArrayList&lt;DotCom&gt;(); private int numOfGuesses = 0; private void setUpGame()&#123; //2 创建3个DotCom对象并指派名称并置入ArrayList DotCom one = new DotCom(); one.setName("Pets.com"); DotCom two = new DotCom(); two.setName("eToys.com"); DotCom three = new DotCom(); three.setName("Go2.com"); dotComsList.add(one); dotComsList.add(two); dotComsList.add(three); //3 列出简短的提示 System.out.println("Your goal is to sink three dot coms."); System.out.println("Pets.com, eToys.com, Go2.com"); System.out.println("Try to sink them all in the fewest number of guesses"); for (DotCom dotComToSet:dotComsList)&#123;//4 对list中的每一个DotCom重复一次 ArrayList&lt;String&gt; newLocation = helper.placeDotCom(3);//5 要求DotCom的位置 dotComToSet.setLocationCells(newLocation);//6 调用这个DotCom的set方法来指派刚取得的位置 &#125; &#125; private void startPlaying()&#123; while (!dotComsList.isEmpty())&#123;//7 判断DotCom的list是否为空 String userGuess = helper.getUserInput("Enter a guess");//8 取得玩家输入 checkUserGuess(userGuess);//9 调用checkUserGuess方法 &#125; finishGame();//10 调用finishGame方法 &#125; private void checkUserGuess(String userGuess)&#123; numOfGuesses++;//11 递增玩家猜测次数的计数 String result= "miss";//12 先假设没有命中 for(DotCom dotComToTest:dotComsList)&#123;//13 对list中所有的DotCom重复 result = dotComToTest.checkYourself(userGuess);//14 要求DotCom检擦是否命中或击沉 if (result.equals("hit"))&#123; break;//15 提前跳出循环 &#125; if (result.equals("kill"))&#123; dotComsList.remove(dotComToTest);//16 这家伙被挂掉了 break; &#125; &#125; System.out.println(result);//17 列出结果 &#125; private void finishGame()&#123; //18 列出玩家成绩 System.out.println("All Dot Coms are dead! Your stock is now worthless."); if (numOfGuesses&lt;=18)&#123; System.out.println("It only took you "+ numOfGuesses + " guesses."); System.out.println(" You got out before your options sank."); &#125;else&#123; System.out.println("Took you long enough."+ numOfGuesses+" guesses."); System.out.println("Fish are dancing with your options."); &#125; &#125; public static void main(String[] args)&#123; DotComBust game = new DotComBust();//19 创建游戏对象 game.setUpGame();//20 要求游戏对象启动 game.startPlaying();//21 要求游戏对象启动游戏的主要循环 &#125;&#125; 12345678910111213141516171819202122232425262728293031323334package day5;import java.util.*;public class DotCom&#123; private ArrayList&lt;String&gt; locationCells; private String name; public void setLocationCells(ArrayList&lt;String&gt; loc)&#123; locationCells = loc; &#125; public void setName(String n) &#123; name = n; &#125; String checkYourself(String userInput) &#123; String result = "miss"; int index = locationCells.indexOf(userInput); System.out.println(index); if(index&gt;=0)&#123; locationCells.remove(index); if(locationCells.isEmpty())&#123; result = "kill"; System.out.println("Ouch! You sunk "+name+" :("); &#125;else&#123; result = "hit"; &#125; &#125; return result; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package day5;import java.io.*;import java.util.*;class GameHelper&#123; private static final String alphabet = "abcdefg"; private int gridLength = 7; private int gridSize = 49; private int [] grid = new int[gridSize]; private int comCount = 0; public String getUserInput(String prompt)&#123; String inputLint = null; System.out.print(prompt+" "); try&#123; BufferedReader is = new BufferedReader(new InputStreamReader(System.in)); inputLint = is.readLine(); if(inputLint.length()==0) return null; &#125; catch (IOException e) &#123; System.out.println("IOExcept: "+e); &#125; return inputLint.toLowerCase(); &#125; public ArrayList&lt;String&gt; placeDotCom(int comSize) &#123; ArrayList&lt;String&gt; alphaCells = new ArrayList&lt;String&gt;(); String[] alphacoords = new String[comSize]; String temp = null; int[] coords = new int[comSize]; int attemps = 0; boolean success = false; int location = 0; comCount++; int incr = 1; if ((comCount%2)==1)&#123; incr = gridLength; &#125; while (!success &amp; attemps++&lt;200)&#123; location = (int) (Math.random()*gridSize); int x = 0; success = true; while (success &amp;&amp; x&lt;comSize)&#123; if (grid[location]==0)&#123; coords[x++] = location; location += incr; if (location&gt;=gridSize)&#123; success = false; &#125; if (x&gt;0 &amp;&amp; (location % gridLength == 0))&#123; success = false; &#125; &#125; else &#123; success = false; &#125; &#125; &#125; int x = 0; int row = 0; int column = 0; while (x&lt;comSize)&#123; grid[coords[x]] = 1; row = (int)(coords[x]/gridLength); column = coords[x]%gridLength; temp = String.valueOf(alphabet.charAt(column)); alphaCells.add(temp.concat(Integer.toString(row))); x++; &#125; return alphaCells; &#125;&#125; 4、使用函数库（Java Api） 你必须指明程序代码中所使用到的类的完整名称 包之所以很重要有3个原因，他们可以帮助组织项目或者函数库相对于一大堆零散的类，以功能来组织会比较好。 包可以制造出空间名称，以便错开相同名称的类，我们可以通过不同的包来区分相同名称的类。 同时还能限制同一包之间的类才能相互存取，以维护安全性。 5、要点 ArrayList是一个Java API的类 使用add()来新增ArrayList的元素 使用remove()来删除ArrayList中的元素 要寻找某项元素的位置，使用indexOf() 使用isEmpty()来判断ArrayList是否为空 要取得ArrayList的大小，可以使用size（）方法，传统的数组使用length方法来取得大小 可是使用参数类型来声明数组内容的类型，例如ArrayList会声明带有Button类型元素的ArrayList 虽然ArrayList只能携带对象而不是primitive主数据类型，但编译器能够自动将primitive主数据类型包装成Object以存放在ArrayList中 类会用包来组织 类有完整的名称，那是由包的名称和类的名称所组成的，ArrayList实际上叫做java.util.ArrayList 除了java.lang之外，使用到其他包的类都需要指定全名，也可以在原始程序开始的地方用import指令来说用使用到的包。 七、继承与多态1、了解继承在设计继承时，你会把共同的程序代码放在某个类中，然后告诉其他类这就是他们的父类，当某个类继承了另一个类时，也就是子类继承了父类。 2、设计动物仿真程序的继承树 找出具有共同属性和行为的对象 设计代表共同状态与行为的类 决定子类是否需要让某项行为有特定不同的运作方式 通过寻找使用共同行为的子类来找出更多的抽象化的机会 完成类的继承层次 当你调用对象引用的方法的时候，你会遇到与该方法类型最接近的方法。及最低阶的会胜出。 某物是否应该要继承另一物时，则可以用IS-A来检验，例如浴室和澡盆的关系是HAS-A而不是IS-A则它们不是继承关系。IS-A测试适用于在继承层次的任何地方 3、要点 子类是extends父类出来的 子类会继承父类所有public类型的实例变量和方法，但不会继承父类所有private类型的变量和方法 继承下来的方法可以被覆盖掉，但是实例变量不能被覆盖掉 使用IS-A测试来验证继承结构的合理性 IS-A关系是单方面的，河马是动物，但是动物不一定是河马 当某个方法在子类中被覆盖过，调用这个方法时会调用到覆盖过的版本 如果类Y是extentds类X，且类Y是类Z的父类，则Z能通过IS-A-X的测试 4、继承 通过设计继承的过程，能够积累面向对象的经验值，Java程序只是由一堆类组成，因此子类不需要编译就能够运用到新版本的父类。 继承可以让你确保某个父类下所有类都会有父型所持有的全部方法 5、多态 在多态下，引用对象可以是不同类型。 1Animal myDog = new Dog(); 运用多态时，引用类型可以是实际对象类型的父类。 参数和返回类型也可以是多态 12345678910111213141516class Vet&#123; public void giveShot(Animal a)&#123; //a参数可以用任何的animal的类型对象来当传入。执行到makeNoise()的时候，不管他引用的对象是什么，该对象都会执行makeNoise（） a.makeNoise(); &#125;&#125;class PetOwner&#123; public void start()&#123; Vet v = new Vet(); Dog d = new Dog(); Hippo h = new Hippo(); //giveShot这个方法可以取用任何一种Animal只要所传入的是Animal的子类它都能执行 v.giveShot(d); v.giveShot(h); &#125;&#125; 6、内部类（防止某个类做出子类） 存取控制——类不能标记成私有，但可以不标记公有，非公有的类只能被同一个包的类做出子类 使用final这个修饰符。这表示它是继承树的末端，不能被继承。 如果想要防止特定的方法被覆盖，可以将该方法标识上final这个修饰符。将整个类标识成final这个修饰符，表示没有任何方法可以被覆盖 让类只拥有private的构造程序 7、同名异式 当你要覆盖父类的方法时，你就得同意要履行。比如，这个合约表示“我没有参数且返回布尔值。因此你覆盖的方法必须没有参数且返回布尔值 参数必须一样，且返回类型必须要兼容 不能降低方法的存取权限 8、方法重载 重载的意义是两个方法的名称相同，但参数不同所以，重载与多态毫无关系。 重载可以有同一个方法的多个不同参数版本以便方便调用。 规范： 返回的类型可以不同 不能只改变返回的类型 可以更改存取权限 八、接口与抽象类1、深入多态 我们需要超越简单的继承并前进到只有通过设计与编写接口规格才能达成的适应性和扩展性，接口是一种100%的纯抽象类，它是无法初始化的。 当你设计好继承结构时，你必须要决定哪些类是抽象的，哪些类是具体的。具体的类是实际可以被初始化为对象的。设计抽象的类很简单，在抽象类之前加上关键词，abstract就好了 123abstract class Canine extends Animal&#123;&#125; 编辑器不不会让你初始化抽象类 1c = new Canine();//编译器会报错 抽象类除了被继承过之外，是没有用途，没有值，没有目的的。 抽象与具体 不是抽象类被成为具体类 抽象的方法没有方法体 如果你声明一个抽象的方法，就必须将类也标记为抽象的，你不能在非抽象类中拥有抽象的方法。 将可继承的方法体，放在父类中是个好主意，但是有时候是没有办法坐出给任何子类都有意义的共同代码，抽象方法的意义就是算无法实现出方法的内容，但还是可以定义出一组子型共同的协议，这就是多态。 你想达成的目标是要使用父类型作为方法的参数，返回类型或者数组的类型。通过这个机制，你可以 加入新的子型到程序中，却又不必重写或者修改处理这些类型的程序。 2、多态的使用 编写一个类，让他可以处理所有的子类，类如编写一个animal类，让他处理Animal所有的子类， 123456789101112public class MyAnimal&#123; private Animal[] Animals = new Animal[5];//这不是创建Animal对象，只是保存Animal的数组对象 private int nextIndx = 0; public void add(Animal a)&#123; if(nextIndex&lt;animals.length)&#123; animals[nextIndex] = a; System.out.printIn("Animal added at "+nextIndex); nextIndex++; &#125; &#125;&#125; 1234567891011public class AnimalTestDrive&#123; public static void main(String[] args)&#123; MyAnimalList list = new MyAnimalList(); Dog a = new Dog(); Cat b = new Cat(); list.add(a); list.add(c); &#125; &#125;//Animal added 0//Animal added 1 在java中的所有类都是从Object这了类中继承出来的，Object是所有类的源头。 没有直接继承过其他类的类会是隐含的继承对象 从ArrayList取出的Object都会被当作是Object这个类的实例，编译器无法将对象识别为Object以外的事物。 将Dog对象转换为原来的类型 123Object o = a1.get(index);Dog d = (Dog) o;//将类型转换为dogd.rom(); 你只能在引用变量类确实有该方法的时候才能调用它，把类的公有方法当作是合约的内容，合约是你对其他程序的承诺协议。 3、接口 所有接口都是抽象的 接口的定义 123public interface Pet&#123; &#125; 接口的实现 123public class Dog extends Canine implements Pet&#123; &#125; 设计实现pet接口 1234567891011121314public interface Pet&#123;//接口的方法带有public 和 abstract的意义，一般省略 public abstract void beFriend();//接口方法是抽象的，没有内容，要以分号结束 public abstract void play();&#125;public class Dog extend Canine implements Pet&#123;//implents 关键词后面跟着接口的名称 //必须出现这个方法，是合约规定 public void beFriendly()&#123;&#125; public void play()&#123;&#125; //一般的覆盖方法 public void roam()&#123;&#125; public void eat()&#123;&#125; &#125; 接口的特点 多态：接口有无比的适用性，若用接口来替换具体的子类或者抽象的父类，作为参数或返回类型，则你就可以传入任何可以实现接口的东西，使用接口可以继承超过一个以上的来源，这样可以不同的需求组合不同的继承层次 接口的意义在于，你只要实现了这个接口，别人就会知道你一定会履行这个合约 大部分良好的设计也不需要在抽象的层次定义出实现的细节，在具体的子类上实现也是合理的。 如何判断应该是设计类，子类，抽象类或接口呢 如果新的类无法对其他的类通过IS-A测试时，就设计不继承其他类的类 只有在需要某类的特殊转化时，以覆盖或者增加的方法来继承现有的类。 当你需要定义一群子类的模板，又不想让程序员初始化此模板时，设计出抽线类给他们用。 如果想要定义出类可以扮演的角色，使用接口 调用父类的方法 创造子类，继承父类的方法后需要加入额外的方法则用关键字auper 12345678910111213abstract class Report&#123; void runReport()&#123;&#125;//设置报告 void printReport()&#123;&#125;&#125;class BuzzwordsReport extends Report&#123; void runReport()&#123; super.runReport(); buzzwordCompliance(); printReport(); &#125; void buzzwordCompliance()&#123;&#125;&#125; super关键字是用来引用父类的对象 4、要点 如果不想让某个类被初始化，就以abstract这个关键词将它标记为抽象的 抽象的类可以带有抽象和非抽象的方法。 如果类带有抽象的方法，则此类必定标识为抽象的 抽象的方法没有内容，它的声明是以分号结束的。 抽象的方法必须在具体的类中运行 Java所有的类都是Object(java.lang.Object)直接或者间接的子类 方法可以声明Object的参数或返回类型 不管实际上所引用的对象是什么类型，只有在引用变量的类型就是带有某方法的类型时才能调用该方法 Object引用变量在没有类型转换的情况下不能赋值给其他的类型，若堆上的对象类型与所要转换的类型不兼容，则此转换会在执行期产生异常 从ArrayList取出的对象只能被Object引用，不然就要用类型转换来改变 Java不允许多重继承，因为那样会有致命方块的问题 接口就好像是100%纯天然抽象类 以interface这个关键词取代class来声明接口 实现接口时要使用implements这个关键词 class可以实现多个接口 实现某方法的类必须实现它所有的方法，因为这些方法都是public与abstract 要从子类调用父类的方法可以用super这个关键词来引用 1super.RunReport(); 九、构造器与垃圾收集器1、对象的前世今生你必须为对象的生命循环周期负责。你决定着对象何时创建，如何创建，也决定着何时销毁。 2、堆与栈的生存空间在Java中程序员会在乎内存中两种 实例变量 实例变量是被声明在类而不是方法里面，他们代表每个独立的“字段”，（每个实例都能有不同的值）。实例变量存在于所属的对象中 局部变量 局部变量和方法的参数都是被声明在方法中，他们是暂时的，且生命周期只限于方法被放在堆上的这段时间。 3、方法会被堆在一起​ 调用方法的时候，如果方法体力还有方法，则被包含的方法会被放在上面 4、有关对象的局部变量 对象存在于何处————堆，不论对象是否声明或者创建，如果局部变量是个对该对象的引用，只有变量本身会放在栈上。 对象本身只会存在于栈上 5、要点： 我们关心堆与栈这两种内存空间 实例变量是声明在类中方法以外的地方。 局部变量声明在方法或者方法的参数上 所有局部变量都存在于栈上相对应的堆栈块中 对象引用变量与primitive主数据类型变量都是放在栈上 不管是实例变量还是局部变量，对象本身都会在堆上 1234//如果有声明变量但没有给他赋值，则只会留下变量的空间private Antenna ant;//直到引用变量被赋值一个新的Antenna对象才会在堆上占有空间private Antenna ant = new Antenna(); 6、创建对象 声明对象和赋值有3个步骤，声明引用变量，创建对象，连接对象和引用 唯一能够调用构造函数的办法就是新建一个类 7、构建Duck 构造函数的一项关键特征是他会在对象能够被赋值给引用之前就被执行，这表示你可以有机会在对象被使用之前介入。 一般使用构造函数来初始化对象的状态，也就是说设置和给对象的实例变量赋值。 构造函数不会有返回类型 如果某对象不应该在状态被初始化之前就使用，把初始化的程序代码放在构造函数中，然后把构造函数设定成需要的参数。 如果你已经写了一个有参数的构造函数，还需要一个没有参数的构造函数，则你必须手动写 重载构造函数的意思代表你有一个以上的构造函数，且参数都不相同。 8、要点 实例变量保存在所属的对象中，位于堆上。 如果实例变量是个对对象的引用，则引用和对象都在堆上 构造函数是个会在新建对象的时候执行程序代码 构造函数必须与类同名且没有返回类型 你可以用构造函数来初始被创造对象的状态 如果你没有写构造函数，编译器会帮你安排一个 默认的构造函数是没有参数的。 如果你写了构造函数，则编译器就不会调用 最好能有无参数的构造函数，让人可以选择使用默认值 重载的构造函数意思是有超过一个以上的构造函数 重构的构造函数参数必须有不同参数 两个构造函数的参数必须不同 实例变量有默认值，原始的默认值是0/0/0/false 引用的默认值是，null 9、注有时候有默认值的无参数构造函数是不合理的。例如Color这个类，该实例会代表特定的颜色，如果要用到color,就必须以某种方式指定颜色 1Color c = new Color(3,45,200); 10、调用父类的构造函数12345678910111213141516171819202122public class Animal&#123; public Animal()&#123; System.out.printIn("Making an Animal!"); &#125;&#125;public class Hippo extends Animal&#123; public Hippo()&#123; System.out.printIn("Making a Hippo"); &#125;&#125;public class TestHippo&#123; public static void main(String[] args)&#123; System.out.printIn("Starting..."); Hippo h = new Hippo(); &#125;&#125;//输出//Starting。。。。//Making an Animal //Making a Hippo 调用父类构造函数的时候，我们唯一的方法只能是，super(); 如果我们没有调用super()，编译器会帮我们加上super()的调用 编译器帮忙加的一定会是没有参数的版本，假使父类有多重版本，也只有无参数的这个版本会被调用到。 从某个构造函数调用重载版的另一个构造函数 使用this()来从某个构造函数调用同一个类的另外一个构造函数。 this()只能用在构造函数中，且必须是第一行语句 super()与this()不能兼得 11、对象的生命周期 局部变量只会生存在声明变量的方法中 实例变量的寿命与对象相同，如果对象还活着，则实例变量也会是活的 局部变量只能在声明它的方法在执行中才能被使用 只要有活着的引用，对象也就会活着，如果某个对象的引用已经不在它的范围中，但此引用还是活着的，则此对象就会继续活在堆上。如果对象的唯一引用死了，对象就会被从堆中被踢开，引用变量会跟堆栈块一起解散。 释放引用变量的三种方法 引用永久性的离开它的范围 引用被赋值到其他的对象上 直接将引用设定为null 12、静态方法不需要实例化 例如math,我们用到的是类本身 123int x = Math.round(42.2);int y = Math.min(56,12);int z = Math.abs(-342); 13、静态变量和非静态变量的区别 java 是面向对象的，但是若处于某种特殊的情况下，通常是实用方法，则不需要类的实例，static这个关键词可以标记出不需要实例的方法。一个静态的方法代表说“一种不依靠实例变量也就不需要对象的行为”。 静态的调用方法，以类的名称调用静态的方法 1Math.min(11,88); 以引用变量的名称调用非静态的方法 12Song t2 = new Song();t2.play();]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle Vm VirtualBox桥接网络配置]]></title>
    <url>%2F2020%2F11%2F03%2FOracle%20Vm%20VirtualBox%E6%A1%A5%E6%8E%A5%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Oracle Vm VirtualBox桥接网络配置添加全局nat网络管理【F】-&gt;全局设定【ctrl+G】-&gt;网络-&gt;添加（右侧的绿色加号）-&gt;双击NatNetwork-&gt;去掉“支持DHCP”前的勾 添加网卡1选择网络地址转换（NAT）——用于访问外网 添加网卡2选择仅主机（Host-Only）网络 网络配置 ifcfg-enp0s3 主要设置BOOTPROTO=dhcp 访问外网桥接自动获取 123456789101112131415161718TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=dhcpDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=enp0s3UUID=e9f9b5c6-24ec-45f5-ae36-ed01fb112241DEVICE=enp0s3ONBOOT=yesMACADDR=preservePREFIX=24IPV6_PRIVACY=no ifcfg-enp0s8 设置BOOTPROTO=static IPADDR=192.168.56.100 NETMASK=255.255.255.0 1234567891011121314151617181920TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=staticDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=enp0s3UUID=e9f9b5c6-24ec-45f5-ae36-ed01fb112241DEVICE=enp0s8ONBOOT=yesMACADDR=preserveIPADDR=192.168.56.100NETMASK=255.255.255.0PREFIX=24IPV6_PRIVACY=no 重启网络1service network restart end]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鸟哥的linux私房菜《第四版》——读后感]]></title>
    <url>%2F2020%2F10%2F15%2F%E9%B8%9F%E5%93%A5%E7%9A%84linux%E7%A7%81%E6%88%BF%E8%8F%9C%E3%80%8A%E7%AC%AC%E5%9B%9B%E7%89%88%E3%80%8B%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、主机的规划与磁盘分区1、linux与硬件的搭配 各个组件或者装置在linux底下都是一个文件。 开机流程 BIOS：开机主动执行的韧体，会认识第一个可开机的装置 MBR：第一个可开机的装置的第一个扇区内的主要启动记录区块，内含开机管理程序 开机股那里程序（boot loader）：一支可读取核心文件来执行的软件 提供选单：用户可以选择不同的开机项目，这也是多重引导的重要功能！ 载入核心文件：直接指向可开机的程序区段来开始操作系统 转交其他loader：将开机管理功能转交给其他loader负责 核心文件：开始操作系统的功能。。。 2、磁盘分区 目录树结构：整个目录树架构最重要的就是那个根目录（root directory）这个根目录的表示方法为一条斜线/ 挂载：就是利用一个目录当作进入点，将磁盘分区槽的数据放置在该目录下；也就是说，进入该目录就可以读取该分区槽的意思。这个动作叫做挂在，进入的点叫做挂载点。 二、安装centos7 若安装笔记本电脑失败时，可尝试在开机时加入【linux nofb apm=off acpi=off】来关闭省电功能 安装过程进入分区后，请以【自定义的分区模式】来处理自己规划的分区方式 centos 7预设使用xfs作为文件系统 没有连上Internet时，可尝试关闭防火墙，但SELinux最好选择强制状态 设定时不要选择启动kdump，应为那是给核心开发查阅当机数据 如果我的磁盘分区时使用MBR方式，并设定了四个Primary分区槽，这是磁盘还有空间，由于最多只有四个Primary的磁盘分区槽，没有多的可以进行分区了，且由于没有Extended,就不能在使用Logical分区。 三、首次登入与在线求助 查看文档 空格键——向下翻一页 【Page Down】——向下翻一页 【Page Up】——向上翻一页 【Home】——去到第一页 【End】——去到最后一页 /string 向【下】搜寻string这个字符串，如果要搜寻vbird的话，就输入/vbird ?string 向【上】搜寻string这个字符串 n,N：继续往下查询N用于反向查询 q 结束 Linux系统在线求助man page man -f 指令 ，在某些情况下，你可能知道要使用某些特定的指令或者是修改某些特定的配置文件，但是偏偏忘记了该指令的完整名称。有些时候则是你只记得该指令的部分关键词。 【man -f man】 左边部分：指令（或文件）以及该指令所代表的意义（就是那个数字）； 右边部分：这个指令的简易说明 【man 1 yum-groups-manager】 info page info page 则是将文件数据拆成一个一个的段落，每个段落用自己的页面来撰写，并且在各个页面中还有类似的网页的【超链接】来跳到各不同的页面中，每个独立的页面也被称为一个节点。 总结： 在终端机模式中，如果你知道某个指令，但却忘记了相关选项与参数，请先善用 –help的功能来查询相关信息 当有任何你不知道的指令或文件格式这种玩意儿，请使用man或者info来查询 而如果你想要架设一些其他的服务，或想要利用一整套软件来达成某项功能时，到/usr/share/doc底下查一下有没有该服务的说明文档 超级文书编辑器：nano [ctrl]-G：取得联机帮助(help)，很有用的！ [ctrl]-X：离开 naon 软件，若有修改过文件会提示是否需要储存喔！ [ctrl]-O：储存文件，若你有权限的话就能够储存文件了； [ctrl]-R：从其他文件读入资料，可以将某个文件的内容贴在本文件中； [ctrl]-W：搜寻字符串，这个也是很有帮助的指令喔！ [ctrl]-C：说明目前光标所在处的行数与列数等信息； [ctrl]-_：可以直接输入行号，让光标快速移动到该行； [alt]-Y：校正语法功能开启或关闭(单击开、再单击关) [alt]-M：可以支持鼠标来移动光标的功能 正确的关机方法 在你看不到的屏幕背后其实可能有相当多人同时在你的主机上面工作，若不正常关机，则可能造成文件系统的损毁。 观察系统的使用状态： 如果要看目前有谁在线，可以下达【who】这个指令，而如果要看网络的联机状态，可以下达【netstat -a】这个指令，要看背景执行的程序可以执行【ps -aux】这个指令 关机：shutdown 重启：reboot 相关指令 将数据同步写入硬盘中的指令：sync 转换为管理员权限 su - 输入密码后转为管理员权限 tips: sync可以被一般账号使用，只不过一般账号用户所更新的硬盘数据就仅有自己的数据，不像root可以更新整个系统中的数据了。 惯用的关机指令：shutdown shutdown 【参数】 -k：不要真的关机，只是发送警告讯息出去！ -r：在将系统的服务停掉之后就重新启动（常用） -h：将系统的服务停掉后，立即关机。（常用） -c：取消已经在进行中的shutdown指令内容。 时间：指定系统关机的时间！世家你的范例地下会说明。若没有这个项目，则默认1分钟后自动进行。 例子： 123456shutdown -h now #立刻关机，其中now相当于时间为0的状态shutdown -h 20:25 #系统在今天的20:25分会关机，若在21:25才下达此指令，则隔天才关机shutdown -h +10 #系统踩过十分钟后自动关机shutdown -r now #系统立刻重启shutdown -r +30 &apos;The system will reboot&apos; #再过三十分钟系统会重新启动，并显示后面的讯息给所有在线使用者shutdown -k now &apos;This system will reboot&apos; #仅发出警告信件的参数！系统并不会关机，吓唬人。 systemctl【指令】 指令项目包括如下： halt：进入系统停止模式，屏幕可能会保留一些讯息，这与你的电源管理模式有关 poweroff：进入系统关机模式，直接关机没有提供电力 reboot：直接重新启动 suspend：进入休眠模式 重新启动，关机：reboot,halt,poweroff 重点回顾 为了避免瞬间断电造成的 Linux 系统危害，建议做为服务器的 Linux 主机应该加上不断电系统来持续提供稳定的电力； 养成良好的操作习惯，尽量不要使用 root 直接登入系统，应使用一般账号登入系统，有需要再转换身份 可以透过『活动总览』查看系统所有使用的软件及快速启用惯用软件 在 X 的环境下想要『强制』重新启动 X 的组合按键为：『[alt]+[ctrl]+[backspace]』； 预设情况下，Linux 提供 tty1~tty6 的终端机界面； 在终端机环境中，可依据提示字符为$或#判断为一般账号或 root 账号； 取得终端机支持的语系数据可下达『echo $LANG』或『locale』指令； date 可显示日期、cal 可显示日历、bc 可以做为计算器软件； 组合按键中，[tab]按键可做为(1)命令补齐或(2)档名补齐或(3)参数选项补齐，[crtl]-[c]可以中断目前正在运作中的程序； Linux 系统上的英文大小写为不同的资料 联机帮助系统有 man 及 info 两个常见的指令； man page 说明后面的数字中，1 代表一般账号可用指令，8 代表系统管理员常用指令，5 代表系统配置文件格式； info page 可将一份说明文件拆成多个节点(node)显示，并具有类似超链接的功能，增加易读性； 系统需正确的关机比较不容易损坏，可使用 shutdown, poweroff 等指令关机。 四、linux的文件权限与目录配置 文件权限read/write/execute权限 （一）使用者与群组1、文件拥有者： linux是多人多任务的系统，为了考虑每个人的隐私以及每个人喜好的工作环境，【文件拥有者】的角色就显得的相当重要了。 2、群组概念： 群组最有用的功能是团队开发中使用，限制非自己团队的其他人不能阅览内容。 如果teacher这个账号是projecta与projectb这两个专题的老师，想同时观察两者的进度，则同时支持projecta与projectb这两个群组！也就是说：每个账号都可以由多个群组的支持- 使用者和群组的概念 使用者的意义：有使用权但是有的私人文件不能使用 群组：属于群组的都能使用 3、其他人的概念 群组意外的用户则为其他人 4、Linux用户身份与群组记录的文件 linux系统中root相关信息，/etc/passwd这个文件内的。密码则记录在/etc/shadow这个文件下 linux所有的组名都在/etc/group （二）linux文件权限概念1、linux文件按属性 ls -al -rw-r–r–. 1 root root 2150 10月 15 16:01 initial-setup-ks.cfg 1）第一栏代表这个文件的类型与权限（permission） 【rwx】的三个参数的组合，【r】代表可读的（read）【w】代表可写（write）【x】代表可执行（execute） 【-rwxr-xr–】: 【-】【rwx】【r-x】【r–】 【1】【234】【567】【890】 1：代表这个文件名为目录或者文件，本例中为文件（-） 234：拥有者的权限，本例中为可读，可写，可执行（rwx） 567：同群组用户权力，本例中为可读可执行（rx） 980：其他用户权力，本例中为可读（r），就是只读之意 同时注意到，rwx所在的位置是不会改变的，有该权限就会显示字符，没有该权限就变成减号（-）就是了 2）第二栏表示有多少档名连接到此节点（i-node）每个文件都会将他的权限与属性记录到文件系统的i-node中，不过，我们使用的目录树却是使用文件名来记录，因此每个档名就会链接一个i-node。这个属性记录的，就是有多少不同的档名连接到相同的一个i-node号码。 3）第三栏表示这个文件（或目录）的【拥有者账号】4）第四栏表示这个文件的所属群组5）第五栏为这个文件的容量大小，默认单位为bytes6）第六栏为这个文件的建档日期或者是最近的修改日期7）第七栏为这个文件的档名 如果档名之前多了一个【.】，则代表这个文件为【隐藏档】，可以使用【ls】【ls -a】。 2、linux文件权限的重要性 系统保护的功能 团队开发软件或数据共享工具 未将权限设定妥当的危害 在修改linux文件与目录属性之前，要先搞清楚什么数据是可变的，什么是不可变的。 3、如何改变文件属性与权限 chgrp：改变文件所属群组 chown：改变文件拥有者 chmod：改变文件的权限，SUID,SGID,SBIT等特性 改变所属群组，chgrp（change group的缩写） 1chgrp users test.txt 改变文件拥有者，chown（change owner的缩写） /etc/passwd这个记录的用户名称才能改变，如果要连目录下的所有次目录或文件同时更改文件拥有者的话，直接加上-R的选项即可。 12chown bin test.txt #将test.txt的拥有者改为bin这个账号chown root:root test.txt #将test.txt的拥有者和群组改回为：root 改变权限，chmod 数字类型改变文件权限 r：4 w：2 x：1 三种身份（owner/group/others）各自的三个权限（r/w/x）分数是需要累加的， owner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others = — = 0+0+0=0 1chmod 777 test.txt #将test.txt这个文件权限都设定 4、目录与文件之权限意义1）权限对文件的重要性 r(read)：可读取此文件的实际内容，如读取文本文件的文字内容 w(write)：可以编辑，新增或者修改该文件的内容（但不含删除该文件） x(eXecute)：该文件具有可以被系统执行的权限 2）权限对目录的重要性 r(read contents in directory )：表示具有读取目录结构列表的权限 w(modify contents of directory )：表示你具有移动该目录结构列表的权限 建立新的文件与目录 删除已经存在的文件与目录（不论该文件的权限为何！） 将已经存在的文件或者目录进行更名； 搬移该目录内的文件，目录位置 x(access directory)：x代表的是用户能否进入该目录成为工作目录的用途，即你登陆Linux时，所在的家目录就是你当下的工作目录 如果你在某目录下不具有x的权限，那么你就无法切换到该目录下，也就无法执行该目录下的任何指令，即使你具有该目录的r或者w的权限 要开放目录给任何人浏览时，应该至少给r和x权限但是w权限不能随便给 5、Linux文件种类与扩展名1）文件种类 正规文件 纯文本：人类可以读到的数据，例如数字，字母等 二进制文件：电脑可以执行的文件 数据格式文件：程序运作时候会读取特定格式的文件，例如我们登录数据，记录在/var/log/wtmp 中，我们可以用last读出来，但是用cat则是乱码 目录 连结档：类似window的快捷方式，第一个属性为【I】 设备与装置文件 与系统周边以及存储等相关的一些文件，通常都集中在/dev这个目录中，分为两种 区块设备档：一些存储设备，例如硬盘，/dev/sda 字符设备文件：一些串型设备，例如键盘鼠标等 资料接口文件（sockets）：我们可以启动一个程序来监听客户端的要求，而客户端可以透过这个socket来进行数据的沟通。属性为【s】,位置/run/tmp 数据传输文件（FIFO，pips）:特殊的文件类型，他主要目的解决多个程序同时存取一个文件造成的错误问题。属性为：【p】 2）Linux文件扩展名​ 一个linux文件能不能执行，我们通常与他第一栏的十个属性有关，在linux下，只要你有这个文件的权限为x时，则这个文件就有执行能力。 ​ “具有可执行能力”和“具有可执行力的代码”是两回事 ​ 通常可执行的后缀名： *.sh：脚本或者批处理文件 Z, .tar, .tar.gz, .zip, *.tgz：经过打包的压缩文件 .html , .php :网页相关文件 3）Linux文件长度的限制​ 单一的文件或者目录最大允许文件名为：255bytes,以一个ASCII英文占用一个bytes来说，则大约可以255个字符长度，若以每中文字占用2bytes来说，最大档名大约在128个中文字之谱。 4）Linux文件名的限制避免特殊字符 * ? &gt; &lt; ; &amp; ! [ ] | \ ‘ “ ` ( ) { } （三）Linux目录配置1、Linux的目录配置依据：FHS将目录分为四种交互形态： 可分享的：可以分享给其他挂载使用的目录，所以包括执行文件，与用户邮件等数据，是能够分享给网络上其他主机挂载用的目录 不可分享的：自己机器上运作的装置文件或者与程序有关的socket文件等，由于与自身机器有关，所以当然就不适合分享给其他主机了。 不变的：有些数据是不会经常变动的，跟随distribution而不变动，例如：函数库，文件说明，系统管理员所管理的主机配置文件 可变动的：经常改变的数据，例如登录文件，一般用户可自行收受的新闻组等。 /（root，根目录）:与开机有关 /usr(unix software resource)：与软件安装/执行有关 /var(variable)：与系统运作过程有关 根目录（/）的意义与内容 根目录也与开机/还原/系统修复等动作有关 根目录所在的分区卡槽应该越少越好，应用程序所安装的软件最好不要与根目录放在同一个分区槽内，保持根目录越小越少。如此不但效能较佳，根目录所在的文件系统也较不容易发生的问题。 FHS要求必须要存在的目录 /bin 放置 的是在单人维护模式下还能够被操作的指令 /boot 这个目录主要在放置开机会使用到的文件，如果使用的是grub2这个开机管理程序，则还会存在/boot/grub2/这个目录 /dev 这个目录任何装置与接口设备都是以文件的形态存在这个目录中。 /etc 系统主要的配置都放在这个目录里面，FHS建议不要放置可执行文件， /etc/opt（必要）：这个目录放置第三方协力软件 /opt的相关配置文件 /etc/X11（建议）：与X Window有关的配置 /etc/sgml（建议）：与SGML格式有关的各项配置文件 /etc/xml（建议）：与xml格式有关的各项配置文件 lib /lib放置的则是在开机时会用到函数库，以及在/bin或/sbin底下的指令会呼叫的函式库而已。 /lib/modules：这个目录主要放置可抽换的核心相关模块。 media /media底下放置的是可移除的装置，如软盘，光盘。 /mnt 暂时挂载 /opt 这个是给第三方协力软件放置的目录 /run 早期的FHS规定系统开机后所产生的各项信息应该要放置到/var/run目录下，新版的FHS则规范到/run底下 /sbin 放在/sbin 底下的为开机过程中所需要的，里面包括了开机、修复、还原 系统所需要的指令,本机自行安装的软件所产生的系统执行文件，则防止到/usr/local/sbin/当中 /srv 是一些网络服务启动之后，这些服务所需要取用的数据目录。 常见的服务例如www,ftp。 /tmp 这是让一般用户或者正在执行的程序暂时放置的地方。每个人都能够存储的。建议每次开机都清除/tmp的数据。 /usr 第二层FHS设定 /var 第二层FHS设定，主要为放置变动性的数据 FHS建议可以存在的目录 /home 这是系统默认的用户家目录，新增一个账号时，默认的用户家目录，都会规范在这里。 /lib 用来存放在与 /lib 不同格式的二进制函式库 /root 系统的管理员（root）的家目录 。 /usr 的意义与内容：/usr里面防止的内容是可分享的与不可变动的。GHS建议所有软件开发者，应该将他们的数据合理的分别放置的到这个目录的次目录，而不自行建立该软件自己独立的目录。 /var的意义与内容： 如果/usr 是安装时会占用较大硬盘容量的目录，那么/var 就是在系统运作后才会渐渐占用硬盘容量的目录。 第一部份：FHS 要求必须要存在的目录 /var/cache/ 应用程序本身运作过程中会产生的一些暂存档； /var/lib/ 程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的 目录。 举例来说，MySQL 的数据库放置到/var/lib/mysql/而 rpm 的数据库则放到/var/lib/rpm 去！ /var/lock/ 某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就 可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。举 例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果 两个人同时刻录，那片子写入的是谁的资料？所以当第一个人在刻录时该刻录机就会被上锁， 第二 个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用啰。目前此目录也已经挪到 /run/lock 中！ /var/log/ 重要到不行！这是登录文件放置的目录！里面比较重要的文件如/var/log/messages, /var/log/wtmp(记 录登入者的信息)等。 /var/mail/ 放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中！ 通常这两个目录 是互为链接文件啦！ /var/run/ 某些程序或者是服务启动后，会将他们的 PID 放置在这个目录下喔！至于 PID 的意义我们会在后续章 节提到的。 与 /run 相同，这个目录链接到 /run 去了！ /var/spool/ 这个目录通常放置一些队列数据，所谓的『队列』就是排队等待其他程序使用的数据啦！这些数据被 使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信 件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出 后就被删除。如果是工作排程数据(crontab)，就会被放置到/var/spool/cron/目录中！ 1）针对FHS，各家distributions 的异同，与 CentOS7 的变化CentOS 的网络设定数据放在/etc/sysconfig/network-scripts/ 目录下，但是 SuSE 则是将网络放置在 /etc/sysconfig/network/ 目录下，目录名称可是不同的呢！ 】 /bin –&gt; /usr/bin /sbin –&gt; /usr/sbin /lib –&gt; /usr/lib /lib64 –&gt; /usr/lib64 /var/lock –&gt; /run/lock /var/run –&gt; /run 2、目录树​ 在linux底下，所有的文件与目录都是由根目录开始的。 目录树的起始点为根目录（/，root）； 每一个目录不止能使用本地端的partition的文件系统，也可以使用网络上的filesystem。举例来说，可以利用Network File System(NFS)服务器挂载某特定目录 每一个文件在此目录中的文件名（包含完整路径）都是独一无二的 3、绝对路径和相对路径 .：代表当前目录，也可以使用./来表示 ..：代表上一层目录，也可以../来表示 4、Centos 的观察1234uname -r #查看核心版本uname -m #查看操作系统的位版本yum install redhat-lsb #查看版本号，需要root身份lsb_release -a #查看信息 5、重点 更改文件的群组支持可用 chgrp，修改文件的拥有者可用 chown，修改文件的权限可用 chmod 修改文件权限 chmod 754 filename 配置数据 /etc/ 几乎系统所有配置文件均在这里 /boot/ 开机配置文件， /usr/bin, /bin 一般执行档摆放的地方 /usr/sbin,/sbin 系统管理员常用的指令集 /dev 所有系统装置文件的目录 /var/log 系统注册表文件的地方 /run 经常变动的项目 五、Linux文件与目录管理1、目录与路径 文件与目录的检视：ls 复制、删除、移动：cp， rm， mv 2、文件与目录管理 取得路径的文件名与目录名称 basename /etc/sysconfig/network # network 取得最后的档名 dirname /etc/sysconfig/network # /etc/sysconfig 取得目录名 3、文件内容查阅 cat 由第一行还是显示文件内容 tac 由最后一行显示文件内容（tac是cat倒着写的） nl 显示的时候 显示行号 more 一页一页显示文件内容 less与more类似 比more好的是，他可以往前翻页 head 只看头几行 tail 只看尾巴几行 od 以二进制的方式读取文件内容 4、文件与目录的默认权限与隐藏权限 除了基本 r, w, x 权限外，在 Linux 传统的 Ext2/Ext3/Ext4 文件系统下，我们还可以设定其他的系统隐藏属性， 这部份可使用 chattr 来设定，而以 lsattr 来查看，最重要的属性就是可以设定其不可修改的特性！ 文件预设权限：umask 用户在建立文件时默认的属性，修改权限则umask 后加对应数值，例如umask 002 文件隐藏属性： chattr（配置隐藏属性） 1chattr [+-=][ASacdistu] 文件或目录名称 12345678910范例：请尝试到/tmp 底下建立文件，并加入 i 的参数，尝试删除看看。[root@study ~]# cd /tmp[root@study tmp]# touch attrtest &lt;==建立一个空文件[root@study tmp]# chattr +i attrtest &lt;==给予 i 的属性[root@study tmp]# rm attrtest &lt;==尝试删除看看rm: remove regular empty file `attrtest&apos;? yrm: cannot remove `attrtest&apos;: Operation not permitted# 看到了吗？呼呼！连 root 也没有办法将这个文件删除呢！赶紧解除设定！范例：请将该文件的 i 属性取消！[root@study tmp]# chattr -i attrtest lsattr（显示文件隐藏属性） 1lsattr [-adR] 文件或目录 1234567选项与参数：-a ：将隐藏文件的属性也秀出来；-d ：如果接的是目录，仅列出目录本身的属性而非目录内的文件名；-R ：连同子目录的数据也一并列出来！[root@study tmp]# chattr +aiS attrtest[root@study tmp]# lsattr attrtest--S-ia---------- attrtest 文件特殊权限 SUID,SGID,SBIT 观察文件类型：file 5、指令与文件搜索 脚本文件名的搜寻 1which [-a] command 1234567891011121314151617181920选项或参数：-a ：将所有由 PATH 目录中可以找到的指令均列出，而不止第一个被找到的指令名称范例一：搜寻 ifconfig 这个指令的完整文件名[root@study ~]# which ifconfig/sbin/ifconfig范例二：用 which 去找出 which 的档名为何？[root@study ~]# which whichalias which=&apos;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&apos;/bin/alias/usr/bin/which# 竟然会有两个 which ，其中一个是 alias 这玩意儿呢！那是啥？# 那就是所谓的『命令别名』，意思是输入 which 会等于后面接的那串指令啦！# 更多的数据我们会在 bash 章节中再来谈的！范例三：请找出 history 这个指令的完整文件名[root@study ~]# which history/usr/bin/which: no history in (/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin)[root@study ~]# history --help-bash: history: --: invalid optionhistory: usage: history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg 文件档名的搜寻 1whereis [-bmsu] 文件或目录名 123456789101112131415选项与参数：-l :可以列出 whereis 会去查询的几个主要目录而已-b :只找 binary 格式的文件-m :只找在说明文件 manual 路径下的文件-s :只找 source 来源文件-u :搜寻不在上述三个项目当中的其他特殊文件范例一：请找出 ifconfig 这个档名[root@study ~]# whereis ifconfigifconfig: /sbin/ifconfig /usr/share/man/man8/ifconfig.8.gz范例二：只找出跟 passwd 有关的『说明文件』档名(man page)[root@study ~]# whereis passwd # 全部的档名通通列出来！passwd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz/usr/share/man/man5/passwd.5.gz[root@study ~]# whereis -m passwd # 只有在 man 里面的档名才抓出来！passwd: /usr/share/man/man1/passwd.1.gz /usr/share/man/man5/passwd.5.g locate/updatedb updatedb：根据 /etc/updatedb.conf 的设定去搜寻系统硬盘内的文件名，并更新 /var/lib/mlocate 内的数据库文件； locate：依据 /var/lib/mlocate 内的数据库记载，找出用户输入的关键词文件名。 1234567[root@study ~]# locate [-ir] keyword选项与参数：-i ：忽略大小写的差异；-c ：不输出档名，仅计算找到的文件数量-l ：仅输出几行的意思，例如输出五行则是 -l 5-S ：输出 locate 所使用的数据库文件的相关信息，包括该数据库纪录的文件/目录数量等-r ：后面可接正规表示法的显示方式 find 1find [PATH] [option] [action] 1234567891011121314选项与参数：1. 与时间有关的选项：共有 -atime, -ctime 与 -mtime ，以 -mtime 说明-mtime n ：n 为数字，意义为在 n 天之前的『一天之内』被更动过内容的文件；-mtime +n ：列出在 n 天之前(不含 n 天本身)被更动过内容的文件档名；-mtime -n ：列出在 n 天之内(含 n 天本身)被更动过内容的文件档名。-newer file ：file 为一个存在的文件，列出比 file 还要新的文件档名范例一：将过去系统上面 24 小时内有更动过内容 (mtime) 的文件列出[root@study ~]# find / -mtime 0# 那个 0 是重点！0 代表目前的时间，所以，从现在开始到 24 小时前，# 有变动过内容的文件都会被列出来！那如果是三天前的 24 小时内？# find / -mtime 3 有变动过的文件都被列出的意思！范例二：寻找 /etc 底下的文件，如果文件日期比 /etc/passwd 新就列出[root@study ~]# find /etc -newer /etc/passwd# -newer 用在分辨两个文件之间的新旧关系是很有用的！ 12345678范例一：将过去系统上面 24 小时内有更动过内容 (mtime) 的文件列出[root@study ~]# find / -mtime 0# 那个 0 是重点！0 代表目前的时间，所以，从现在开始到 24 小时前，# 有变动过内容的文件都会被列出来！那如果是三天前的 24 小时内？# find / -mtime 3 有变动过的文件都被列出的意思！范例二：寻找 /etc 底下的文件，如果文件日期比 /etc/passwd 新就列出[root@study ~]# find /etc -newer /etc/passwd# -newer 用在分辨两个文件之间的新旧关系是很有用的 123456789101112131415161718192021222324252627282930选项与参数：3. 与文件权限及名称有关的参数：-name filename：搜寻文件名为 filename 的文件；-size [+-]SIZE：搜寻比 SIZE 还要大(+)或小(-)的文件。这个 SIZE 的规格有：c: 代表 byte， k: 代表 1024bytes。所以，要找比 50KB还要大的文件，就是『 -size +50k 』-type TYPE ：搜寻文件的类型为 TYPE 的，类型主要有：一般正规文件 (f), 装置文件 (b, c),目录 (d), 连结档 (l), socket (s), 及 FIFO (p) 等属性。-perm mode ：搜寻文件权限『刚好等于』 mode 的文件，这个 mode 为类似 chmod的属性值，举例来说， -rwsr-xr-x 的属性为 4755 ！-perm -mode ：搜寻文件权限『必须要全部囊括 mode 的权限』的文件，举例来说，我们要搜寻 -rwxr--r-- ，亦即 0744 的文件，使用 -perm -0744，当一个文件的权限为 -rwsr-xr-x ，亦即 4755 时，也会被列出来，因为 -rwsr-xr-x 的属性已经囊括了 -rwxr--r-- 的属性了。-perm /mode ：搜寻文件权限『包含任一 mode 的权限』的文件，举例来说，我们搜寻-rwxr-xr-x ，亦即 -perm /755 时，但一个文件属性为 -rw-------也会被列出来，因为他有 -rw.... 的属性存在！范例五：找出档名为 passwd 这个文件[root@study ~]# find / -name passwd范例五-1：找出文件名包含了 passwd 这个关键词的文件[root@study ~]# find / -name &quot;*passwd*&quot;# 利用这个 -name 可以搜寻档名啊！默认是完整文件名，如果想要找关键词，# 可以使用类似 * 的任意字符来处理范例六：找出 /run 目录下，文件类型为 Socket 的檔名有哪些？[root@study ~]# find /run -type s# 这个 -type 的属性也很有帮助喔！尤其是要找出那些怪异的文件，# 例如 socket 与 FIFO 文件，可以用 find /run -type p 或 -type s 来找！范例七：搜寻文件当中含有 SGID 或 SUID 或 SBIT 的属性[root@study ~]# find / -perm /7000# 所谓的 7000 就是 ---s--s--t ，那么只要含有 s 或 t 的就列出，所以当然要使用 /7000，# 使用 -7000 表示要同时含有 ---s--s--t 的所有三个权限。而只需要任意一个，就是 /7000 ～瞭乎？ 6、复习 特殊目录有：., .., -, ~, ~account 需要注意； rmdir 仅能删除空目录，要删除非空目录需使用『 rm -r 』指令； cat -n 与 nl 均可显示行号，但默认的情况下，空白行会不会编号并不相同 文件具有 SUID 的特殊权限时，代表当用户执行此一 binary 程序时，在执行过程中用户会暂时具有程序拥有者的权限 目录具有 SGID 的特殊权限时，代表用户在这个目录底下新建的文件之群组都会与该目录的组名相同。 目录具有 SBIT 的特殊权限时，代表在该目录下用户建立的文件只有自己与 root 能够删除！ 观察文件的类型可以使用 file 指令来观察； 搜寻指令的完整文件名可用 which 或 type ，这两个指令都是透过 PATH 变量来搜寻文件名； 搜寻文件的完整档名可以使用 whereis 找特定目录或 locate 到数据库去搜寻，而不实际搜寻文件系统； 利用 find 可以加入许多选项来直接查询文件系统，以获得自己想要知道的档名。 六、Linux磁盘与文件系统6.1、认识Linux系统 EXT2：是使用inode/block/superblock这种inode为基础的文件系统 我们在Linux下的文件系统建立一个目录时，文件就会分配一个inode与至少一块block给该目录。 EXT3,4是EXT2的升级版本，新增了日志等功能，推荐直接用EXT4 挂载点：每个filesystem 都有独立的inode/block/superblock 。挂载点一定是目录，该目录为进入该文件系统的入口。 1234[root@study ~]# ls -lid / /boot /home128 dr-xr-xr-x. 17 root root 4096 May 4 17:56 /128 dr-xr-xr-x. 4 root root 4096 May 4 17:59 /boot128 drwxr-xr-x. 5 root root 41 Jun 17 00:20 /home inode号为128 filesystem为17，4，5则它们为不同的目录 1234[root@study ~]# ls -ild / /. /..128 dr-xr-xr-x. 17 root root 4096 May 4 17:56 /128 dr-xr-xr-x. 17 root root 4096 May 4 17:56 /.128 dr-xr-xr-x. 17 root root 4096 May 4 17:56 /.. inode号为128 filesystem为17则它们为相同的目录 查看Linux支持的文件系统 1ls -l /lib/modules/$(uname -r)/kernel/fs XFS：Centos 7 已经由原本的EXT4变成了XFS文件系统。 Ext家族当前较伤脑筋的地方：支持度最广，但格式化超级慢 xfs是一个日志式的文件系统，主要用在高容量磁盘以及高性能文件系统只用。 一个资料区（data section） 一个文件系统活动登录区（log section） 一个实时运作区(realtime section) 范例一 123456789101112131415找出系统 /boot 这个挂载点底下的文件系统的 superblock 纪录[root@study ~]# df -T /bootFilesystem Type 1K-blocks Used Available Use% Mounted on/dev/vda2 xfs 1038336 133704 904632 13% /boot# 没错！可以看得出来是 xfs 文件系统的！来观察一下内容吧！[root@study ~]# xfs_info /dev/vda21 meta-data=/dev/vda2 isize=256 agcount=4, agsize=65536 blks2 = sectsz=512 attr=2, projid32bit=13 = crc=0 finobt=04 data = bsize=4096 blocks=262144, imaxpct=255 = sunit=0 swidth=0 blks6 naming =version 2 bsize=4096 ascii-ci=0 ftype=07 log =internal bsize=4096 blocks=2560, version=28 = sectsz=512 sunit=0 blks, lazy-count=19 realtime =none extsz=4096 blocks=0, rtextents=0 说明： 第 1 行里面的 isize 指的是 inode 的容量，每个有 256bytes 这么大。至于 agcount 则是前面谈到的储存区群组 (allocation group) 的个数，共有 4 个， agsize 则是指每个储存区群组具有 65536 个 block 。配合第 4 行的 block 设定为 4K，因此整个文件系统的容量应该就是 4655364K 这么大！ 第 2 行里面 sectsz 指的是逻辑扇区 (sector) 的容量设定为 512bytes 这么大的意思。 第 4 行里面的 bsize 指的是 block 的容量，每个 block 为 4K 的意思，共有 262144 个 block 在这个文件系统内。 第 5 行里面的 sunit 与 swidth 与磁盘阵列的 stripe 相关性较高。这部份我们底下格式化的时候会举一个例子来说明。 第 7 行里面的 internal 指的是这个登录区的位置在文件系统内，而不是外部设备的意思。且占用了 4K *2560 个 block，总共约 10M 的容量。 第 9 行里面的 realtime 区域，里面的 extent 容量为 4K。不过目前没有使用。 6.2、文件系统的简单操作6.2.1 磁盘与目录的容量 df：列出文件的整体磁盘使用量 -h 会以G/M等容量格式显示出来 -aT 系统内的所有特殊文件格式及名称都列出来 1234将 /etc 底下的可用的磁盘容量以易读的容量格式显示[root@study ~]# df -h /etcFilesystem Size Used Avail Use% Mounted on/dev/mapper/centos-root 10G 3.3G 6.8G 33% / 12345678范例五：将目前各个 partition 当中可用的 inode 数量列出[root@study ~]# df -ihFilesystem Inodes IUsed IFree IUse% Mounted on/dev/mapper/centos-root 10M 108K 9.9M 2% /devtmpfs 154K 397 153K 1% /devtmpfs 156K 5 156K 1% /dev/shmtmpfs 156K 497 156K 1% /runtmpfs 156K 13 156K 1% /sys/fs/cgroup du：评估文件系统的磁盘使用量（常用在推估目录所占容量） 1234567选项与参数：-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。-h ：以人们较易读的容量格式 (G/M) 显示；-s ：列出总量而已，而不列出每个各别的目录占用容量；-S ：不包括子目录下的总计，与 -s 有点差别。-k ：以 KBytes 列出容量显示；-m ：以 MBytes 列出容量显示； 直接输入du没有任何选项时，则默认分析当前目录 du分析的是当前目录下的所有数据的总和，如果想减少此目录的加总则要加上-S 6.2.2 实体链接与符号链接 ln在Linux底下的连接档有两种，一种是类似的Windows的快捷方式，可以快速的链接到目标文件，另一种则是透过文件系统的inode链接来产生新的文档名，这种链接称为实体链接。 1）建立实体链接 hard link123456[root@study ~]# ll -i /etc/crontab34474855 -rw-r--r--. 1 root root 451 Jun 10 2014 /etc/crontab[root@study ~]# ln /etc/crontab . &lt;==建立实体链接的指令[root@study ~]# ll -i /etc/crontab crontab34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab 如果将任何一个档名删除，其实inode和block都还是存在的，不论在哪个档名修改，结果都会写入相同的inode与block中。 hard link限制： 不能跨Filesytem 不能link目录 2）Symbolic Link(符号链接，亦既是快捷方式)Symbolic link 就是在建立一个独立的文件，而这个文件会让数据的读取指向他 link 的那个文件的档名！由于只是利用文件来做为指向的动作， 所以，当来源档被删除之后，symbolic link 的文件会『开不了』 。 1234[root@study ~]# ln -s /etc/crontab crontab2[root@study ~]# ll -i /etc/crontab /root/crontab234474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&gt; /etc/crontab 选项 -s:如果不加任何参数就进行链接则是hand link ,至于-s就是symbolic link -f:如果目标文件存在时，就主动将目标文件直接移除后再建立 6.3、磁盘的分区、格式化、检验、挂载6.3.1 观察磁盘分区状态 lsblk：列出磁盘上所有列表 blkid：找出装置的UUID parted：列出磁盘分区表类型与分区信息 6.3.2 磁盘分区：gdisk/fdisk【MBR 分区表用fdisk,GPT分区表用gdisk】 partprobe 更新Linux核心的分区表信息 gdisk 删除分区 123gdisk /dev/vdapw #使指令生效 6.3.3 磁盘格式化（建置文件系统） XFS文件系统 mkfs.xfs 1mkfs.xfs -f /dev/sdb XFS文件系统for RAID（磁盘阵列） 效能优化（Optional） 1[root@study ~]# mkfs.xfs -f -d agcount=2,sunit=512,swidth=3584 -r extsize=1792k /dev/vda4 EXT4文件系统 mkfs.ext4 123456[root@study ~]# mkfs.ext4 [-b size] [-L label] 装置名称选项与参数：-b ：设定 block 的大小，有 1K, 2K, 4K 的容量，-L ：后面接这个装置的标头名称。范例：将 /dev/vda5 格式化为 ext4 文件系统[root@study ~] 其他文件系统 mkfs mkfs 是综合指令使用mkfs -t xfs时就会找mkfs.xfs的相关参数给我们使用 123[root@study ~]# mkfs[tab][tab]mkfs mkfs.btrfs mkfs.cramfs mkfs.ext2 mkfs.ext3 mkfs.ext4mkfs.fat mkfs.minix mkfs.msdos mkfs.vfat mkfs.xfs 6.3.4 文件系统检验 xfs_repair 处理XFS文件系统 12345xfs_repair [-find] 装置名称选项与参数：-f ：后面的装置其实是个文件而不是实体装置-n ：单纯检查并不修改文件系统的任何数据 (检查而已)-d ：通常用在单人维护模式底下，针对根目录 (/) 进行检查与修复的动作！很危险！不要随便使用 fsck.ext4 处理EXT4文件系统 1fsck.ext4 /dev/sdb 6.3.5 文件系统的挂载与卸除 mount 1mount /dev/sdb /data/cdrom 1mount UUID=&quot;e0a6af55-26e7-4cb7-a515-826a8bd29e90&quot; /data/xfs 重新挂载根目录与挂载不特定目录 12范例：将 / 重新挂载，并加入参数为 rw 与 auto[root@study ~]# mount -o remount,rw,auto / umount（将装置文件卸除） 1umount -f /dev/sdb 6.3.6 磁盘/文件系统参数修订 mknod xfs_admin 修改XFS文件系统UUID与Label name 1234567891011范例：利用 uuidgen 产生新 UUID 来设定 /dev/vda4，并测试挂载[root@study ~]# umount /dev/vda4 # 使用前，请先卸除！[root@study ~]# uuidgene0fa7252-b374-4a06-987a-3cb14f415488 # 很有趣的指令！可以产生新的 UUID 喔！[root@study ~]# xfs_admin -u /dev/vda4UUID = e0a6af55-26e7-4cb7-a515-826a8bd29e90[root@study ~]# xfs_admin -U e0fa7252-b374-4a06-987a-3cb14f415488 /dev/vda4Clearing log and setting UUIDwriting all SBsnew UUID = e0fa7252-b374-4a06-987a-3cb14f415488[root@study ~]# mount UUID=e0fa7252-b374-4a06-987a-3cb14f415488 /data/xfs tune2fs修改ext4的lable name 与 UUID 1234567范例：列出 /dev/vda5 的 label name 之后，将它改成 vbird_ext4[root@study ~]# dumpe2fs -h /dev/vda5 | grep namedumpe2fs 1.42.9 (28-Dec-2013)Filesystem volume name: &lt;none&gt; # 果然是没有设定的！[root@study ~]# tune2fs -L vbird_ext4 /dev/vda5[root@study ~]# dumpe2fs -h /dev/vda5 | grep nameFilesystem volume name: vbird_ext4[root@study ~]# mount LABEL=vbird_ext4 /data/ext4 6.4 设定开机挂载6.4.1 开机挂载 /etc/fstab 及 /etc/mtab /etc/fstab 是将我们利用mount指令进行挂载时将所有选项与参数写入到这个文件中 1234567891011121314[root@bogon ~]# [root@bogon ~]# cat /etc/fstab## /etc/fstab# Created by anaconda on Mon Nov 2 16:02:43 2020## Accessible filesystems, by reference, are maintained under &apos;/dev/disk&apos;# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info##[装置/UUID 等] [挂载点] [文件系统] [文件系统参数] [dump] [fsck]/dev/mapper/centos-root / xfs defaults 0 0UUID=6a760021-6800-4ab7-9565-bd9abe459a0f /boot xfs defaults 0 0/dev/mapper/centos-swap swap swap defaults 0 0 参数说明： 磁盘装置文件名/UUID/LABEL name： 文件系统或磁盘的装置文件名，如 /dev/vda2 等 文件系统的 UUID 名称，如 UUID=xxx 文件系统的 LABEL 名称，例如 LABEL=xxx 第二栏：挂载点 (mount point)： 一定是目录 第三栏：磁盘分区槽的文件系统： 在手动挂载时可以让系统自动测试挂载，但在这个文件当中我们必须要手动写入文件系统才行！包括 xfs, ext4, vfat, reiserfs, nfs 等等。 第四栏：文件系统参数： defaults：同时具有 rw, suid, dev, exec, auto, nouser, async 等参数。 基本上，预设情况使用 efaults 设定即可！ 第五栏：能否被 dump 备份指令作用： dump 是一个用来做为备份的指令，由于备份方案有很多，所以这里写0就好了。 第六栏：是否以 fsck 检验扇区： 早期开机流程中会校验，主要是透过fsck去做的，现在由于xfs文件系统会自己进行校验，不需要额外校验，直接填写0 如果/etc/fstab输入错误导致无法开机 进入单人模式 1[root@study ~]# mount -n -o remount,rw / 6.4.2 特殊装置loop挂载（映像档不刻录就挂载使用） 如果有光盘映像文件或者是使用文件作为磁盘的方式时，就用特殊的方式将他挂载起来- 挂载光盘/DVD映像文件 通过loop文件来挂载 123456789101112131415[root@study ~]# mount -o loop /tmp/CentOS-7.0-1406-x86_64-DVD.iso /data/centos_dvd[root@study ~]# df /data/centos_dvdFilesystem 1K-blocks Used Available Use% Mounted on/dev/loop0 4050860 4050860 0 100% /data/centos_dvd# 就是这个项目！ .iso 映象文件内的所有数据可以在 /data/centos_dvd 看到！[root@study ~]# ll /data/centos_dvdtotal 607-rw-r--r--. 1 500 502 14 Jul 5 2014 CentOS_BuildTag &lt;==瞧！就是 DVD 的内容啊！drwxr-xr-x. 3 500 502 2048 Jul 4 2014 EFI-rw-r--r--. 1 500 502 611 Jul 5 2014 EULA-rw-r--r--. 1 500 502 18009 Jul 5 2014 GPLdrwxr-xr-x. 3 500 502 2048 Jul 4 2014 images.....(底下省略).....[root@study ~]# umount /data/centos_dvd/# 测试完成！记得将数据给他卸除！ 建立大文件以制作loop装置文件 建立大文件 1234567891011#假设我要建立一个空的文件在 /srv/loopdev[root@study ~]# dd if=/dev/zero of=/srv/loopdev bs=1M count=512512+0 records in &lt;==读入 512 笔资料512+0 records out &lt;==输出 512 笔数据536870912 bytes (537 MB) copied, 12.3484 seconds, 43.5 MB/s# 这个指令的简单意义如下：# if 是 input file ，输入文件。那个 /dev/zero 是会一直输出 0 的装置！# of 是 output file ，将一堆零写入到后面接的文件中。# bs 是每个 block 大小，就像文件系统那样的 block 意义；# count 则是总共几个 bs 的意思。所以 bs*count 就是这个文件的容量了！[root@study ~]# ll -h /srv/loopdev-rw-r--r--. 1 root root 512M Jun 25 19:46 /srv/loopdev 大型文件格式化 123[root@study ~]# mkfs.xfs -f /srv/loopdev[root@study ~]# blkid /srv/loopdev/srv/loopdev: UUID=&quot;59615042-c25e-4ec8-acd2-5cf407f2b55e&quot; TYPE=&quot;xfs 挂载 1234[root@study ~]# mount -o loop UUID=&quot;7dd97bd2-4446-48fd-9d23-a8b03ffdd5ee&quot; /mnt[root@study ~]# df /mntFilesystem 1K-blocks Used Available Use% Mounted on/dev/loop0 520876 26372 494504 6.5 内存置换空间（swap）之建制6.5.1 使用实体分区槽建置swap 先进行分区的行为 1234567891011121314151617181920[root@study ~]# gdisk /dev/vdaCommand (? for help): nPartition number (6-128, default 6):First sector (34-83886046, default = 69220352) or &#123;+-&#125;size&#123;KMGTP&#125;:Last sector (69220352-83886046, default = 83886046) or &#123;+-&#125;size&#123;KMGTP&#125;: +512MCurrent type is &apos;Linux filesystem&apos;Hex code or GUID (L to show codes, Enter = 8300): 8200Changed type of partition to &apos;Linux swap&apos;Command (? for help): pNumber Start (sector) End (sector) Size Code Name6 69220352 70268927 512.0 MiB 8200 Linux swap # 重点就是产生这东西！Command (? for help): wDo you want to proceed? (Y/N): y[root@study ~]# partprobe[root@study ~]# lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTvda 252:0 0 40G 0 disk.....(中间省略).....`-vda6 252:6 0 512M 0 part # 确定这里是存在的才行！# 鸟哥有简化输出喔！结果可以看到我们多了一个 /dev/vda6 可以使用于 swap 喔 开始建置 swap 格式 123456[root@study ~]# mkswap /dev/vda6Setting up swapspace version 1, size = 524284 KiBno label, UUID=6b17e4ab-9bf9-43d6-88a0-73ab47855f9d[root@study ~]# blkid /dev/vda6/dev/vda6: UUID=&quot;6b17e4ab-9bf9-43d6-88a0-73ab47855f9d&quot; TYPE=&quot;swap&quot;# 确定格式化成功！且使用 blkid 确实可以抓到这个装置了喔！ 开始观察与加载看看吧！ 123456789101112131415161718[root@study ~]# freetotal used free shared buff/cache availableMem: 1275140 227244 330124 7804 717772 875536 # 物理内存Swap: 1048572 101340 947232 # swap 相关# 我有 1275140K 的物理内存，使用 227244K 剩余 330124K ，使用掉的内存有# 717772K 用在缓冲/快取的用途中。至于 swap 已经有 1048572K 啰！这样会看了吧？！[root@study ~]# swapon /dev/vda6[root@study ~]# freetotal used free shared buff/cache availableMem: 1275140 227940 329256 7804 717944 874752Swap: 1572856 101260 1471596 &lt;==有看到增加了没？[root@study ~]# swapon -sFilename Type Size Used Priority/dev/dm-1 partition 1048572 101260 -1/dev/vda6 partition 524284 0 -2# 上面列出目前使用的 swap 装置有哪些的意思！[root@study ~]# nano /etc/fstabUUID=&quot;6b17e4ab-9bf9-43d6-88a0-73ab47855f9d&quot; swap swap defaults 0 0# 当然要写入配置文件，只不过不是文件系统，所以没有挂载点！第二个字段写入 swap 即可。 6.5.2 使用文件建置swap 使用dd这个指令来新增一个128MB的文件在/tmp底下： 1234567[root@study ~]# dd if=/dev/zero of=/tmp/swap bs=1M count=128 128+0 records in 128+0 records out 134217728 bytes (134 MB) copied, 1.7066 seconds, 78.6 MB/s [root@study ~]# ll -h /tmp/swap -rw-r--r--. 1 root root 128M Jun 26 17:47 /tmp/swap 使用 mkswap 将 /tmp/swap 这个文件格式化为 swap 的文件格式： 使用 swapon 来将 /tmp/swap 启动啰！ 使用 swapoff 关掉 swap file，并设定自动启用 1234567891011121314[root@study ~]# nano /etc/fstab /tmp/swap swap swap defaults 0 0 # 为何这里不要使用 UUID 呢？这是因为系统仅会查询成组设备 (block device) 不会查询文件！ # 所以，这里千万不要使用 UUID，不然系统会查不到喔！ [root@study ~]# swapoff /tmp/swap /dev/vda6 [root@study ~]# swapon -s Filename Type Size Used Priority /dev/dm-1 partition 1048572 100380 -1 # 确定已经回复到原本的状态了！然后准备来测试！！ [root@study ~]# swapon -a [root@study ~]# swapon -s # 最终你又会看正确的三个 swap 出现啰！这也才确定你的 /etc/fstab 设定无误！ 6.6 文件系统的特殊观察与操作6.6.1 磁盘空间之浪费问题​ 一个 block 只能放置一个文件， 因此太多小文件将会浪费非常多的磁盘容量。 6.6.2 利用 GNU 的 parted 进行分区行为(Optional)​ 如果你想要将原本的 MBR 改成 GPT 分区表，或原本的 GPT 分区表改成 MBR 分区表，也能使用 parted ！ 但是请不要使用 vda 来测试！因为分区表格式不能转换！因此进行底下的测试后，在该磁盘的系统应该是会损毁的！ 七、文件与文件系统的压缩，打包与备份7.1压缩文件的用途与技术​ 计算机工程师就利用一些复杂的计算方式， 将这些没有使用到的空间『丢』出来，以让文件占用的空间变小！这就是压缩的技术 7.2 Linux常见的压缩指令7.2.1 gzip，zcat/zmore/zless/zgrep1234567891011121314151617181920212223[dmtsai@study ~]$ gzip [-cdtv#] 檔名 [dmtsai@study ~]$ zcat 檔名.gz.gz 选项与参数： -c ：将压缩的数据输出到屏幕上，可透过数据流重导向来处理； -d ：解压缩的参数； -t ：可以用来检验一个压缩文件的一致性～看看文件有无错误； -v ：可以显示出原文件/压缩文件案的压缩比等信息； -# ：# 为数字的意思，代表压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好！预设是 -6 范例一：找出 /etc 底下 (不含子目录) 容量最大的文件，并将它复制到 /tmp ，然后以 gzip 压缩 [dmtsai@study ~]$ ls -ldSr /etc/* # 忘记选项意义？请自行 man 啰！ .....(前面省略)..... -rw-r--r--. 1 root root 25213 Jun 10 2014 /etc/dnsmasq.conf -rw-r--r--. 1 root root 69768 May 4 17:55 /etc/ld.so.cache -rw-r--r--. 1 root root 670293 Jun 7 2013 /etc/services [dmtsai@study ~]$ cd /tmp [dmtsai@study tmp]$ cp /etc/services . [dmtsai@study tmp]$ gzip -v services services: 79.7% -- replaced with services.gz [dmtsai@study tmp]$ llll /etc/services /tmp/services* -rw-r--r--. 1 root root 670293 Jun 7 2013 /etc/services -rw-r--r--. 1 dmtsai dmtsai 136088 Jun 30 18:40 /tmp/services.gz 当你使用 gzip 进行压缩时，在预设的状态下原本的文件会被压缩成为 .gz 的档名，源文件就不再存在了。 1234范例二：由于 services 是文本文件，请将范例一的压缩文件的内容读出来！ [dmtsai@study tmp]$ zcat services.gz # 由于 services 这个原本的文件是是文本文件，因此我们可以尝试使用 zcat/zmore/zless 去读取！ # 此时屏幕上会显示 servcies.gz 解压缩之后的源文件内容！ 12345678910111213范例三：将范例一的文件解压缩 [dmtsai@study tmp]$ gzip -d services.gz # 鸟哥不要使用 gunzip 这个指令，不好背！使用 gzip -d 来进行解压缩！ # 与 gzip 相反， gzip -d 会将原本的 .gz 删除，回复到原本的 services 文件。 范例四：将范例三解开的 services 用最佳的压缩比压缩，并保留原本的文件 [dmtsai@study tmp]$ gzip -9 9 -c services &gt; services.gz 范例五：由范例四再次建立的 services.gz 中，找出 http 这个关键词在哪几行？ [dmtsai@study tmp]$ zgrep -n &apos;http&apos; services.gz 14:# http://www.iana.org/assignments/port-numbers 89:http 80/tcp www www-http # WorldWideWeb HTTP 90:http 80/udp www www-http # HyperText Transfer Protocol 7.2.2 bzip2,bzcat/bzmore/bzless/bzgrep123456789101112131415161718192021222324252627[dmtsai@study ~]$ bzip2 [-cdkzv#] 檔名 [dmtsai@study ~]$ bzcat 檔名.bz2 选项与参数： -c ：将压缩的过程产生的数据输出到屏幕上！ -d ：解压缩的参数 -k ：保留源文件，而不会删除原始的文件喔！ -z ：压缩的参数 (默认值，可以不加) -v ：可以显示出原文件/压缩文件案的压缩比等信息； -# ：与 gzip 同样的，都是在计算压缩比的参数， -9 最佳， -1 最快！ 范例一：将刚刚 gzip 范例留下来的 /tmp/services 以 bzip2 压缩 [dmtsai@study tmp]$ bzip2 -v services services: 5.409:1, 1.479 bits/byte, 81.51% saved, 670293 in, 123932 out. [dmtsai@study tmp]$ ls -l services* -rw-r--r--. 1 dmtsai dmtsai 123932 Jun 30 18:40 services.bz2 -rw-rw-r--. 1 dmtsai dmtsai 135489 Jun 30 18:46 services.gz # 此时 services 会变成 services.bz2 之外，你也可以发现 bzip2 的压缩比要较 gzip 好喔！！ # 压缩率由 gzip 的 79% 提升到 bzip2 的 81% 哩！ 范例二：将范例一的文件内容读出来！ [dmtsai@study tmp]$ bzcat services.bz2 范例三：将范例一的文件解压缩 [dmtsai@study tmp]$ bzip2 -d services.bz2 范例四：将范例三解开的 services 用最佳的压缩比压缩，并保留原本的文件 [dmtsai@study tmp]$ bzip2 -9 9 -c services &gt; services.bz2 使用和gzip一模一样，压缩率要更好一些，但是对于大文件需要的时间要长 7.2.3 xz, xzcat/xzmore/xzless/xzgrep1234567891011121314151617181920212223242526272829303132333435[dmtsai@study ~]$ xz [-dtlkc#] 檔名 [dmtsai@study ~]$ xcat 檔名.xz.xz 选项与参数： -d ：就是解压缩啊！ -t ：测试压缩文件的完整性，看有没有错误 -l ：列出压缩文件的相关信息 -k ：保留原本的文件不删除～ -c ：同样的，就是将数据由屏幕上输出的意思！ -# ：同样的，也有较佳的压缩比的意思！ 范例一：将刚刚由 bzip2 所遗留下来的 /tmp/services 透过 xz 来压缩！ [dmtsai@study tmp]$ xz -v services services (1/1) 100 % 97.3 KiB / 654.6 KiB = 0.149 [dmtsai@study tmp]$ ls -l services* -rw-rw-r--. 1 dmtsai dmtsai 123932 Jun 30 19:09 services.bz2 -rw-rw-r--. 1 dmtsai dmtsai 135489 Jun 30 18:46 services.gz -rw-r--r--. 1 dmtsai dmtsai 99608 Jun 30 18:40 services.xz # 各位观众！看到没有啊！！容量又进一步下降的更多耶！好棒的压缩比！ 范例二：列出这个压缩文件的信息，然后读出这个压缩文件的内容 [dmtsai@study tmp]$ xz -l services.xz Strms Blocks Compressed Uncompressed Ratio Check Filename 1 1 97.3 KiB 654.6 KiB 0.149 CRC64 services.xz # 竟然可以列出这个文件的压缩前后的容量，真是太人性化了！这样观察就方便多了！ [dmtsai@study tmp]$ xzcat services.xz 范例三：将他解压缩吧！ [dmtsai@study tmp]$ xz -d services.xz 范例四：保留原文件的档名，并且建立压缩文件！ [dmtsai@study tmp]$ xz -k services 7.3 打包指令：tar 压缩： 123tar -jcv -f filename.tar.bz2 要被压缩的tar -jtv -f filename.tar.bz2 查 询tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录 解压缩： ​ 1234567891011121314151617选项与参数： -c ：建立打包文件，可搭配 -v 来察看过程中被打包的档名(filename) -t ：察看打包文件的内容含有哪些档名，重点在察看『档名』就是了； -x ：解打包或解压缩的功能，可以搭配 -C (大写) 在特定目录解开 特别留意的是， -c, -t, -x 不可同时出现在一串指令列中。 -z ：透过 gzip 的支持进行压缩/解压缩：此时档名最好为 *.tar.gz -j ：透过 bzip2 的支持进行压缩/解压缩：此时档名最好为 *.tar.bz2 -J ：透过 xz 的支持进行压缩/解压缩：此时档名最好为 *.tar.xz 特别留意， -z, -j, -J 不可以同时出现在一串指令列中 -v ：在压缩/解压缩的过程中，将正在处理的文件名显示出来！ -f filename：-f 后面要立刻接要被处理的档名！建议 -f 单独写一个选项啰！(比较不会忘记) -C 目录 ：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。 其他后续练习会使用到的选项介绍： -p(小写) ：保留备份数据的原本权限与属性，常用于备份(-c)重要的配置文件 -P(大写) ：保留绝对路径，亦即允许备份数据中含有根目录存在之意； --exclude=FILE：在压缩的过程中，不要将 FILE 打包 如果加上 -P 选项，那么文件名内的根目录就会存在喔！不过，鸟哥个人建议，还是不要加上 -P 这个选项来备份！ 毕竟很多时候，我们备份是为了要未来追踪问题用的，倒不一定需要还原回原本的系统中！ 所以拿掉根目录后，备份数据的应用会比较有弹性！也比较安全呢！ 查阅内容 1[root@study ~]# tar -jtv -f /root/etc.tar.bz2 解压缩 1234[root@study ~]# tar -jxv -f /root/etc.tar.bz2 [root@study ~]# ll ....(前面省略).... drwxr-xr-x. 131 root root 8192 Jun 26 22:14 etc 解压缩到指定文件 -C 12345# 解压缩到指定文件 -C[root@study ~]# tar -jxv -f /root/etc.tar.bz2 -C /tmp [root@study ~]# ll /tmp ....(前面省略).... drwxr-xr-x. 131 root root 解压缩单一文件的方法 123456789101112131415161718# 1. 先找到我们要的档名，假设解开 shadow 文件好了： [root@study ~]# tar -jtv jtv -f /root/etc.tar.bz2 | grep &apos;shadow&apos; ---------- root/root 721 2015-06-17 00:20 etc/gshadow ---------- root/root 1183 2015-06-17 00:20 etc/shadow- ---------- root/root 1210 2015-06-17 00:20 etc/shadow &lt;==这是我们要的！ ---------- root/root 707 2015-06-17 00:20 etc/gshadow- # 先搜寻重要的档名！其中那个 grep 是『撷取』关键词的功能！我们会在第三篇说明！ # 这里您先有个概念即可！那个管线 | 配合 grep 可以撷取关键词的意思！ # 2. 将该文件解开！语法与实际作法如下： [root@study ~]# tar -jxv -f f 打包檔.tar.bz2 待解待解开档开档名 [root@study ~]# tar -jxv -f /root/etc.tar.bz2 etc/shadow etc/shadow [root@study ~]# ll etc total 4 ----------. 1 root root 1210 Jun 17 00:20 shadow # 很有趣！此时只会解开一个文件而已！不过，重点是那个档名！你要找到正确的档名。 # 在本例中，你不能写成 /etc/shadow ！因为记录在 etc.tar.bz2 内的并没有 / 之故！ 打包某目录，但不包含目录下的某些文件之作法 –exclude 12[root@study ~]# tar -jcv -f /root/system.tar.bz2 ----exclude=/root/etc* \ &gt; ----exclude=/root/system.tar.bz2 /etc /root 上面的指令是一整列的～其实你可以打成：『tar -jcv -f /root/system.tar.bz2 –exclude=/root/etc* –exclude=/root/system.tar.bz2 /etc /root』，如果想要两行输入时，最后面加上反斜杠 () 并立刻按下 [enter] ， 就能够到第二行继续输入了。 仅备份比某个时刻还要新的文件 12345678910111213141516171819202122232425# 1. 先由 find 找出比 /etc/passwd 还要新的文件 [root@study ~]# find /etc -newer /etc/passwd ....(过程省略).... # 此时会显示出比 /etc/passwd 这个文件的 mtime 还要新的档名， # 这个结果在每部主机都不相同！您先自行查阅自己的主机即可，不会跟鸟哥一样！ [root@study ~]# ll /etc/passwd -rw-r--r--. 1 root root 2092 Jun 17 00:20 /etc/passwd # 2. 好了，那么使用 tar 来进行打包吧！日期为上面看到的 2015/06/17 [root@study ~]# tar -jcv jcv -f /root/etc.newer.then.passwd.tar.bz2 \ &gt; --newer-mtime=&quot;2015/06/17&quot; /etc/* tar: Option --newer-mtime: Treating date `2015/06/17&apos; as 2015-06-17 00:00:00 tar: Removing leading `/&apos; from member names /etc/abrt/ ....(中间省略).... /etc/alsa/ /etc/yum.repos.d/ ....(中间省略).... tar: /etc/yum.repos.d/CentOS-fasttrack.repo: file is unchanged; not dumped # 最后行显示的是『没有被备份的』，亦即 not dumped 的意思！ # 3. 显示出文件即可 [root@study ~]# tar -jtv jtv -f /root/etc.newer.then.passwd.tar.bz2 | grep -v &apos;/$&apos;v &apos;/$&apos; # 透过这个指令可以呼叫出 tar.bz2 内的结尾非 / 的檔名！就是我们要的啦！ 基本名称：tarfile,tarball 如果仅是打包而已，就是『 tar -cv -f file.tar 』而已，这个文件我们称呼为 tarfile 。 如果还有进行压缩的支持，例如『 tar -jcv -f file.tar.bz2 』时，我们就称呼为 tarball (tar 球？)！ 特殊应用：利用管线命令与数据流 12345678# 1. 将 /etc 整个目录一边打包一边在 /tmp 解开 [root@study ~]# cd /tmp [root@study tmp]# tar -cvf - /etc | tar -xvf xvf - # 这个动作有点像是 cp -r /etc /tmp 啦～依旧是有其有用途的！ # 要注意的地方在于输出档变成 - 而输入档也变成 - ，又有一个 | 存在～ # 这分别代表 standard output, standard input 与管线命令啦！ # 简单的想法中，你可以将 - 想成是在内存中的一个装置(缓冲区)。 # 更详细的数据流与管线命令，请翻到 bash 章节啰！ 解压缩后的SELlinux课题 SELinux 的权限问题『可能会让你的系统无法存取某些配置文件内容，导致影响到系统的正常使用权』。 透过各种可行的救援方式登入系统，然后修改 /etc/selinux/config 文件，将 SELinux 改成 permissive 模式，重新启动后系统就正常了； 在第一次复原系统后，不要立即重新启动！先使用 restorecon -Rv /etc 自动修复一下 SELinux 的类型即可。 透过各种可行的方式登入系统，建立 /.autorelabel 文件，重新启动后系统会自动修复 SELinux 的类型，并且又会再次重新启动，之后就正常了！ 7.4 XFS文件系统的备份与还原7.4.1 XFS 文件系统备份 xfsdump123456789[root@study ~]# xfsdump [-L S_label] [-M M_label] [-l #] [-f f 备份档] ] 待备份资料 [root@study ~]# xfsdump -I 选项与参数： -L ：xfsdump 会纪录每次备份的 session 标头，这里可以填写针对此文件系统的简易说明 -M ：xfsdump 可以纪录储存媒体的标头，这里可以填写此媒体的简易说明 -l ：是 L 的小写，就是指定等级～有 0~9 共 10 个等级喔！ (预设为 0，即完整备份) -f ：有点类似 tar 啦！后面接产生的文件，亦可接例如 /dev/st0 装置文件名或其他一般文件档名等 -I ：从 /var/lib/xfsdump/inventory 列出目前备份的信息状态 用xfsdump备份完整的文件系统 123456789101112131415# 1. 先确定 /boot 是独立的文件系统喔！ [root@study ~]# df -h /boot Filesystem Size Used Avail Use% Mounted on /dev/vda2 1014M 131M 884M 13% /boot # 挂载 /boot 的是 /dev/vda 装置！ # 看！确实是独立的文件系统喔！ /boot 是挂载点！ # 2. 将完整备份的文件名记录成为 /srv/boot.dump ： [root@study ~]# xfsdump -l 0 -L boot_all -M boot_all -f /srv/boot.dump /boot# 在指令的下达方面，你也可以不加 -L 及 -M 的，只是那就会进入互动模式，要求你 enter！ # 而执行 xfsdump 的过程中会出现如上的一些讯息，您可以自行仔细的观察！ [root@study ~]# ll /srv/boot.dump -rw-r--r--. 1 root root 102872168 Jul 1 18:43 /srv/boot.dump [root@study ~]# ll /var/lib/xfsdump/inventory 用xfsdump进行累计备份（Incremental backups） 12345678910111213141516171819202122232425262728293031323334353637# 0. 看一下有没有任何文件系统被 xfsdump 过的资料？ [root@study ~]# xfsdump -I# 我们可以看到目前仅有一个 session 0 的备份资料而已！而且是 level 0 喔！ # 1. 先恶搞一下，建立一个大约 10 MB 的文件在 /boot 内： [root@study ~]# dd if=/dev/zero of=/boot/testing.img bs=1M count=10 10+0 records in 10+0 records out 10485760 bytes (10 MB) copied, 0.166128 seconds, 63.1 MB/s # 2. 开始建立差异备份档，此时我们使用 level 1 吧： [root@study ~]# xfsdump -l 1 -L boot_2 -M boot_2 -f /srv/boot.dump1 /boot ....(中间省略).... [root@study ~]# ll /srv/boot* -rw-r--r--. 1 root root 102872168 Jul 1 18:43 /srv/boot.dump -rw-r--r--. 1 root root 10510952 Jul 1 18:46 /srv/boot.dump1 # 看看文件大小，岂不是就是刚刚我们所建立的那个大文件的容量吗？ ^_^ # 3. 最后再看一下是否有记录 level 1 备份的时间点呢？ [root@study ~]# xfsdump -Ifile system 0: fs id: 94ac5f77-cb8a-495e-a65b-2ef7442b837c session 0: mount point: study.centos.vbird:/boot device: study.centos.vbird:/dev/vda2 ....(中间省略).... session 1: mount point: study.centos.vbird:/boot device: study.centos.vbird:/dev/vda2 time: Wed Jul 1 18:46:21 2015 session label: &quot;boot_2&quot; session id: c71d1d41-b3bb-48ee-bed6-d77c939c5ee8 level: 1 resumed: NO....(中间省略).... 7.4.2 XFS 文件体统还原 xfsrestore123456789101112[root@study ~]# xfsrestore -I &lt;==用来察看备份文件资料 [root@study ~]# xfsrestore [-f f 备份档] [] [-L S_label] [-s] s] 待复原目录 &lt;==单一文件全系统复原 [root@study ~]# xfsrestore [-f f 备份文件] ] -r r 待复原目录 &lt;==透过累积备份文件来复原系统 [root@study ~]# xfsrestore [-f f 备份文件] ] -i i 待复原目录 &lt;==进入互动模式 选项与参数： -I ：跟 xfsdump 相同的输出！可查询备份数据，包括 Label 名称与备份时间等 -f ：后面接的就是备份档！企业界很有可能会接 /dev/st0 等磁带机！我们这里接档名！ -L ：就是 Session 的 Label name 喔！可用 -I 查询到的数据，在这个选项后输入！ -s ：需要接某特定目录，亦即仅复原某一个文件或目录之意！ -r ：如果是用文件来储存备份数据，那这个就不需要使用。如果是一个磁带内有多个文件， 需要这东西来达成累积复原 -i ：进入互动模式，进阶管理员使用的！一般我们不太需要操作它！ 用xfsrestore观察xfsdump后的备份数据内容 1234567891011121314151617181920212223242526[root@study ~]# xfsrestore -Ifile system 0: fs id: 94ac5f77-cb8a-495e-a65b-2ef7442b837c session 0: mount point: study.centos.vbird:/boot device: study.centos.vbird:/dev/vda2 time: Wed Jul 1 18:43:04 2015 session label: &quot;boot_all&quot; session id: 418b563f-26fa-4c9b-98b7-6f57ea pathname: /srv/boot.dump mfile size: 102872168 media label: &quot;boot_all&quot; session 1: mount point: study.centos.vbird:/boot device: study.centos.vbird:/dev/vda2 time: Wed Jul 1 18:46:21 2015 session label: &quot;boot_2&quot; session id: c71d1d41-b3bb-48ee-bed6-d77c939c5ee8 level: 1 pathname: /srv/boot.dump1 mfile size: 10510952 media label: &quot;boot_2&quot; xfsrestore: Restore Status: SUCCESS # 鸟哥已经将不重要的项目删除了，所以上面的输出是经过经简化的结果！ # 我们可以看到这个文件系统是 /boot 载点，然后有两个备份，一个 level 0 一个 level 1。 # 也看到这两个备份的资料他的内容大小！更重要的，就是那个 session label 喔！ 简单复原level 0的文件系统 1234567891011121314151617# 1. 直接将数据给它覆盖回去即可！ [root@study ~]# xfsrestore -f /srv/boot.dump -L boot_all /boot# 2. 将备份资料在 /tmp/boot 底下解开！ [root@study ~]# mkdir /tmp/boot [root@study ~]# xfsrestore -f /srv/boot.dump -L boot_all /tmp/boot [root@study ~]# du -sm /boot /tmp/boot 109 /boot 99 /tmp/boot # 咦！两者怎么大小不一致呢？没关系！我们来检查看看！ [root@study ~]# diff -r /boot /tmp/boot Only in /boot: testing.img # 看吧！原来是 /boot 我们有增加过一个文件啦！# 3. 仅复原备份档内的 grub2 到 /tmp/boot2/ 里头去！ [root@study ~]# mkdir /tmp/boot2 [root@study ~]# xfsrestore -f /srv/boot.dump -L boot_all -s grub2 /tmp/boot2 复原累积备份资料 12# 继续复原 level 1 到 /tmp/boot 当中！ [root@study ~]# xfsrestore -f /srv/boot.dump1 /tmp/boot 仅还原部分文件的xfsrestore互动模式 12345678910111213141516171819202122232425262728293031323334353637383940# 1. 先进入备份文件内，准备找出需要备份的文件名数据，同时预计还原到 /tmp/boot3 当中！ [root@study ~]# mkdir /tmp/boot3 [root@study ~]# xfsrestore -f /srv/boot.dump -i /tmp/boot3 ========================== subtree selection dialog ========================== the following commands are available: pwd ls [ &lt;path&gt; ] cd [ &lt;path&gt; ] add [ &lt;path&gt; ] # 可以加入复原文件列表中 delete [ &lt;path&gt; ] # 从复原列表拿掉档名！并非删除喔！ extract # 开始复原动作！ quit help -&gt; ls 455517 initramfs-3.10.0-229.el7.x86_64kdump.img 138 initramfs-3.10.0-229.el7.x86_64.img 141 initrd-plymouth.img 140 vmlinuz-0-rescue-309eb890d09f440681f596543d95ec7a 139 initramfs-0-rescue-309eb890d09f440681f596543d95ec7a.img 137 vmlinuz-3.10.0-229.el7.x86_64 136 symvers-3.10.0-229.el7.x86_64.gz 135 config-3.10.0-229.el7.x86_64 134 System.map-3.10.0-229.el7.x86_64 133 .vmlinuz-3.10.0-229.el7.x86_64.hmac 1048704 grub2/ 131 grub/ -&gt; add grub -&gt; add grub2 -&gt; add config-3.10.0-229.el7.x86_64 -&gt; extract [root@study ~]# ls -l /tmp/boot3 -rw-r--r--. 1 root root 123838 Mar 6 19:45 config-3.10.0-229.el7.x86_64 drwxr-xr-x. 2 root root 26 May 4 17:52 grub drwxr-xr-x. 6 root root 104 Jun 25 00:02 grub2 # 就只会有 3 个档名被复原，当然，如果文件名是目录，那底下的子文件当然也会被还原回来的！ 7.5 光盘写入工具 先将所需要备份的数据建置成为一个映像档(iso)，利用 mkisofs 指令来处理； 将该映像文件刻录至光盘或 DVD 当中，利用 cdrecord 指令来处理。 7.5.1 mkisofs：建立映像档 制作一般数据光盘映像文件 mkisofs 12345678910[root@study ~]# mkisofs [-o o 映像档] [] [-Jrv] [-V vol] [-m file] 待备份文件份文件... ... \ &gt; -graft-point isodir=systemdir ... 选项与参数： -o ：后面接你想要产生的那个映像档档名。 -J ：产生较兼容于 windows 机器的文件名结构，可增加文件名长度到 64 个 unicode 字符 -r ：透过 Rock Ridge 产生支持 Unix/Linux 的文件数据，可记录较多的信息(如 UID/GID 等) ； -v ：显示建置 ISO 文件的过程 -V vol ：建立 Volume，有点像 Windows 在文件总管内看到的 CD title 的东西 -m file ：-m 为排除文件 (exclude) 的意思，后面的文件不备份到映像档中，也能使用 * 通配符喔 -graft-point：graft 有转嫁或移植的意思，相关资料在底下文章内说明。 ​ 光盘的格式一般称为 iso9660 ，这种格式一般仅支持旧版的 DOS 檔名，亦即檔名只能以 8.3 (文件名 8 个字符，扩展名 3 个字符) 的方式存在。 1234567891011121314151617[root@study ~]# ll -h /tmp/system.img -rw-r--r--. 1 root root 117M Jul 2 18:48 /tmp/system.img [root@study ~]# mount -o loop /tmp/system.img /mnt [root@study ~]# df -h /mnt Filesystem Size Used Avail Use% Mounted on /dev/loop0 117M 117M 0 100% /mnt [root@study ~]# ls /mnt abrt festival mail.rc rsyncd.conf adjtime filesystems makedumpfile.conf.sample rsyslog.conf alex firewalld man_db.conf rsyslog.d # 看吧！一堆数据都放置在一起！包括有的没有的目录与文件等等！ [root@study ~]# umount /mnt # 测试完毕要记得卸除！ -graft-point 123456789101112131415[root@study ~]# mkisofs -r r -V &apos;linux_file&apos; -o /tmp/system.img \ &gt; -m /root/etc -graft-point /root=/root /home=/home /etc=/etc [root@study ~]# ll -h /tmp/system.img -rw-r--r--. 1 root root 92M Jul 2 19:00 /tmp/system.img # 上面的指令会建立一个大文件，其中 -graft-point 后面接的就是我们要备份的数据。 # 必须要注意的是那个等号的两边，等号左边是在映像文件内的目录，右侧则是实际的数据。 [root@study ~]# mount -o loop /tmp/system.img /mnt/mnt [root@study ~]# ll /mnt dr-xr-xr-x. 131 root root 34816 Jun 26 22:14 etc dr-xr-xr-x. 5 root root 2048 Jun 17 00:20 home dr-xr-xr-x. 8 root root 4096 Jul 2 18:48 root # 瞧！数据是分门别类的在各个目录中喔这样了解乎？最后将数据卸除一下： [root@study ~]# umount /mnt 制作修改可开机光盘映像档 1234567891011121314151、先观察一下这片光盘里面有什么东西[root@study ~]# isoinfo -d -i /home/CentOS-7-x86_64-Minimal-15031503-01.iso2、开始挂载这片光盘到 /mnt 并将完整的数据复制到/srv/newcd中去[root@study ~]# mount /home/CentOS-7-x86_64-Minimal-15031503-01.iso /mnt [root@study ~]# mkdir /srv/newcd [root@study ~]# rsync -a /mnt/ /srv/newcd [root@study ~]# ll /srv/newcd/ -rw-r--r--. 1 root root 16 Apr 1 07:11 CentOS_BuildTag# rsync 可以完整的复制所有的权限属性等数据，也能够进行镜像处理！相当好用的指令喔！ # 这里先了解一下即可。现在 newcd/ 目录内已经是完整的映像档内容！# 3. 假设已经处理完毕你在 /srv/newcd 里面所要进行的各项修改行为，准备建立 ISO 檔！ [root@study ~]# ll /srv/newcd/isolinux/[root@study ~]# cd /srv/newcd [root@study newcd]# mkisofs -o /custom.iso -b isolinux/isolinux.bin -c isolinux/boot.cat \ &gt; -no-emul-boot -V &apos;CentOS 7 x86_64&apos; -bootboot-loadload-size 4 -bootboot-infoinfo-table table -R R -J J -v v -T . 此时你就有一个 /custom.img 的文件存在，可以将该光盘刻录出来啰！就这么简单！ 7.5.2 cdrecord：光盘刻录工具Centos 7使用的是wodim文字界面来进行刻录行为的，不过为了兼容旧版依然可以使用cdrecord，建议使用wodim。 1234567891011121314151617181920[root@study ~]# wodim ----devices dev=/dev/sr0... &lt;==查询刻录机的 BUS 位置 [root@study ~]# wodim -v dev=/dev/sr0 blank=[fast|all] &lt;==抹除重复读写片 [root@study ~]# wodim -v dev=/dev/sr0 -format &lt;==格式化 DVD+RW [root@study ~]# wodim -v dev=/dev/sr0 [可用可用选项选项功能功能] file.iso 选项与参数： --devices ：用在扫瞄磁盘总线并找出可用的刻录机，后续的装置为 ATA 接口 -v ：在 cdrecord 运作的过程中，显示过程而已。 dev=/dev/sr0 ：可以找出此光驱的 bus 地址，非常重要！ blank=[fast|all]：blank 为抹除可重复写入的 CD/DVD-RW，使用 fast 较快，all 较完整 -format ：对光盘片进行格式化，但是仅针对 DVD+RW 这种格式的 DVD 而已； [可用选项功能] 主要是写入 CD/DVD 时可使用的选项，常见的选项包括有： -data ：指定后面的文件以数据格式写入，不是以 CD 音轨(-audio)方式写入！ speed=X ：指定刻录速度，例如 CD 可用 speed=40 为 40 倍数，DVD 则可用 speed=4 之类 -eject ：指定刻录完毕后自动退出光盘 fs=Ym ：指定多少缓冲存储器，可用在将映像档先暂存至缓冲存储器。预设为 4m， 一般建议可增加到 8m ，不过，还是得视你的刻录机而定。 针对 DVD 的选项功能： driveropts=burnfree ：打开 Buffer Underrun Free 模式的写入功能 -sao ：支持 DVD-RW 的格式 检测你刻录机所在位置 123456789101112131415[root@study ~]# ll /dev/sr0 brw-rw----+ 1 root cdrom 11, 0 Jun 26 22:14 /dev/sr0 # 一般 Linux 光驱文件名！ [root@study ~]# wodim ----devices dev=/dev/sr0 ------------------------------------------------------------------------- 0 dev=&apos;/dev/sr0&apos; rwrw-- : &apos;QEMU&apos; &apos;QEMU DVD-ROM&apos; ------------------------------------------------------------------------- [root@demo ~]# wodim ----devices dev=/dev/sr0 wodim: Overview of accessible drives (1 found) : ------------------------------------------------------------------------- 0 dev=&apos;/dev/sr0&apos; rwrw-- : &apos;ASUS&apos; &apos;DRW-24D1ST&apos; ------------------------------------------------------------------------- # 你可以发现到其实鸟哥做了两个测试！上面的那部主机系统是虚拟机，当然光驱也是仿真的，没法用。 # 因此在这里与底下的 wodim 用法，鸟哥只能使用另一部 Demo 机器测试给大家看了！ 进行CD/DVD的刻录动作： 1234567891011121314151617181920# 0. 先抹除光盘的原始内容：(非可重复读写则可略过此步骤) [root@demo ~]# wodim -v dev=/dev/sr0 blank=fast # 中间会跑出一堆讯息告诉你抹除的进度，而且会有 10 秒钟的时间等待你的取消！ # 1. 开始刻录： [root@demo ~]# wodim -v v dev=/dev/sr0 speed=4 -dummy -eject /tmp/system.img# 2. 刻录完毕后，测试挂载一下，检验内容： [root@demo ~]# mount /dev/sr0/mnt [root@demo ~]# df -h /mnt Filesystem Size Used Avail Use% Mounted on Filesystem Size Used Avail Use% Mounted on /dev/sr0 87M 87M 0 100% /mnt [root@demo ~]# ll /mnt dr-xr-xr-x. 135 root root 36864 Jun 30 04:00 etc dr-xr-xr-x. 19 root root 8192 Jul 2 13:16 root [root@demo ~]# umount /mnt &lt;==不要忘了卸除 7.6 其他常见的压缩和备份工具7.6.1 dd​ dd最大功能是用来备份 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849[root@study ~]# dd if=&quot;input_file&quot; of=&quot;output_file&quot; bs=&quot;block_size&quot; count=&quot;number&quot; 选项与参数： if ：就是 input file 啰～也可以是装置喔！ of ：就是 output file 喔～也可以是装置； bs ：规划的一个 block 的大小，若未指定则预设是 512 bytes(一个 sector 的大小) count：多少个 bs 的意思。 范例一：将 /etc/passwd 备份到 /tmp/passwd.back 当中 [root@study ~]# dd if=/etc/passwd of=/tmp/passwd.back 4+1 records in 4+1 records out 2092 bytes (2.1 kB) copied, 0.000111657 s, 18.7 MB/s [root@study ~]# ll /etc/passwd /tmp/passwd.back -rw-r--r--. 1 root root 2092 Jun 17 00:20 /etc/passwd -rw-r--r--. 1 root root 2092 Jul 2 23:27 /tmp/passwd.back # 仔细的看一下，我的 /etc/passwd 文件大小为 2092 bytes，因为我没有设定 bs ， # 所以默认是 512 bytes 为一个单位，因此，上面那个 4+1 表示有 4 个完整的 512 bytes， # 以及未满 512 bytes 的另一个 block 的意思啦！事实上，感觉好像是 cp 这个指令啦～ 范例二：将刚刚刻录的光驱的内容，再次的备份下来成为映像挡 [root@study ~]# dd if=/dev/sr0 of=/tmp/system.iso 177612+0 records in 177612+0 records out 90937344 bytes (91 MB) copied, 22.111 s, 4.1 MB/s # 要将数据抓下来用这个方法，如果是要将映像文件写入 USB 磁盘，就会变如下一个范例啰！ 范例三：假设你的 USB 是 /dev/sda 好了，请将刚刚范例二的 image 刻录到 USB 磁盘中 [root@study ~]# lsblk /dev/sda NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 2G 0 disk # 确实是 disk 而且有 2GB 喔！ [root@study ~]# dd if=/tmp/system.iso of=/dev/sda [root@study ~]# mount /dev/sda /mnt [root@study ~]# ll /mnt dr-xr-xr-x. 131 root root 34816 Jun 26 22:14 etc dr-xr-xr-x. 5 root root 2048 Jun 17 00:20 home dr-xr-xr-x. 8 root root 4096 Jul 2 18:48 root # 如果你不想要使用 DVD 来作为开机媒体，那可以将映像档使用这个 dd 写入 USB 磁盘， # 该磁盘就会变成跟可开机光盘一样的功能！可以让你用 USB 来安装 Linux 喔！速度快很多！ 范例四：将你的 /boot 整个文件系统透过 dd 备份下来 [root@study ~]# df -h /boot Filesystem Size Used Avail Use% Mounted on /dev/vda2 1014M 149M 866M 15% /boot # 请注意！备份的容量会到 1G 喔！ [root@study ~]# dd if=/dev/vda2 of=/tmp/vda2.img [root@study ~]# ll -h /tmp/vda2.img -rw-r--r--. 1 root root 1.0G Jul 2 23:39 /tmp/vda2.img # 等于是将整个 /dev/vda2 通通捉下来的意思～所以，文件容量会跟整颗磁盘的最大量一样大！ ‘]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php无限极分类]]></title>
    <url>%2F2020%2F08%2F17%2Fphp%E6%97%A0%E9%99%90%E6%9E%81%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[无限极分类12345678910111213141516171819202122232425public function getTree()&#123; $data = [ ['id'=&gt;1,'name'=&gt;'x1','pid'=&gt;0], ['id'=&gt;2,'name'=&gt;'x2','pid'=&gt;1], ['id'=&gt;3,'name'=&gt;'x3','pid'=&gt;0], ['id'=&gt;4,'name'=&gt;'x4','pid'=&gt;2], ['id'=&gt;5,'name'=&gt;'x5','pid'=&gt;2], ['id'=&gt;6,'name'=&gt;'x6','pid'=&gt;4] ]; $items = array(); foreach ($data as $v)&#123; $v['category_id'] = $v['id']; $items[$v['category_id']]=$v; &#125; $tree = []; foreach ($items as $id=&gt;$item)&#123; if(isset($items[$item['pid']]))&#123; $items[$item['pid']]['list'][]=&amp;$items[$id]; &#125;else&#123; $tree[]=&amp;$items[$id]; &#125; &#125; print_r($tree);&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php——Md5Rsa加密]]></title>
    <url>%2F2020%2F08%2F17%2Fphp_Md5Rsa%2F</url>
    <content type="text"><![CDATA[Md5Rsa加密 Md5rsa.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?phpnamespace libs;class Md5rsa&#123; /** * 利用约定数据和私钥生成数字签名 * @param $data 待签数据 * @return String 返回签名 */ public function sign($data='') &#123; if (empty($data)) &#123; return False; &#125; $private_key = file_get_contents(dirname(__FILE__) . '/rsa_private_key.pem'); if (empty($private_key)) &#123; echo "Private Key error!"; return False; &#125; $pkeyid = openssl_get_privatekey($private_key); if (empty($pkeyid)) &#123; echo "private key resource identifier False!"; return False; &#125; $verify = openssl_sign($data, $signature, $pkeyid, OPENSSL_ALGO_MD5); openssl_free_key($pkeyid); return $signature; &#125; /** * 利用公钥和数字签名以及约定数据验证合法性 * @param $data 待验证数据 * @param $signature 数字签名 * @return -1:error验证错误 1:correct验证成功 0:incorrect验证失败 */ public function isValid($data='', $signature='') &#123; if (empty($data) || empty($signature)) &#123; return False; &#125; $public_key = file_get_contents(dirname(__FILE__) . '/rsa_java_public_key.pem');//rsa_public_key if (empty($public_key)) &#123; echo "Public Key error!"; return False; &#125; $pkeyid = openssl_get_publickey($public_key); if (empty($pkeyid)) &#123; echo "public key resource identifier False!"; return False; &#125; $ret = openssl_verify($data, $signature, $pkeyid, OPENSSL_ALGO_MD5); switch ($ret) &#123; case -1: echo "error"; return false;// break; default: if($ret==1)&#123; $ret = 1; &#125;else&#123; return false; &#125;// echo $ret==1 ? "true" : "false";//0:incorrect break; &#125; return $ret; &#125;&#125; 加签名 12345public function myMd5rsa($data)&#123; $md5Rsa = new Md5rsa(); $res = $md5Rsa-&gt;sign($data); return $res;&#125; 验签名 1234567public function checkPass()&#123;$res = (new Md5rsa()) -&gt;isValid($post['data'],base64_decode($post['sign'])); if($res===false)&#123; ajaxReturn(0,'验证失败'); &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[与青春有关的日子]]></title>
    <url>%2F2020%2F07%2F16%2F%E4%B8%8E%E9%9D%92%E6%98%A5%E6%9C%89%E5%85%B3%E7%9A%84%E6%97%A5%E5%AD%90%2F</url>
    <content type="text"><![CDATA[第01集$http://zy.kubozy-sohu-360-sogou.com/20190910/5951_e497ce7e/index.m3u8 第02集$http://zy.kubozy-sohu-360-sogou.com/20190910/5948_f57450ae/index.m3u8 第03集$http://zy.kubozy-sohu-360-sogou.com/20190910/5946_d4525eda/index.m3u8 第04集$http://zy.kubozy-sohu-360-sogou.com/20190910/5944_d3b6ea1d/index.m3u8 第05集$http://zy.kubozy-sohu-360-sogou.com/20190910/5942_811768b7/index.m3u8 第06集$http://zy.kubozy-sohu-360-sogou.com/20190910/5940_ca18e17f/index.m3u8 第07集$http://zy.kubozy-sohu-360-sogou.com/20190910/5938_31f3f2ca/index.m3u8 第08集$http://zy.kubozy-sohu-360-sogou.com/20190910/5936_a80e34e9/index.m3u8 第09集$http://zy.kubozy-sohu-360-sogou.com/20190910/5935_63012d17/index.m3u8 第10集$http://zy.kubozy-sohu-360-sogou.com/20190910/5933_9ca10621/index.m3u8 第11集$http://zy.kubozy-sohu-360-sogou.com/20190910/5931_0b7322a4/index.m3u8 第12集$http://zy.kubozy-sohu-360-sogou.com/20190910/5929_7df7d6c9/index.m3u8 第13集$http://zy.kubozy-sohu-360-sogou.com/20190910/5927_c3a54264/index.m3u8 第14集$http://zy.kubozy-sohu-360-sogou.com/20190910/5925_aeed061c/index.m3u8 第15集$http://zy.kubozy-sohu-360-sogou.com/20190910/5923_0d82e49d/index.m3u8 第16集$http://zy.kubozy-sohu-360-sogou.com/20190910/5921_cdf3cc2c/index.m3u8 第17集$http://zy.kubozy-sohu-360-sogou.com/20190910/5919_f0221218/index.m3u8 第18集$http://zy.kubozy-sohu-360-sogou.com/20190910/5917_bd26590c/index.m3u8 第19集$http://zy.kubozy-sohu-360-sogou.com/20190910/5915_b7014f94/index.m3u8 第20集$http://zy.kubozy-sohu-360-sogou.com/20190910/5914_e322f1e5/index.m3u8 第21集$http://zy.kubozy-sohu-360-sogou.com/20190910/5911_92340ede/index.m3u8 第22集$http://zy.kubozy-sohu-360-sogou.com/20190910/5908_97929005/index.m3u8 第23集$http://zy.kubozy-sohu-360-sogou.com/20190910/5903_738f4ec1/index.m3u8 第24集$http://zy.kubozy-sohu-360-sogou.com/20190910/5898_8af66216/index.m3u8 第25集$http://zy.kubozy-sohu-360-sogou.com/20190910/5894_79a816dc/index.m3u8 第26集$http://zy.kubozy-sohu-360-sogou.com/20190910/5889_24967d45/index.m3u8 第27集$http://zy.kubozy-sohu-360-sogou.com/20190910/5884_097ac00a/index.m3u8 第28集$http://zy.kubozy-sohu-360-sogou.com/20190910/5881_b88341ba/index.m3u8 第29集$http://zy.kubozy-sohu-360-sogou.com/20190910/5878_1196fd27/index.m3u8 第30集$http://zy.kubozy-sohu-360-sogou.com/20190910/5874_c14cd3ac/index.m3u8 第31集$http://zy.kubozy-sohu-360-sogou.com/20190910/5871_94f1e632/index.m3u8 第32集$http://zy.kubozy-sohu-360-sogou.com/20190910/5867_fdc4f2ae/index.m3u8 第33集$http://zy.kubozy-sohu-360-sogou.com/20190910/5864_f2286061/index.m3u8 第34集$http://zy.kubozy-sohu-360-sogou.com/20190910/5860_5c95dc31/index.m3u8 第35集$http://zy.kubozy-sohu-360-sogou.com/20190910/5856_da7b3297/index.m3u8 第36集$http://zy.kubozy-sohu-360-sogou.com/20190910/5853_9222ff0a/index.m3u8 第37集$http://zy.kubozy-sohu-360-sogou.com/20190910/5838_436360ed/index.m3u8 第38集$http://zy.kubozy-sohu-360-sogou.com/20190910/5815_69d8d80b/index.m3u8 第39集$http://zy.kubozy-sohu-360-sogou.com/20190910/5791_c6790c5d/index.m3u8 第40集$http://zy.kubozy-sohu-360-sogou.com/20190910/5769_c7b6a413/index.m3u8 第41集$http://zy.kubozy-sohu-360-sogou.com/20190910/5754_143f3a36/index.m3u8 第42集$http://zy.kubozy-sohu-360-sogou.com/20190910/5743_17c71a40/index.m3u8 第43集$http://zy.kubozy-sohu-360-sogou.com/20190910/5735_5d13013b/index.m3u8 第44集$http://zy.kubozy-sohu-360-sogou.com/20190910/5720_dea07443/index.m3u8 第45集$http://zy.kubozy-sohu-360-sogou.com/20190910/5719_b81ee80b/index.m3u8 第46集$http://zy.kubozy-sohu-360-sogou.com/20190910/5718_03596a9d/index.m3u8 第47集$http://zy.kubozy-sohu-360-sogou.com/20190910/5717_2a2920e5/index.m3u8 第48集$http://zy.kubozy-sohu-360-sogou.com/20190910/5716_771362b1/index.m3u8 第49集$http://zy.kubozy-sohu-360-sogou.com/20190910/5715_a7c24bea/index.m3u8 第50集$http://zy.kubozy-sohu-360-sogou.com/20190910/5714_7185f78e/index.m3u8 第51集$http://zy.kubozy-sohu-360-sogou.com/20190910/5713_007bd494/index.m3u8 第52集$http://zy.kubozy-sohu-360-sogou.com/20190910/5712_1af52215/index.m3u8 第01集$http://zy.kubozy-sohu-360-sogou.com/share/800b03685c22049f049801f6841861a2 第02集$http://zy.kubozy-sohu-360-sogou.com/share/cd0b43eac0392accf3624b7372dec36e 第03集$http://zy.kubozy-sohu-360-sogou.com/share/926ffc0ca56636b9e73c565cf994ea5a 第04集$http://zy.kubozy-sohu-360-sogou.com/share/90f4760fcc9b69c13da7368c5c2917f3 第05集$http://zy.kubozy-sohu-360-sogou.com/share/b0dd033cbe58aa5ea27747271bfd84e3 第06集$http://zy.kubozy-sohu-360-sogou.com/share/c17028c9b6e0c5deaad29665d582284a 第07集$http://zy.kubozy-sohu-360-sogou.com/share/62e0973455fd26eb03e91d5741a4a3bb 第08集$http://zy.kubozy-sohu-360-sogou.com/share/60131a2a3f223dc8f4753bcc5771660c 第09集$http://zy.kubozy-sohu-360-sogou.com/share/234dd9e577ac5892481bc60663ffa405 第10集$http://zy.kubozy-sohu-360-sogou.com/share/a5d42e4024cc540befb48f466820e25f 第11集$http://zy.kubozy-sohu-360-sogou.com/share/aa1b6b26d690368d6f74a35a7daa0916 第12集$http://zy.kubozy-sohu-360-sogou.com/share/05f17e3cfa5de42020eaa6df34fb4805 第13集$http://zy.kubozy-sohu-360-sogou.com/share/c8afe805c097dab1f1e5bdd57f8d2931 第14集$http://zy.kubozy-sohu-360-sogou.com/share/979a3f14bae523dc5101c52120c535e9 第15集$http://zy.kubozy-sohu-360-sogou.com/share/418db2ea5d227a9ea8db8e5357ca2084 第16集$http://zy.kubozy-sohu-360-sogou.com/share/b59442085644532ef03417a3e5a76437 第17集$http://zy.kubozy-sohu-360-sogou.com/share/cd755a6c6b699f3262bcc2aa46ab507e 第18集$http://zy.kubozy-sohu-360-sogou.com/share/78e092e6f3d8a7b10a82c6abd756d748 第19集$http://zy.kubozy-sohu-360-sogou.com/share/9ba196c7a6e89eafd0954de80fc1b224 第20集$http://zy.kubozy-sohu-360-sogou.com/share/dd5bfdeb57f7c75d400de61e99d78e2e 第21集$http://zy.kubozy-sohu-360-sogou.com/share/84a955d5ff75f508ec01007bc2b9b301 第22集$http://zy.kubozy-sohu-360-sogou.com/share/8804f94e16ba5b680e239a554a08f7d2 第23集$http://zy.kubozy-sohu-360-sogou.com/share/367147f1755502d9bc6189f8e2c3005d 第24集$http://zy.kubozy-sohu-360-sogou.com/share/eecccd8ff4107946c78d42265cd474b5 第25集$http://zy.kubozy-sohu-360-sogou.com/share/8973ba741e7bd6450d8023552f43728e 第26集$http://zy.kubozy-sohu-360-sogou.com/share/a3bf6e4db673b6449c2f7d13ee6ec9c0 第27集$http://zy.kubozy-sohu-360-sogou.com/share/7ed2d3454c5eea71148b11d0c25104ff 第28集$http://zy.kubozy-sohu-360-sogou.com/share/6d378765f17a856b7ba8bf1541cafb69 第29集$http://zy.kubozy-sohu-360-sogou.com/share/e0ae4561193dbf6e4cf7e8f4006948e3 第30集$http://zy.kubozy-sohu-360-sogou.com/share/85d6e9c8255c0364fb67b5ac8a25eea3 第31集$http://zy.kubozy-sohu-360-sogou.com/share/07bba581a2dd8d098a3be0f683560643 第32集$http://zy.kubozy-sohu-360-sogou.com/share/fc9e62695def29ccdb9eb3fed5b4c8c8 第33集$http://zy.kubozy-sohu-360-sogou.com/share/7cdace91c487558e27ce54df7cdb299c 第34集$http://zy.kubozy-sohu-360-sogou.com/share/32508f53f24c46f685870a075eaaa29c 第35集$http://zy.kubozy-sohu-360-sogou.com/share/10112bde2ba78e674b21aaa84613bc8e 第36集$http://zy.kubozy-sohu-360-sogou.com/share/367692068f069c135b7d5a3a59e470d3 第37集$http://zy.kubozy-sohu-360-sogou.com/share/a91bc76c2a6302e573badedcbf57bf7a 第38集$http://zy.kubozy-sohu-360-sogou.com/share/2835acf1b5aaa6ade0d10b4c977e912a 第39集$http://zy.kubozy-sohu-360-sogou.com/share/05b0afd266cc205432b8dad3f3413c28 第40集$http://zy.kubozy-sohu-360-sogou.com/share/bbc12a3a98d8487f58a87d3a3070516e 第41集$http://zy.kubozy-sohu-360-sogou.com/share/0dbcf39d413231953d442f2f17f80cd5 第42集$http://zy.kubozy-sohu-360-sogou.com/share/31f81674a348511b990af268ca3a8391 第43集$http://zy.kubozy-sohu-360-sogou.com/share/6d34d468ac8876333c4d7173b85efed9 第44集$http://zy.kubozy-sohu-360-sogou.com/share/e34376937c784505d9b4fcd980c2f1ce 第45集$http://zy.kubozy-sohu-360-sogou.com/share/0b33f2e8843e8b440dd8caf7086995b0 第46集$http://zy.kubozy-sohu-360-sogou.com/share/25daeb9b3072e9c53f66a2196a92a011 第47集$http://zy.kubozy-sohu-360-sogou.com/share/dae3312c4c6c7000a37ecfb7b0aeb0e4 第48集$http://zy.kubozy-sohu-360-sogou.com/share/fd4771e85e1f916f239624486bff502d 第49集$http://zy.kubozy-sohu-360-sogou.com/share/6e4243f5511fd6ef0f03e9f386d54403 第50集$http://zy.kubozy-sohu-360-sogou.com/share/0fe6a94848e5c68a54010b61b3e94b0e 第51集$http://zy.kubozy-sohu-360-sogou.com/share/5e7d00134ba3a8b3e37edf5038bc51fc 第52集$http://zy.kubozy-sohu-360-sogou.com/share/a6b8deb7798e7532ade2a8934477d3ce]]></content>
      <categories>
        <category>影视</category>
      </categories>
      <tags>
        <tag>电视剧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电影]]></title>
    <url>%2F2020%2F06%2F09%2F%E7%94%B5%E5%BD%B12020-6-9%2F</url>
    <content type="text"><![CDATA[血液机器http://zy.kubozy-qq-360-sogou.com/share/f708f064faaf32a43e4d3c784e6af9ea 超世纪战神http://zy.kubozy-qq-360-sogou.com/share/5314b9674c86e3f9d1ba25ef9bb32895 AI崩坏http://zy.kubozy-qq-360-sogou.com/share/f7e0b956540676a129760a3eae309294 史前一亿年http://zy.zxziyuan-yun.com/share/lcajX643DGG1OyT7 巨鲨大战食人鳄/噬人鲨大战食人鳄噬人鲨大战食人鳄http://youku.com-kubozy.com/share/6SqWDouTHPWD3NnY 惊涛迷局http://zy.kuboy-aiqiyi-163.com/share/c4bb5a353be47442aa65df4e7ec64cae 莫斯科陷落2http://zy.kuboy-aiqiyi-163.com/share/0b7fd9d2155471c9ae714ee8b6709386 永恒代码http://zy.kuboy-aiqiyi-163.com/share/a1c62fbf4642034e14471693862c7434 灭绝(2018)http://zy.kubo-360-tudou.com/share/5f1d7043087ae82ff6a62662b62a0fbc 深渊巨兽http://yun.zxziyuan-yun.com/share/d8696cc3e3447ac44237a936a80b05d8 终结者：黑暗命运http://zy.kuboy-aiqiyi-163.com/share/5285a1493a5742c839cdf4cf7311beea 圆环行动http://zy.kuboy-aiqiyi-163.com/share/1501c2e690dba321cc03859b0bd0b5fb 杜立巴http://zy.kuboy-aiqiyi-163.com/share/9f81250cf78de6e784e780b5c9958cc2 病毒抗体http://yun.kubo-zy-youku.com/share/le6iAGpt3cfLNT7u 机械陪伴http://zy.kuboy-aiqiyi-163.com/share/da04e7275d1e3a97f9dff39f2340fb86 超时空犯罪小队http://yun.zxziyuan-yun.com/share/131e28c946ec1e010dc02a8f53cec237 心慌慌http://yun.zxziyuan-yun.com/share/47b4bf45a262ed01def0ca1bea603991 宇杀员http://yun.zxziyuan-yun.com/share/9a3e594b26056b67a02cac0e510393d1 短波http://yun.zxziyuan-yun.com/share/bJXduutcWQIviVXM 纸上谋杀http://zy.kuboy-aiqiyi-163.com/share/301c8eb1f76e106ec1bcf7a70ad25ffd 异种3http://zy.kubo-163-360.com/share/80568f6743b6126cb61be9f97c55ba85 异种4http://zy.kubo-163-360.com/share/bc8741c4e92bbbca75ab9fe51f54664a 异种2http://zy.kubo-163-360.com/share/ffe4a40fecc90fa1120088e704712fb2 异种1http://zy.kubo-163-360.com/share/eff3058117fd4cf4d4c3af12e273a40f 死者的孩子http://zy.kuboy-aiqiyi-163.com/share/e6f9f20dad3eec7008b77d10ff08f14c 爱在星空下http://yun.zxziyuan-yun.com/share/1a2415c433a4d3d7634fcd104c607e26 生态箱http://zy.kuboy-aiqiyi-163.com/share/00b5d2692a781b6a9d3d1522c6e9d1ad 逃亡僵尸岛http://zy.kuboy-aiqiyi-163.com/share/c51c55cec7054dd833f192a7895b378c 星球大对决http://zy.kuboy-aiqiyi-163.com/share/7878b14e9d762184301b06f3f609ead7 喋血战士http://yun.zxziyuan-yun.com/share/e6a3684de5e80c535db4f65de1d27041 太空英雌芭芭丽娜http://yun.zxziyuan-yun.com/share/ad1c145ebcbfebe02e9107405d585cee 异界http://zy.kuboy-aiqiyi-163.com/share/7fa2c598be3498baead8d1d2c4485ab9 亡魂岛(1932)http://yun.zxziyuan-yun.com/share/b1a6da1fe555b20268bf9ce70ed980e7 系列怪兽区 加拉斯http://yun.zxziyuan-yun.com/share/8412670cc10f39db2e3285faaac95c5e 饥饿站台http://zy.kuboy-aiqiyi-163.com/share/e394c4fcf4858aeb877a99486c9c9418 隐身人2020http://yun.zxziyuan-yun.com/share/eef83da5f4bf1168b71baec76e8d17cb 副本：义体置换http://zy.kuboy-aiqiyi-163.com/share/3dcc0806127ac6878b990a079e4f8c77 我是人类http://yun.zxziyuan-yun.com/share/a588b762d68fe60225d3de3c647a52b9 星球大战9：天行者崛起http://zy.kuboy-aiqiyi-163.com/share/d481fbe55e77099eef411a60f2d36fca 黑色尾流http://zy.kuboy-aiqiyi-163.com/share/4fbd11aeadd719c8cf9c6d501b854755 生化危机:终章未删版http://yun.zxziyuan-yun.com/share/OBIzsUaJAPryYW3n 完美的蛇颈龙之日http://yun.zxziyuan-yun.com/share/bbd529c3160b4c800103a27dd102a72a 异星怪兽之荒野求生http://yun.zxziyuan-yun.com/share/3de644286aafb7e5b26f58ec57d05d2d 第九区http://zy.kubozy-360-baidu.com/share/tW2DdbMMnYUhqfCC 智能迷失http://zy.kubozy-360-baidu.com/share/zw0UF8FZLQqBJzMJ 外星人爆发http://yun.zxziyuan-yun.com/share/94bc2d7bde46c9df3a2647a6c78144c0 来自火星的她http://zy.baidu-360-yyy-kubo.com/share/jU5Ior7nVnoGR6PR 无法磨灭http://zy.kuboy-aiqiyi-163.com/share/a62dd1eb9b15f8d11a8bf167591c2f17 决战猩球http://yun.zxziyuan-yun.com/share/9563122a75eef032c2a1681289515325 圆梦巨人http://zy.kuboy-aiqiyi-163.com/share/6e69ebbfad976d4637bb4b39de261bf7]]></content>
      <categories>
        <category>影视</category>
      </categories>
      <tags>
        <tag>电影集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[精通python爬虫框架scrapy读书笔记]]></title>
    <url>%2F2020%2F06%2F05%2F%E7%B2%BE%E9%80%9Apython%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6scrapy%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[精通python爬虫框架scrapy读书笔记一、初识Scrapy1、Scrapy能够识别残缺的HTML 可以直接使用Beautiful Soup或lxml Scrapy还提供了lxml更高级的Xpath接口——selectors 2、社区 https://groups.google.com/ forum/#!forum/scrapy-users http:// stackoverflow.com/questions/tagged/ scrapy 3、更新http://doc.scrapy.org/en/latest/news.html 二、理解HTML和XPath1、树表示法检查网页源代码——Elements——Properties 2、使用XPath选择HTML元素/html——[…] /html/body——[…] //a——会选择所有的连接 //a/@href——可以使用符号@来访问该属性 //a/text()——只选取文本 //a[@href=”https://www.iana.org/domains/example&quot;] ——选择href为这个的超链接 例子： 获取id为“firstHeading”的h1标签下span中的text 1//h1[@id=&quot;firstHeading&quot;]/span/text() 获取id为‘toc’的div标签内的无序列表ul中的所有链接的url 1//div[@id=&quot;toc&quot;]/ul//a/@href 获取class属性包含“ltr”以及class属性包含“skin-vector”的任意元素内所有标题元素（h1）中的文本。这两个字符串可能在同一个class中，也可能在不同的class中。 1//*[contains(@class,&quot;ltr&quot;) and contains(@class,&quot;skin-vector&quot;)]//h1/text() contains()函数可以让你选择包含指定类的所有元素 选择class属性值为“infobox”的表格中第一张图片的url 1//table[@class=&quot;infobox&quot;]//img[1]/@src 选择class属性以“reflist”开头的div标签中所有的url 1//div[starts-with(@class,&quot;reflist&quot;)]//a/@href 选择子元素包含文本“References”的元素之后的div元素中所有链接的URL 1//*[text()=&quot;References&quot;]/../following-sibling::div//a 获取页面中每张图片的url 1//img/@src ID通常是最可靠的 1//*[@id=&quot;more_info&quot;]//text() 在线文档 https://www.w3school.com.cn/xpath/index.asp 三、爬虫基础1、安装scrapy1pip install scrapy 2、升级scrapy 升级 1pip install --upgrade Scrapy 降级 1pip install Scrapy==1.0.0 3、scrapy调试问题，可以使用–pdb参数启动交换试，以避免发生异常1scrapy shell --pdb &quot;https//gumtree.com&quot; 4、Item 需要对爬取的数据进行清洗，来替换extract() 1response.xpath(&quot;..h1&quot;).re(&apos;&lt;h1&gt;(.*?)&lt;/h1&gt;&apos;)[-1] 说明 xpath和css都会返回选择器，只有当调用extract()或者re()方法才会得到真是的文本数组 5、一个真正的Scrapy项目 创建一个项目 1scrapy startproject properties 声明item 重新定义PropertiesItem类 1234class BilispiderItem(scrapy.Item): # define the fields for your item here like: title = scrapy.Field() pass 爬虫中引入item 123item = BilispiderItem()item[&apos;title&apos;] = response.xpath(&apos;//h1/span/text()&apos;).extract()return item 说明： ​ 我们在输出记录中看到，没有包含字段值的DEBUG了，这是因为scrapy是围绕着Item的概念构建的，可以使用管道，对其进行过滤和丰富了，并通过“Feed exports”将其以不同的格式输出存储到不同的地方。 保存文件 1scrapy crawl bili2 -o item.json 上传文件 1scrapy crawl bili2 -o &quot;ftp://user:pass@ftp.scrapybook.com/items.json&quot; ItemLoader 123l = ItemLoader(BilispiderItem(),response=response)l.add_xpath(&apos;title&apos;,&apos;//h1/span/text()&apos;)return l.load_item() 说明： ​ ItemLoader 提供了许多有趣的结合数据以及对数据进行格式化和清洗的方式。Item通过不同的处理器传递XPath/Css表达式的值。处理器是一个快速而又简单的函数。例如Join()可以将//p结合成一个条目。MapCompose()。可以使用Python函数或者函数链。例如MapCompose(float)可以将字符串数据转换为数值，而MapCompose(Unicode.strip,Unicode.title)可以删除多余空白符。等等。 ​ ItemLoader和处理器是基于编写并支持了成千上万个爬虫的人们的抓取需求而开发的工具包。 创建contract 1contract有点像为爬虫设计的单元测试。它可以快速知道哪里有运行异常。 12345&quot;&quot;&quot; This is Function parses a property page.@url http://www.bilibili.com/video/BV1K54y1972N?p=147@returns items 1@scrapes title&quot;&quot;&quot; 运行contract 1scrapy check bili2 抽取更多的url 12345start_urls = ( &apos;http://www.bilibili.com/video/BV1K54y1972N?p=147&apos;, &apos;http://www.bilibili.com/video/BV1K54y1972N?p=148&apos;, &apos;http://www.bilibili.com/video/BV1K54y1972N?p=149&apos;,) 获取文件作为url的源 1start_url = [i.strip() for i in open(&apos;todo.urls.txt&apos;).read] 获取链接地址urljoin的使用 12345678import urllibfrom urllib.parse import urljoin#获取nexturls = response.xpath(&quot;//li[@class=&apos;next&apos;]/a/@href&quot;).extract() # [&apos;/blogs?page=2&apos;]next = [urljoin(response.url,i) for i in urls] #[&apos;https://segmentfault.com/blogs?page=2&apos;]#获取网站列表urls = response.xpath(&quot;//div[@class=&apos;summary&apos;]/h2/a/@href&quot;).extract()lists = [urljoin(response.url,i) for i in urls] 编写垂直和水平双向抓取网页 123456789def parse(self,response): #Get next index URLs and yield Requests next_selector = response.xpath(&quot;//li[@class=&apos;next&apos;]/a/@href&quot;).extract() for url in next_selector: yield Request(urljoin(resoinse.url,url)) #Get item URLs and yield Requests item_selector = response.xpath(&quot;//div[@class=&apos;summary&apos;]/h2/a/@href&quot;).extract() for url in item_selector: yield Request(urljoin(resoinse.url,url),callback=self.parse_item)]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习--复习篇]]></title>
    <url>%2F2020%2F06%2F01%2FLinux%E5%AD%A6%E4%B9%A0--%E5%A4%8D%E4%B9%A0%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Linux 复习一、Linux目录结构1、目录结构管理类目录 /bin 【重点】 (/usr/bin、/usr/local/bin) 是Binary的缩写，这个目录存放最经常使用的目录 /boot 【重点】 存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 /sbin （/usr/sbin、/usr/local/sbin） s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序 /home 【重点】 存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /var【重点】 这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件。 /etc 主要存放系统配置方面的文件 /dev 类似window的设备管理器，把所有的硬件用文件的形式存储 /mnt 这个目录一般事用于存放挂在存储设备的挂载目录的，比如有cdrom等目录。可以参看/etc/fdtab的定义 用户类目录 /root 【重点】 该目录为系统管理员，也称超级权限的用户主目录 /home 存放个人数据 应用程序类目录 /lib 该目录用来存放系统动态链接共享库，几乎所有的应用程序都会用到该目录 /tmp 这个目录是用来存放一些临时文件的 /usr 存放一些不适合放在/bin或者/etc目录下的额外工具，如个人安装的程序或者工具 /usr/local 主要存放哪些手动安装的软件 /usr/bin 用于存放程序 /usr/share 用于存放一些共享数据 /usr/share 用于存放一些共享数据 /opt【重点】 这是主机额外安装软件所摆放的目录。如安装ORACLE数据库就可放到该目录下。默认为空。 信息类目录 /lost+found 在ext2或者ext3文件系统中，当系统意外崩溃或者机器意外关机，而产生一些文件碎片放在这里。但当突然断电或者非正常关机后，有些文件就临时存放在这里。 / proc 操作系统运行时，进程信息及内核信息（比如cpu、硬盘分区、内存信息等）存放在这里 其他重要目录 /etc/rc.d 放置开机和关机的脚本。 /etc/rc.d/init.d 放置启动脚本 /etc/xinetd.d 配置xinetd.conf可以配置启动其他额外服务。 /usr/include 一些distribution套件的头文件放置目录，安装程序时可能会用到。 /usr/lib* 套件的程序库 /usr/local【重点】 默认的软件安装目录。一般是通过编译源码方式安装的程序。 /usr/share/doc 系统说明文件的放置目录 /usr/share/man 程序说明文件放置目录 /usr/src 内核源代码目录 /usr/X11R6 X的存放目录 /srv service缩写，该目录存放一些服务启动后需要提取的数据 /media【重点】 Linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt 【重点】 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储改在到/mnt上，然后进入该目录就可以查看里的内容了。 /selinux[security-enhanced linux]360 SELinux是一种安全子系统，它能控制程序只能访问特定文件。 2、linux目录总结 linux的目录中有且只有一个根目录 linux的各个目录存放的内容是规划好的，不用乱放文件。 linux是以文件的形式管理我们的设备，因此linux系统，一切皆为文件。 二、常用操作命令1、vim操作命令 vim使用笔记 i 进入插入模式 v 可视模式，光标移动可以进行复制 ctrl+v 可是模式，选中整行 y 复制可视模式下选中的文字 yy or Y 复制整行文本 复制当前5行（5yy）向下粘贴（p） p 粘贴文本 d 删除可视模式下选择的文本 dd 删除整行 u 一个一个取消改变 :wq 保存退出 :wq! 强制保存退出 :set nu 显示行号 :10 跳转到第10行 三、用户操作 添加用户 useradd 1useradd wwq 给用户指定或者修改密码 1passwd wwq 删除用户 1userdel wwq 删除用户和用户主目录 1userdel -r wwq 通常不会将用户主目录删除 查询用户 1id wwq 切换用户——当前用户权限不够时 1su - root 高级别到低级别不用输入用户密码，反之需要 当需要返回原来数组的时候，exit指令]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime text3 自定义按键]]></title>
    <url>%2F2020%2F05%2F29%2Fsublime%20text3%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[sublime text3注册码12345678[ &#123; "keys": ["shift+enter"], "command": "run_macro_file", "args": &#123;"file": "res://Packages/Default/Add Line.sublime-macro"&#125; &#125;, &#123; "keys": ["ctrl+d"], "command": "duplicate_line" &#125;, &#123; "keys": ["alt+shift+up"], "command": "swap_line_up" &#125;, &#123; "keys": ["alt+shift+down"], "command": "swap_line_down" &#125;, &#123; "keys": ["ctrl+w"], "command": "find_under_expand" &#125;, ]]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我编程我快乐]]></title>
    <url>%2F2020%2F05%2F14%2F%E6%88%91%E7%BC%96%E7%A8%8B%E6%88%91%E5%BF%AB%E4%B9%90%2F</url>
    <content type="text"><![CDATA[# 一、选择市场1作为软件开发人员，用这种投机取巧的方式来编程显然不是什么好主意。但是很多人正是让偶然来决定职业道路上的各种选择。我们应该在哪种技术上投资？应该专注于哪个领域?是英国扩展知识面，还是深入学习一门学问？这些问题都是值得我们细细斟酌的。 1、稳定型还是技术型在有目的地选择投资哪种技术和领域时，风险收益平衡是一个很重要的权衡因素。 1选择是把双刃剑，决定权还是在你手机。 2、供应和需求1主流外包公司不会着手新技术，他们等技术服务市场平衡，然后再用极其廉价的编程成本打入这个市场。 1从供求规律中，我们可以学到重要的一点——需求的增长会加剧价格的竞争。 1我需要做的是了解行业中哪些高需求技术已经被使用，但是还没有流入外包市场中的技术。思考多久才能为相应市场提供服务。这个时间就是市场不平衡阶段。 3、只会编程是不够的1如果你想站稳脚跟，必须要深入了解你所处的领域 1你的行业经历应该成为你的重要才能。 1或许你是一个程序员，但是如果你能用客户所处行业的专业语言与他们交流，那这就是一项非常重要的技能。 需要在所处的行业中，沉淀下来。 1与业内人士吃饭，并了解他们如何工作的。 1看行业内杂志，了解大事件和专题 4、做团队中最差的1试图做团队最差的可以让你不再小看自己，可能你的能力应在在甲等乐团演出，但你自己确认为在乙等乐队。你清楚的知道自己不是最好的，就不会担心别人发现你不是最优秀的。而事实上，你尝试做最差的，但你并不是。 5、在思维上投资1如果在一种新的还未稳定的技术上花费时间和精力，就会显得很愚蠢。特别是如果你之前并没打算开发的技术。 1尝试去学习一门新的语言，换一种思维方式。 6、不要听从父母1出于担心的职业规划不会让你走向成功，而是会局限你的发展。没错这条路很安全，但毫无乐趣可言。 1在职业道路上，需要一些有目的性的冒险。别让恐惧征服了你。如果在工作中没有感到乐趣，那你就不可能出色的工作。 1等我老了，驾鹤西游之前，回想过去我希望我会说“上帝，这辈子真是险象环生啊！”而不是“嗯，这辈子过得还算稳稳当当。 7、做一名通才1怎么才能成为这些生意人遇到困难时首先想到的”英雄呢“？答案就是--能够解决一切可能出现的难题。 1如果你想在这个行业站稳脚跟，那我建议你要成为通才。 8、成为一名专家1已经处理过我们工作中可能遇到的80%的问题，并且拥有足够的知识来应付另外还未出现的20%的问题。不仅可以处理高水平的抽象，同时应该了解实现高端抽象的低端细节。 9、切记孤注一掷 不要把自己的职业规划放到一门特定的技术上，我们应该把他当作一门生意来做。如果说必须要一心一意投资在一项特定的技术里面的话，考虑开源项目。而不是选择商业性质的。 1你应该下载一个开源的JBoss或者Geronimo服务器，留出时间来学习这些服务器的内部是如何运转的，而不是学习如何操作。 10、热爱它，不然就离开它1如果你想在工作中做出成绩，那么就必须对工作充满激情；如果不在乎这份工作，那后果会显现出来。 1一门技术或者一个商业领域可能会使你感到兴奋；相反，或许是某一特定技术或者商业领域拖累了你。也许你更适合一个小团队或者大团队，而你处在不适合的组织里；或者是在挑选偏呆板或者偏灵活上出了差错。不管什么原因，想想自己到底适合什么。 1短时间内你可能可以伪装，但是缺少热情总会影响你和你的工作。 不要用自己的技术来定位自己，而是用我做过的或者是将要做的事情来定位自己，技术只是一种做事的方法。 二、在产品中投资 如果想要拥有一个有竞争力与众不同的产品，就必须要在这个产品中投资。商业中，有想法有天赋的人很多。只有在产品中投入心血，汗水，眼泪和资金，才能使它真正具有价值。 11、学习钓鱼 Don`t wait to be told. Ask! 12、学习行业是如何运转的 只有了解一个行业后，你才能创造性的有所建树。 1了解你公司的财务运作可以让你做出有意义的转变，而不是茫然无知地专注于某一事情，却主观的认为这样就是对的。 13、寻找良师 可以依赖别人，但要确保这个人是靠的住的。 1良师还是值得信任的朋友，他们可以观察并判断你做出的决定和取得的进步。 14、做一名良师1要想真正学点东西，就要试着向别人传授这些知识。 15、练习，练习，再练习 在极限处练习 1训练思维敏捷和提高即兴编码技术的好方法是通过自我限制的方式来练习。 书中推荐网站： Topcoder.com —— 编程竞技网站 Code Kata —— 《程序员修炼之道》Dave Thomas 创造的小练习。 16、做事的方法1一个成功的软件开发步骤。必须是由使用它的人来参与定制的。 方法论听上去很空洞，但是对软件开发本身很有帮助，即使研究你不需要做的事情。如果你很擅长软件开发，那你就拥有了一个有力的证据证明你的团队如何才能更好的工作。 1找一个能够设计出软件开发步骤的人要比做这个软件的人要难的多。 项目管理相应的网站： http://www.pmi.org —— “Project Management Book of Knowledge” http://www.isixsigma.com/ —— “六西格玛方法论” 1唯一找到项目管理与软件管理混合方法的办法是研究可用的方法论，从真正的实践中不断提炼总结。 17、站在巨人的肩膀上 从现有的程序中得到领悟——用现有程序来反思自己的程序 设计模式相应书籍的推荐: Design Patterns —— 《设计模式：可复用面上对象软件的基础》 123当你读这些程序时，你会发现某些你可能永远都不会去实践的工作，甚至你想都没想过的。他为什么这么做？他是怎么想的？即使你读到的是不怎么样的程序，通过批判的角度研究它，你也会有不获。 1当你以一种批判的角度去看这些程序时，你就会开始培养自己的品味。 18、在工作中，将自己自动化 封装一些经常使用的类库。不用考虑效率，只需要确保这个能节省时间。想办法提高生成代码的抽象等级。 研究模型驱动架构。（MAD）并在日常生活中来应用MAD概念。 三、执行1在成功的道路上，你的能力在没有得到实践之前不能带你走太远。 19、就是现在1根据帕金森定律：工作会自动膨胀到占满所有可用的时间。 随时问问自己：现在我能做些什么。 20、读心术 在与经理或者客户交流时，认真倾听分析他们说过的话。尤其是他们不经意间表达出要做的事情，即使他们自己有时候都没有意识到。将这些事情添加到代办事情中去，看看是不是可行。如果执行起来不是很困难，那就去做。 风险： 做错了怎么办？先从小事做，尽量用业余时间完成。 如果做了，会影响原有的系统，并且恢复起来很难，就不要做了。如果改变带来的影响很大，需要做商业决定了，而这并不是一个程序员能权衡的。 也许客户提出了某些改动，你按照他的要求变化了，但出乎意料的弱化了系统的功能，这并不是客户想看到的。所以在做之前一定要特别小心。 在做项目之前，要先试着做些笔记，试着记录下客户想要你做的事情。 然后在接到项目后看看自己命中了多少。 21、每日成绩1你最后一次做分外的事是什么时候？你的经理知道么？你又怎么能让他知道你做的工作呢？ 每天要有可汇报的成绩 1制定目标（每日、每周或者无论什么你能做到的）并且记录下来可以彻底改变你工作中的表现的工作内容。当你开始追寻骄人的业绩时，你自然而然地会根据你工作领域的商业价值，对你的行为做出评价，将工作花费优先顺序。 测试: 流出半小时，用一只铅笔，一张纸安静的坐在无人打扰的地方，想想哪些时一些吹毛求疵的小问题。哪些烦人的任务，确要耽误整个团队好几分钟。却没人来有精力完成，记录下来 现在的项目中哪些时可以自动完成的，确要手动完成。。。 22、别忘了你在为谁工作 确保你的目标和工作与你公司的目标一致. 1要想直接对公司业绩造成影响就像是想把大海里的水煮沸,可以把整片大海海水分解成一个一个的可以煮沸的小水坑。 1你做的事情虽小，但却是在为完成整个公司的目标出力。这就是你工作的目标，也是你工作的意义所在。 经理的成功就是你们的成功 测试： 安排一次与经理的会面，目的是了解经理对整个团队下个月，下个季度以及来年的目标。 23、安分守己1你把所有时间都花费在想要得到的某种东西，可是欲望同满足时对立的。 1比起只专注在目标上的做法，专注于现在的工作会使你离最终的目标更近。 24、今天我能把工作做到多好？1越糟糕的环境越能激发出我们最优秀的一面 1问你自己，“我今天能把工作做到多好？”你发现你会更喜欢自己的工作，你的工作也会喜欢上你。 25、你的价值是多少 如果你创造的价值是你现在工资的两倍，那你公司还是会破产。因为公司在你身上的投入不只有工资，还有保险等等福利，这些不是在工资中体现的，粗略的讲公司在你身上的投入应该为工资的两倍。记住这个数字：2倍的薪水，在达到这个目标前，千万不要放弃。 26、一桶水中的鹅卵石1一个人的离开对公司来说造成的影响非常小，即使是这个员工处在非常重要的职位，造成的影响也会非常小。 永远不要高枕无忧，也许哪天就会被公司辞掉，可能就是今天。 小心！别让成功冲昏了头脑。 1你越是成功，就越有可能犯下重大错误。当你得到很多肯定时，就会很少质疑自己的决定。你使用方法屡试不爽的时候，就可能会忽略会有更好的方法。你开始变的傲慢。人一旦傲慢，就会产生盲点。越认为自己无可替代，就越有可能被取代。 1想要让自己不可替代，就要建立一种友好的工作关系。 写代码要尽量把一些别人不容易理解的加上注释，说明，看起来更友好的代码，并分享给你的同事。 27、爱上维护 维护也可以成为自由和创造的沃土 12评估，改进，评估——在你所维护的所有重要应用程序和代码中，把所有可以评估程序质量的元素列举出来。从中选择最重要的特征，开始对它进行评估。在有了一个基本的测量准线后，确定一个可实现的目标，改进这个应用程序表现以达到这个既定目标。 28、8小时的激情燃烧1工作的时候不容一丝松懈，高度集中，以至于连续工作的时间无法超越8小时。 1当工作的时间非常宽裕的时候，工作的时间价值就会降低。 好好规划你的工作时间。减少工作时间，你的收获会更多。当你离开工作一段时间后，才会更喜欢工作。 29、学习如何失败 每个错误的音调离正确的音调不过一步之遥 发现问题，第一时间提出了，不要试图隐瞒，越早发现错误，造成的问题会越少 接受批评，即使不完全是你的问题，你也要承担责任后继续工作 提供解决方案。如果你没有想到解决的办法，就提供一份有计划性的进程。 寻求帮助。拒绝别人的帮助，只会使情况更糟糕 充满压力的时候是赢得忠诚的最好时机。 1公司对错误处理方式的不同，会产生不同的结果。问题处理得好，会使客户对其产品更加忠诚，甚至比碰到问题之前，更加信任这家公司。要是处理不好，那就摧毁了客户的信任。工作中犯错误的时候，要时刻谨记客户的这一心理。 30、说”不“ 清楚的知道自己无法做到却还依然做的承诺，最不容易实现。 1说”是“是个上瘾却具有毁灭性的习惯。”能够胜任的态度“和歪曲某人的能力有很大的不同。后者不仅给自己造成麻烦，也会给你所承受的对象制造麻烦。 1当我的团队无法完成某项工作时，有勇气说”不“，那当他们说”是“的时候我会更信任他们。 31、不要恐慌1现实生活中，不管做出怎样完美的计划，我的职业生涯还是有一连串的突发事件和灾难。 在惊慌之前克制住它，事后分析自己对问题时的反应。每天用日记记录下使你惊慌的事情，哪怕是一点点。也不要放过。每周回顾上一周的日记。分析是否值得恐慌。这样反复练习后，会发现再遇到事情，就会理智分析。 32、说出来，行动，展示1从不做出承诺最容易导致一事无成。 状态报告可以推销自己。 完成一轮计划后，与你上司讨论你的计划。一开始按照周与上司交流，你觉得适应了这个过程之后，按照30天，60天，90天时间安排，把长期计划按照提案的方式陈述给你的领导，并要求他们反馈。时间长了，你会发现哪些项目经理不会提出异议，哪些他们会提出较多异议。经理对你提出的计划也会越来越少。 1你的上司希望你具有独立性和归属感。制作计划，执行计划以及与上司就计划进行沟通，都会帮助你找到工作的独立性和归属感。 如果让我开选择两种能使我取得进步的方法，我会选择失败和模仿。 四、推销。。。不仅仅是迎合12很多软件开发人员，特别是哪些自以为是的开发人员，都认为自己的能力在同行和上司眼中是不证自明的，他们可以自然的将这个谎言掩藏于虚构的道德逻辑中：不显示自己的能力，是因为自己过于谦虚，炫耀自己的能力会像是阿谀奉承。有自尊心的程序员是不会在老板面前讨好卖乖的。事实上，这都是他们恐慌的接口。 1掩藏你的能力都是非常愚蠢的。 宣传自己有两个目标，让别人知道你的存在，以及让他们知道，当你遇到难题时，你是那个可以解决问题的人。 33、不要忽视感觉1你应该在乎别人的看法，别人对你的认识是现实，好好解决它。 1如果你知道你比哪个同事出色，那这点应该表现在你的工作表现评价，工作评分和工资中。 1当你明确地了解他人判断你的因素后，你就会更加明确如何让他们满意。 找出身边的人，分组，然后罗列出你的哪些特质会影响他们对你的感觉，根据表格做出改变。 34、探索向导 他们寻找的是可以帮助他们完成项目的人。 决定升值的人员安排的时候，你最有力的支持者就是一个无法离开你的客户。 找一个陌生的，自己知之甚少的境况。感受下你会需要队友如何与你沟通。 35、学会沟通，善于写作1写作能力不但非常必要，并且还很紧缺。 1沟通，特别是以文字的方式进行沟通，是你所有绝妙想法必须要通过的瓶颈。你就是你要解释的内容。 开始记录开发日记，每天写一点。记录你做了什么工作。解释你的设计决定，检查棘手的技术和专业决策。 36、到场1在工作中，近距离的接触是一种优势。 1通过面对面的互动，我们不仅提高了工作效率，增进了沟通，还形成了更加紧密的人际关系。 37、适当的言语 用行业术语推销你的成就。 练习： 罗列出你近期完成的工作，并写出每项工作的商业意义。 准备好你的“电梯演讲” 38、改变世界1如果你想在高消费城市里做一名软件开发师，你就必须带着任务来上班。你必须要做出变化，这种变化不只是你自身或者是你工作的改变。你所作的改变必须让你的团队、组织或者公司看到。 1如果你不知道要做的改变是什么，那你就没有在做任何改变。如果你没有主动让自己获得承认，那你就没有获得承认。 39、让人们听到你的声音1把目标放在更远一些。不要把自己局限在某一特定公司中的程序员————毕竟，你不太可能永远在一个公司里工作————因此要把你当作一个行业的人员。 第一步： 阅读网络日志。挑选几位喜欢的技术类书籍的作者，看他们的网络日志。订阅并记录。 第二部： 写自己的网络日志。要抱着你最喜欢的杂志写专栏文章的态度，撰写网络日志。随着你写作技巧增加，你也会越来越自信。 第三步：将你写的网络日志在社区网站，杂志等地发表。人际关系也会随之扩展。 练习： 创建网络日志 列出可能的网络日志话题，不要局限在宏大的观点上。尝试10到20分钟就可以写出相关文件的小想法。 40、创建自己的商标 创建商标分为两部分：认知和尊重。创立自己id商标，让他们认识它，然后确保与之关联的都是积极的特征。 你的名字就是你的商标，竭尽所能捍卫你的商标。别让自己的行为回了它的名誉。你的商标就是你的一切。 41、发布你编写的程序 如果已经有公司在使用你开发的软件了，那么找工作将是多么容易的事。 1尽管很多开发员这样做只是出于兴趣和享受过程，但诱惑因素还是存在的。他们在某个团体中扩展自己的社交圈；在为自己树立名号；在此行业中建立自己的名誉。或者这些都不是刻意为之，但是在这个过程中，他们将自己推向了市场。 42、变为卓越的能力1想要卓越，就必须和周围的人大相经庭。发布成功的开源软件，写书和撰写文章以及在研讨会上演讲都可能会提高你变得卓越的能力。 仅仅做人群中最好的是不够的。要成为人们谈论的焦点。 43、建立关系 恐惧感使我们无法接近专业人士。 1与那些聪明、人际关系好的、能教你东西或者可以帮助你找到工作的人结识，是取得进步的最好的办法，但是我们却没有胆量尝试与他们结识。 1只是解释你的难处是不够的，你应该更深的探索管理人员这样做是由哪个商业因素造成的。久而久之，你会学到更多这个商业领域的知识，也会更好的分析、判断待解决的难题。这一能力再加上你的专业技术，就会使你从一个总是说“不”的人变成一个公司管理人员不可或缺的合作伙伴。 五、保持技术领先 再自己从事的领域里面，我们需要随时保持警惕。如果你在一段时间停滞不前，就会有突然间就过时的危险。这种危险会悄然而至。给你来个措手不及。 44、已经过时的技术 今天热门的技术到明天就有可能成为过时的垃圾了。 1必须要认识到，即使你现在处于当今潮流的尖端，也及有可能已经在下个潮流之后了。时间就是一切。学习之前要先东东脑子。 1向前看，清楚的知道你的技术发展方向，是盲目和有远见之间的区别。 每周找出时间研究尖端技术。每周至少找出2个小时来研究新科技，学习技术，并尝试。 45、你已经失去工作了1你已经失去工作了，可能你每个月还是领到了薪水；可能你依然在为你的公司创造价值；可能你还是可以使你老板非常高兴。但是，你已经失去工作了。 1如果你的工作是编程，别把自己当成一名程序员。继续工作，但是不要满足与你的工作。永远不要把自己的身份定位于程序员，或者设计师，或者测试员。 有理想是好事，但不要对遥远的未来抱有太大的希望。 尝试换一种身份来完成你的工作。你会发现你的工作发生了变化。 46、没有终点的道路1你的职业生涯也是一样，最重要的部分不是晋升或者加薪，而是向这些发展方向努力工作的过程。 47、给自己做一份蓝图 我们的工作需要一份蓝图，用来判断你是否在不断发展的依据。 1每天你出入相同的办公室，从事大量的相同工作，周围环境没有任何变化。所有你需要在合理的范围内做出一些标记，当你到达这些标准的时候，你就知道你不是停滞不前的。蓝图的“功能”就是这些标记。 1尽管学些不同的技术是绝对正确的——这会拓宽你的思想，但是，想想你的技能包会向自己展示什么样的前途，没有蓝图你的前途就会结构松散，你可能会迷失方向。 练习： ​ 做出蓝图之前，罗列你所处的位置，清楚的列出你职业发展的时间表。表示出你从哪里开始，以及每个阶段你的技术和工作是什么。注意哪个阶段你在持续进步，又在哪个阶段取得了重大进步。 48、要注意观察市场变化1市场在不断的变化，稍不留意就会赔钱或者错失赚钱的机会。 1你必须时刻细心留意。注意技术方面的新闻——不管是商业上的，还是纯技术的。要留意技术达人，观察他们热衷干什么，那你就能够大致了解到什么技术将会成为热门。 49、镜子里的胖子 和体重一样，你整天面对自己，不知道自己是胖了还是瘦了，职业也是一样，并不了解自己的技术和以往一样处于尖端时代。 1找到一个可信赖的第三方，是衡量进步的简单方法。 别让过时悄悄降临到你身上，就像你的裤子突然紧身了一样。 50、南印度捉猴陷阱 当你过于坚信某事的价值时，就会无法客观的来评判它，这既是价值僵固。 51、避免瀑布型置业计划 从菜鸟——软件架构师——经理——总监，这条道路不断上升，开始觉得这条路并不是自己喜欢的。 1如果每个人在项目一开始就知道他们要做的每一个细节，那这种计划性和精确性会产生出缜密并且品质受控制的软件。但是大多情况下，人们并不知道每个细节，项目越大，就很难规范细节，这一过程就是瀑布过程。 改变职业道路。尝试敏捷开发方法，特别是极限编程。 1树立远大的目标，在实现目标的道路上，根据情况不断变化，从实践中学习，不断改变你的目标。 52、每天都有进步 即使是一点进步，你也应该感到高兴。 1如果在改善自己的道路上，美一天都比昨天做出的改变，你就会发现--拥有卓越的职业生涯——这个目标变的越容易达成，二不再像汪洋大海一样没有边际。 列出你要做的复杂困难的改善——可能是个人问题，也可以是职业问题。 53、独立 如果你可以隐藏在平庸的盾牌之后，就会丧失变得卓越的动力。 1成为一名独立的承包商还会迫使你如何推销自己，同时在你啊专注的领域中检验你的选择。你必须走出去，主动去找客户。一旦你找到了客户。你还必须要说服他们，让他们相信你的价值。 1试着跟随着自己的兴趣，看看会发生什么？结果或许会让你大吃一惊！ 结束语 软件开发极具乐趣！ 软件开发的职业道路，最重要的一点不是你以什么为生，或者你得到了什么，最中国要的是你如何接受这一切。这是一种心里活动。满足，就像我们的职业选择。是应该去追寻并且认真选择决定的。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php秒杀系统]]></title>
    <url>%2F2020%2F04%2F22%2F%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9Fphp%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[php 秒杀系统一、特点 人多商品少 时间短流量高 外挂机器 二、技术分析 瞬时高并发处理能力 多层次的分布式处理能力 人机交互与对抗 三、系统环境搭建1、 技术选型分析之基础服务 Linux+Nginx+PHP+Mysql+redis 开源，免费 大众普及 2、技术选型分析之环境搭建 CDN，智能DNS 分布式缓存，全国多节点 多线路接入 3、技术选型分析之负载均衡 负载均衡LVS 大型web集群 高效稳定 3、开发环境搭建 开发环境准备 开发工具：Eclipse for php developers/phpstrom/editplus 部署开发环境 XAMPP/macos brew安装工具/Linux yum 代码管理器 Git/SVN 4、系统环境搭建 Mysql封装类 更安全的pdo组件 封装常用的增删改查 详情参见项目代码 redis 封装类 PHP客户端：phpredis/Predis 封装基本的redis资源链接和命令 详情参见项目代码 调试封装类 封装资源类调用：mysql,redis,curl等 定制日志，调试日志等 详情参见项目代码 5、系统设置 基本功能和流程 后台 活动管理/商品管理/订单管理/日志管理 前台 商品展示/秒杀/购物车/我的订单 安全 验证码/问答]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime text3 注册码]]></title>
    <url>%2F2020%2F03%2F18%2Fsublime%20text3%20%E6%B3%A8%E5%86%8C%E7%A0%81%2F</url>
    <content type="text"><![CDATA[sublime text3注册码12345678910111213----- BEGIN LICENSE -----Member J2TeaMSingle User LicenseEA7E-1011316D7DA350E 1B8B0760 972F8B60 F3E64036B9B4E234 F356F38F 0AD1E3B7 0E9C5FADFA0A2ABE 25F65BD8 D51458E5 3923CE8087428428 79079A01 AA69F319 A1AF29A4A684C2DC 0B1583D4 19CBD290 217618CD5653E0A0 BACE3948 BB2EE45E 422D2C87DD9AF44B 99C49590 D2DBDEE1 75860FD28C8BB2AD B2ECE5A4 EFC08AF2 25A9B864------ END LICENSE ------​]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习——抽象类/接口]]></title>
    <url>%2F2020%2F01%2F25%2Fjava%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[一、抽象类1、说明 抽象类关键词 abstract 单继承 抽象方法，只有方法名，没有方法的实现 2、注意 不能new这个抽象类，只能靠子类来约束他 抽象类中可以写普通的方法 抽象方法必须在抽象类中 二、接口1、说明 接口就是规范，定义的是一组规则 接口的本质是契约，制定好后大家都遵守 OO的精髓是对象的抽象，最能体现这一点的是接口。 声明类的关键字是class 声明接口的关键字是abstract 2、作用 约束 定义一些方法，让不同的人实现 接口的方法默认都是 public abstract 接口的常量默认是public static final 接口不能被实例化，接口中没有构造方法 通过implements可以实现多个接口]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>狂神说学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习——封装/继承/重写/多态]]></title>
    <url>%2F2020%2F01%2F21%2Fjava%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E9%87%8D%E5%86%99%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[一、封装1、封装概念 高内聚，低耦合 禁止直接访问一个对象中数据的实际表示，而通过操作接口来访问，这称为隐藏信息 属性私有，get/set 2、特点 提高程序的安全性，保护数据 隐藏代码的实现细节 统一接口 系统可维护性增加了 二、继承1、基本概念 继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模 extands的意思是扩展，子类是父类的扩展 Java类中只有单继承没有多继承 Java类所有的类都直接或者间接继承object 继承是类和类之间的一种关系，除此之外类和类之间的关系还有依赖，组合，聚合等 继承关系的两个类，一个为子类（派生类）一个为父类（基类），子类继承父类，使用关键字extends来表示 子类和父类之间从意义上讲应该具有“is a”的关系 2、super 子类默认调用父类的无参构造 1super() super() 必须在第一行 调用父类的属性，方法 12345678910public void test(String name)&#123; System.out.println(name); System.out.println(this.name); System.out.println(super.name);&#125;public void test1(String name)&#123; say(); this.say(); super.say();&#125; 注意点 super调用父类的构造方法．必须在构造方法的第一个 super 必须只能出现在子类的方法或者构造方法中 super和 this不能同时调用构造方法! super与this区别 代表的对象不同 this:本身调用者这个对象 super:代表父类对象的应用 前提 this:没有继承也可以使用 super:只能在维承条件才可以使用 构造方法 this();本类的构造 super():父类的构造 三、重写1、静态方法 方法的调用和左边定义的类有关 2、非静态方法 父类的引用指向子类，子类重写的父类的方法 3、重点：需要有继承关系，子类重写父类的方法 方法名必须相同，方法体可以不同 参数列表必须相同 修饰符：子类范围可以扩大，不能缩写。public -&gt;protected-&gt;default-&gt;private 抛出异常：范围可以被缩小，不能扩大。 重现原因：父类功能不能完全满足子类的需求 四、多态1、定义： 同一方法可以根据发送对象的不同而采用多种不同的行为方式 一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多 2、注意事项 多态是方法的多态，属性没有多态 父类型和子类型转换要有联系，不能随意转换-》类型转换异常 存在条件：要有继承关系，方法需要重写，父类引用指向子类对象！ 1Father f1 = new Son(); 不能重写的方法关键字 static 方法: 属于类，它不属于实例 final : 常量 private 方法 3、instanceof（类型转换）引用类型12345Object o = new Student(); System.out.println(o instanceof Student);//true System.out.println(o instanceof Person);//true System.out.println(o instanceof Teacher);//false System.out.println(o instanceof Object);//true 4、对象转换 父类引用指向子类的对象 把子类转换成父类，向上转型 把父类转换子类，向下转型 方法调用，减少重复的代码！ 5、static 静态方法，静态属性 静态变量（类变量） 12345678910111213public class Student &#123; private static int age;//静态变量 private double score;//非静态变量 public static void main(String[] args) &#123; Student s1 = new Student(); System.out.println(Student.age); //System.out.println(Student.score);//报错 System.out.println(s1.age); System.out.println(s1.score); &#125;&#125; 静态方法可以直接调用，非静态方法需要new之后调用 123456789101112131415161718public class Student &#123; private static int age;//静态变量 private double score;//非静态变量 public void run()&#123; &#125; public static void go()&#123; &#125; public static void main(String[] args) &#123; Student s1 = new Student(); (new Student()).run(); go(); &#125;&#125; 静态代码块 12345678910111213public class Person&#123; // 匿名代码块 // 实例化时运行 &#123; System.out.println("匿名代码块"); &#125; // 静态代码块 // 创建person的时候只调用一次 static&#123; System.out.println("静态代码块"); &#125; &#125; 12345678Person p1 = new Person();Person p2 = new Person();//输出/* 静态代码块 匿名代码块 匿名代码块*/ 静态导入包 1234567import static java.lang.Math.random;public class Person &#123; public void test()&#123; System.out.println(random()); &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>狂神说学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习——面向对象]]></title>
    <url>%2F2020%2F01%2F21%2Fjava%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[1、面向对象概念 面向对象本质：以类的方式组织代码，以对象的组织封装数据 抽象 三大特性：封装，继承，多态 2、类与对象的关系 类是一种抽象的数据类型，它是对某一类事务整体描述/定义，但是并不能代表某一个具体的事物 例如人，动物 对象是抽象概念的具体实现 例如张三是人的一个具体实例，张三家旺财是狗的一个具体实例 能够体现出特点，展现出功能的是具体的实例，而不是一个抽象的概念。 3、构造器 必须和类的名字相同 必须没有返回类型也不能有void 没有返回值 作用 new 的本质在调用构造方法 初始化对象的值 注意点： 定义有参构造之后，如果想用无参构造，需要手动定义一个无参构造 快捷键 alt+insert 4、总结 类与对象 类是一个模板：抽象的，对象是一个具体的实例 方法 定义，调用 对象的引用 对象是通过引用来操作的：栈-》堆 属性：字段（Field）（成员变量） 默认初始化 修饰符 属性类型 属性名 = 属性值 对象的创建和使用 使用new 来创建对象 用.来使用 类 静态的属性 ：属性 动态的行为：方法]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>狂神说学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习]]></title>
    <url>%2F2020%2F01%2F16%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、java]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java设计模式学习]]></title>
    <url>%2F2020%2F01%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1、java设计模式内容介绍]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F01%2F03%2Fthinkphp5.1%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[一、主机的规划与磁盘分区]]></content>
  </entry>
  <entry>
    <title><![CDATA[phpstorm]]></title>
    <url>%2F2019%2F12%2F24%2Fphpstorm%E6%BF%80%E6%B4%BB%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1AHD9079DKZ-eyJsaWNlbnNlSWQiOiJBSEQ5MDc5REtaIiwibGljZW5zZWVOYW1lIjoiSmV0IEdyb3VwcyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0xMi0xNCIsInBhaWRVcFRvIjoiMjAyMC0xMi0xMyJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0xMi0xNCIsInBhaWRVcFRvIjoiMjAyMC0xMi0xMyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMTItMTQiLCJwYWlkVXBUbyI6IjIwMjAtMTItMTMifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMTItMTQiLCJwYWlkVXBUbyI6IjIwMjAtMTItMTMifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMTItMTQiLCJwYWlkVXBUbyI6IjIwMjAtMTItMTMifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMTItMTQiLCJwYWlkVXBUbyI6IjIwMjAtMTItMTMifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMTItMTQiLCJwYWlkVXBUbyI6IjIwMjAtMTItMTMifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTEyLTE0IiwicGFpZFVwVG8iOiIyMDIwLTEyLTEzIn0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTEyLTE0IiwicGFpZFVwVG8iOiIyMDIwLTEyLTEzIn0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTEyLTE0IiwicGFpZFVwVG8iOiIyMDIwLTEyLTEzIn0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTEyLTE0IiwicGFpZFVwVG8iOiIyMDIwLTEyLTEzIn0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDE5LTEyLTE0IiwicGFpZFVwVG8iOiIyMDIwLTEyLTEzIn0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTEyLTE0IiwicGFpZFVwVG8iOiIyMDIwLTEyLTEzIn0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTEyLTE0IiwicGFpZFVwVG8iOiIyMDIwLTEyLTEzIn0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTEyLTE0IiwicGFpZFVwVG8iOiIyMDIwLTEyLTEzIn0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0xMi0xNCIsInBhaWRVcFRvIjoiMjAyMC0xMi0xMyJ9XSwiaGFzaCI6IjE1ODE1MDAyLzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-LSd4oz1ZeZGTkNgA7KqUD6dmIqKNRaJEiAdpNBN3rw86DnEZm6oUoTMdM40mxRG0jz5RpLR8E6/A2uA2b9s6fX3U1dAhzuJ7HUpha2OCk9EnYGlIoxnMmYA+ZrCjlfLU2EsLMPcmKHAY5o2excxpbIqLYsNhXN3r2MxEtvGap9Y+hBxNJJYoYjV5glFIiJ/9NNAE6s1EqRRlQk2UpFg2ODDlK1JZrQTtIJvH9squs1IFz0fY9i/okXIyR4fCUbU2LUp5XbtMn3n2lKb2mEKDWjjSly3cZizAGz7obIixE1HZuEICEPWeAZiU8qc/adRt7eUYW81KFdYjLNDXcVckbw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow==]]></content>
      <tags>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 lamp环境安装]]></title>
    <url>%2F2019%2F12%2F18%2Fcentos%20lamp%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[contos7 lamp环境安装1、apache1）下载依赖包 httpd的包 Apache源码包位置：http://httpd.apache.org/ 依赖的包 apr、apr-util、pcre apr、apr-util包的位置：http://apr.apache.org/ pcre包的位置：http://pcre.org/ 2）安装（网上找的，靠谱。）安装之前先将服务器的防火墙关掉。 systemctl stop firewalld systemctl disable firewall 第一步： 安装apr 下载： wget -c http://mirrors.tuna.tsinghua.edu.cn/apache//apr/apr-1.6.3.tar.bz2 解压该文件： tar -jvxf apr-1.6.3.tar.bz2 检测： cd apr-1.6.3 ./configure –prefix=/usr/local/apr/ 编译： make make install 第二步： 安装apr-util 下载： wget -c http://mirrors.tuna.tsinghua.edu.cn/apache//apr/apr-util-1.6.1.tar.bz2 解压该文件： tar -jvxf apr-util-1.6.1.tar.bz2 检测： cd apr-util-1.6.3 ./configure –prefix=/usr/local/apr-util/ –with-apr=/usr/local/apr/ 编译： make make install 第三步： 安装pcre 下载： wget -c http://ftp.pcre.org/pub/pcre/pcre-8.42.tar.bz2 解压该文件： tar -jvxf pcre-8.42.tar.bz2 检测： cd pcre-8.42 ./configure –prefix=/usr/local/pcre/ 编译： make make install 第四步： 安装httpd 下载： wget -c http://mirrors.cnnic.cn/apache/httpd/httpd-2.4.29.tar.bz2 解压该文件： tar -jvxf httpd-2.4.29.tar.bz2 检测： cd httpd-2.4.29 ./configure –prefix=/usr/local/httpd/ –with-apr=/usr/local/apr/ –with-apr-util=/usr/local/apr-util/ –with-pcre=/usr/local/pcre/ 编译： make make install 第五步： 配置/usr/local/apache2/conf/httpd.conf ServerName www.examda.com:80 改为 ServerName localhost:80 第六步： 启动apache服务 /usr/local/apache2/bin/apachectl start 3）测试 使用浏览器访问本地IP 出现It works!成功 4）报错处理 （1）configure: error: APR not found. Please read the documentation. 这是没有安装apr或者apr安装失败导致的，重新安装apr。 安装请查看第一步。 （2）configure: error: APR-util not found. Please read the documentation. 这是没有安装apr-util或者apr-util安装失败导致的，重新安装apr-util。 安装请查看第二步。 （3）configure: error: no acceptable C compiler found in $PATH 这是没有安装gcc编译器或者gcc编译器安装失败导致的，重新安装gcc。 yum install -y gcc （4）xml/apr_xml.c:35:19: 致命错误：expat.h：没有那个文件或目录 这是没有安装expat-devel或者expat-devel安装失败导致的，重新安装expat-devel。 yum install -y expat-devel （5）configure: error: Invalid C++ compiler or C++ compiler flags 这是没有安装gcc-c++或者gcc-c++安装失败导致的，重新安装gcc-c++。 yum install -y gcc-c++ （6）configure: error: pcre-config for libpcre not found. PCRE is required and available from http://pcre.org/ 这是没有安装pcre或者pcre安装失败导致的，重新安装pcre。 安装请查看第三步。 ​ （7）make[1]: Entering directory `/deployment/apr-util-1.6.0’ ​ xml/apr_xml.c:411: error: ‘apr_xml_parser’ has no member named ‘xp’ ​ 解决办法： ​ yum install expat-devel ​ (8) rm: cannot remove ‘libtoolT’: No such file or directory ​ 解决办法 ​ 1.使用如下命令打开configure文件 ​ 2.找到RM=&#39;$RM&#39;修改为RM=&#39;$RM -f&#39; 5）设置开机启动将apache添加为开机启动有两个方法： 1、在/etc/rc.d/rc.local内加入启动命令 /usr/local/apache2/bin/apachectl start 2、将http添加为系统服务 cp /usr/local/apache2/bin/apachectl /etc/rc.d/init.d/httpd chmod +x /etc/rc.d/init.d/httpd [root@localhost ~]# chkconfig –add httpd[root@localhost ~]# chkconfig –list|grep httpdhttpd 0:关闭 1:关闭 2:关闭 3:关闭 4:关闭 5:关闭 6:关闭 [root@localhost ~]# chkconfig –level 345 httpd on[root@localhost ~]# chkconfig –list|grep httpd httpd 0:关闭 1:关闭 2:关闭 3:启用 4:启用 5:启用 6:关闭 如果出现[root@localhost ~]# chkconfig –add httpd httpd 服务不支持 chkconfig 解决过程如下： 编辑/etc/rc.d/init.d/httpd #!/bin/bash#chkconfig:345 61 61 //此行的345参数表示,在哪些运行级别启动,启动序号(S61);关闭序号(K61) #description:Apache httpd //此行必写,描述服务. 添加红色部分就可以拉！ 再[root@localhost ~]# chkconfig –add httpd[root@localhost ~]# chkconfig –list|grep httpdhttpd 0:关闭 1:关闭 2:关闭 3:关闭 4:关闭 5:关闭 6:关闭 [root@localhost ~]# chkconfig –level 345 httpd on[root@localhost ~]# chkconfig –list|grep httpdhttpd 0:关闭 1:关闭 2:关闭 3:启用 4:启用 5:启用 6:关闭 6）查看端口状态netstat -anpt|grep 80]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swoole+thinkphp从零开始打造高性能直播赛事]]></title>
    <url>%2F2019%2F11%2F20%2Fswoole%2Bthinkphp%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%93%E9%80%A0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9B%B4%E6%92%AD%E8%B5%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[swoole+thinkphp从零开始打造高性能直播赛事一、swoole简介1、简介 PHP异步网络通信引擎 最终编译为so文件作为PHP扩展 2、应用 C编写，消息队列，毫秒定时器，php的异步多线程服务器 支持长连接 移动api服务器、高性能服务器、等 3、目标 学习swoole 实战 系统优化 安装php7和swoole(源码安装) swoole基础： 网络通信引擎TCP UDP WEBSOCKET HTTP swoole进阶 异步mysql 异步redis 异步文件 异步task任务 毫秒定时器 进程、携程、内存 消息队列 实战 登录模块 赛事直播模块 聊天室模块 系统监控 系统调优 二、学习Swoole的准备工作1、linux开发环境2、php7 swoole2.1 redis3、源码安装php7 源码安装swoole4、如何学习swoole 查看文档 实现swoole特性的功能点 多看看其他现有的swoole的经典代码 三、linux环境下源码安装php1、官网下载 )php源码包 2、上传到linux服务器3、开始安装 解压 1tar -xjvf php-7.3.11.tar.bz2 configure 安装一些扩展 gcc 1yum install gcc autoconf 1yum install autoconf libxml2-devel 1yum install libxml2-devel 安装 1./configure --prefix=/var/www/php make 1make make install 1make install 测试 1[root@localhost php]# ./bin/php -m 到php的目录执行命令可以看到默认php安装的一些扩展 配置系统环境变量 1vi ~/.bash_profile 1alias php=/var/www/php/bin/php 1source ~/.bash_profile 测试 1php -v 4、安装完成后的一些坑 在源码包里，把php.ini-development复制到php的编译目录下并且改名 12cp php.ini-development /var/www/php/etcmv php.ini-development php.ini 如果修改php.ini后没有生效， 12[root@localhost etc]# php -i | grep php.iniConfiguration File (php.ini) Path =&gt; /var/www/php/lib 看出默认路径是在lib目录下面，则需要吧php.ini移动到lib目录下面 1mv ./etc/php.ini ./lib/ 四、swoole源码安装1、官网下载源码 github下载zip或者git直接下载到soft目录 2、编译安装swoole 准备 安装gcc库 1yum install gcc-c++ swoole目录下生成configure–利用php工具phpize 1/var/www/php/bin/phpize 根据php配置文件编译安装 123./configure --with-php-config=/var/www/php/bin/php-configmakemake install 在php相应目录生成swoole.so文件则编译安装成功 3、php 支持swoole 修改php.ini文件–添加如下代码 1extension=swoole 测试——看是否有swoole扩展 1php -m 去swoole安装目录执行——/opt/soft/swoole-src/examples/server 1php echo.php 新开窗口查看9501端口是否监听——如下则成功 1netstat -anp | grep 9501 查看swoole版本 1php --ri swoole 五、swoole服务器介绍–tcp服务1、tcp服务12345678910111213141516171819202122232425262728&lt;?php//创建Server对象，监听 127.0.0.1:9501端口$serv = new Swoole\Server("127.0.0.1", 9501);$serv-&gt;set([ 'worker_num' =&gt; 4, //worker process num 'max_request' =&gt; 50,]);//监听连接进入事件/* * $fd: 客户端链接的唯一标识 * $reactor_id: 线程id */$serv-&gt;on('Connect', function ($serv, $fd, $reactor_id) &#123; echo "Client: &#123;$reactor_id&#125;-&#123;$fd&#125;-Connect.\n";&#125;);//监听数据接收事件$serv-&gt;on('Receive', function ($serv, $fd, $from_id, $data) &#123; $serv-&gt;send($fd, "Server: &#123;$from_id&#125;--&#123;$fd&#125;--&#123;$data&#125;".$data);&#125;);//监听连接关闭事件$serv-&gt;on('Close', function ($serv, $fd) &#123; echo "Client: &#123;$fd&#125;Close.\n";&#125;);//启动服务器$serv-&gt;start(); 2、client php链接tcp服务123456789101112131415&lt;?php//链接swoole tcp 服务$cilent = new swoole_client(SWOOLE_SOCK_TCP);if(!$cilent-&gt;connect('127.0.0.1',9501))&#123; echo '链接失败'; exit;&#125;;//php 内置cli产量fwrite(STDOUT,'请输入消息');$msg = trim(fgets(STDIN));//发送消息给tcp server$cilent-&gt;send($msg);//接受来自server的数据$result = $cilent-&gt;recv();echo $result; 3、判断tcp有几个进程1ps aft | grep tcp.php 六、swoole服务器–http1、http服务12345678&lt;?phpuse Swoole\Http\Server;$http = new Server("0.0.0.0", 8800);$http-&gt;on('request', function ($request, $response) &#123; $response-&gt;end("&lt;h1&gt;Hello Swoole. #".rand(1000, 9999)"&lt;/h1&gt;");&#125;);$http-&gt;start(); 2、获取get参数 关键代码 12$array = $request-&gt;get;$get = json_encode($request-&gt;get); 示例 12345678910&lt;?phpuse Swoole\Http\Server;$http = new Server("0.0.0.0", 8800);$http-&gt;on('request', function ($request, $response) &#123; $array = $request-&gt;get; $get = json_encode($request-&gt;get); $response-&gt;end("&lt;h1&gt;Hello Swoole. #".rand(1000, 9999).$get."&lt;/h1&gt;");&#125;);$http-&gt;start(); 3、保存cookie 关键代码 1$response-&gt;cookie('wwq','scccc',time()+1800); 实例 123456789101112&lt;?phpuse Swoole\Http\Server;$http = new Server("0.0.0.0", 8800);$http-&gt;on('request', function ($request, $response) &#123;// print_r($request-&gt;get); $array = $request-&gt;get; $get = json_encode($request-&gt;get); $response-&gt;cookie('wwq','scccc',time()+1800); $response-&gt;end("&lt;h1&gt;Hello Swoole. #".rand(1000, 9999).$get."&lt;/h1&gt;");&#125;);$http-&gt;start(); 4、开启swoole静态资源访问 关键代码 1234$http-&gt;set([ 'enable_static_handler' =&gt; true, 'document_root' =&gt; '/var/www/my_swoole/data', // v4.4.0以下版本, 此处必须为绝对路径]); 实例 1234567891011121314151617&lt;?phpuse Swoole\Http\Server;$http = new Server("0.0.0.0", 8811);$http-&gt;set([ 'enable_static_handler' =&gt; true, 'document_root' =&gt; '/var/www/my_swoole/data', // v4.4.0以下版本, 此处必须为绝对路径]);$http-&gt;on('request', function ($request, $response) &#123;// print_r($request-&gt;get); $array = $request-&gt;get; $get = json_encode($request-&gt;get); $response-&gt;cookie('wwq','scccc',time()+1800); $response-&gt;end("&lt;h1&gt;Hello Swoole. #".rand(1000, 9999).$get."&lt;/h1&gt;");&#125;);$http-&gt;start(); 七、swoole服务–websocket WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工（full-duplex）通信——允许服务器主动发送信息给客户端。 为什么需要websocket 缺陷：http的通信只能由客户端发起 websocket特点 建立在TCP协议之上 性能开销小通信高效 客户端可以与任意服务器通信 协议标识符ws wss 持久化网络通信协议 1、WebSocket服务 服务端——ws_server.php 12345678910111213141516171819202122&lt;?php$server = new Swoole\WebSocket\Server("0.0.0.0", 8812);$server-&gt;set([ 'enable_static_handler' =&gt; true, 'document_root' =&gt; '/var/www/my_swoole/data', // v4.4.0以下版本, 此处必须为绝对路径]);//监听websocket链接打开事件$server-&gt;on('open', 'onOpen');function onOpen($server,$request)&#123; print_r($request-&gt;fd);&#125;//监听websocket消息事件$server-&gt;on('message', function (Swoole\WebSocket\Server $server, $frame) &#123; echo "receive from &#123;$frame-&gt;fd&#125;:&#123;$frame-&gt;data&#125;,opcode:&#123;$frame-&gt;opcode&#125;,fin:&#123;$frame-&gt;finish&#125;\n"; $server-&gt;push($frame-&gt;fd, "wwq - push - success!");&#125;);$server-&gt;on('close', function ($ser, $fd) &#123; echo "client &#123;$fd&#125; closed\n";&#125;);$server-&gt;start(); 用户——ws_client.html 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="zh-cn"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;ws_client&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;wwq ws server&lt;/h1&gt;&lt;script&gt;var wsUrl = "ws://192.168.72.4:8812";var webSocket = new WebSocket(wsUrl);webSocket.onopen = new WebSocket(wsUrl);//实例对象的onopen属性webSocket.onopen = function (evt) &#123; webSocket.send('hello wwq'); console.log('content-swoole-success');&#125;//实例化onmwssagewebSocket.onmessage = function (evt) &#123; console.log('ws-server-return-data:'+evt.data);&#125;//onclosewebSocket.onclose = function (evt) &#123; console.log('close');&#125;//onerrorwebSocket.onerror = function (evt) &#123; console.log('error:'+evt.data);&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结果 2、服务优化 ws.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?php/** * ws优化 * User: 30no2 * Date: 2019/11/26 * Time: 16:56 */class Ws&#123; CONST HOST = "0.0.0.0"; CONST PORT = '8812'; public $ws = null; public function __construct()&#123; $this-&gt;ws = new swoole_websocket_server("0.0.0.0",self::PORT); $this-&gt;ws-&gt;on("open",[$this,'onOpen']); $this-&gt;ws-&gt;on("message",[$this,'onMessage']); $this-&gt;ws-&gt;on("close",[$this,'onClose']); $this-&gt;ws-&gt;start(); &#125; /** * 监听ws连接事件 * User: 30no2 * Date: 2019/11/26 * Time: 17:01 */ public function onOpen($ws,$request)&#123; var_dump($request-&gt;fd); &#125; /** * 监听ws消息事件 * User: 30no2 * Date: 2019/11/26 * Time: 17:01 */ public function onMessage($ws,$frame)&#123; echo "ser-push-message:&#123;$frame-&gt;data&#125;\n"; $ws-&gt;push($frame-&gt;fd,"server-push:".date('Y-m-d H:i:s')); &#125; /** * ws关闭事件 * User: 30no2 * Date: 2019/11/26 * Time: 17:06 */ public function onClose($ws,$fd)&#123; echo "clientid:&#123;$fd&#125;\n"; &#125; &#125;$obj = new Ws(); 结果 八、task任务 使用场景——执行耗时的操作（发送邮件，广播等） 1、修改wx.php——增加task任务12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?php/** * ws优化 * User: 30no2 * Date: 2019/11/26 * Time: 16:56 */class Ws&#123; CONST HOST = "0.0.0.0"; CONST PORT = '8812'; public $ws = null; public function __construct()&#123; $this-&gt;ws = new swoole_websocket_server("0.0.0.0",self::PORT); //新增 $this-&gt;ws-&gt;set([ 'worker_num'=&gt;2, 'task_worker_num'=&gt;2 ]); $this-&gt;ws-&gt;on("open",[$this,'onOpen']); $this-&gt;ws-&gt;on("message",[$this,'onMessage']); $this-&gt;ws-&gt;on("task",[$this,'onTask']);//新增 $this-&gt;ws-&gt;on("finish",[$this,'onFinish']);//新增 $this-&gt;ws-&gt;on("close",[$this,'onClose']); $this-&gt;ws-&gt;start(); &#125; /** * 监听ws连接事件 * User: 30no2 * Date: 2019/11/26 * Time: 17:01 */ public function onOpen($ws,$request)&#123; var_dump($request-&gt;fd); &#125; /** * 监听ws消息事件 * User: 30no2 * Date: 2019/11/26 * Time: 17:01 */ public function onMessage($ws,$frame)&#123; echo "ser-push-message:&#123;$frame-&gt;data&#125;\n"; //todo 10s//新增 $data = [ 'task'=&gt;1, 'fd'=&gt;$frame-&gt;fd ]; $ws-&gt;task($data); $ws-&gt;push($frame-&gt;fd,"server-push:".date('Y-m-d H:i:s')); &#125; /** * task任务//新增 * @param $serv * @param $taskId * @param $workerId * @param $data * @return string */ public function onTask($serv, $taskId, $workerId, $data)&#123; print_r($data); //耗时场景10秒 sleep(10); return "on task finish";//告诉worker进程 &#125; /** * finish任务//新增 * @param $serv * @param $taskId * @param $data: task进程return的内容 */ public function onFinish($serv, $taskId, $data)&#123; echo "taskId:&#123;$taskId&#125;\n"; echo "finish-data-sucess：&#123;$data&#125;\n"; &#125; /** * ws关闭事件 * User: 30no2 * Date: 2019/11/26 * Time: 17:06 */ public function onClose($ws,$fd)&#123; echo "clientid:&#123;$fd&#125;\n"; &#125;&#125;$obj = new Ws(); 2、结果 九、swoole 定时器 swoole_timer_tick——每间隔一段时间执行某个函数等 swoole_timer_after——几秒/几分钟后执行某个函数等 1、增加定时功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;?php/** * ws优化 * User: 30no2 * Date: 2019/11/26 * Time: 16:56 */class Ws&#123; CONST HOST = "0.0.0.0"; CONST PORT = '8812'; public $ws = null; public function __construct()&#123; $this-&gt;ws = new swoole_websocket_server("0.0.0.0",self::PORT); $this-&gt;ws-&gt;set([ 'worker_num'=&gt;2, 'task_worker_num'=&gt;2 ]); $this-&gt;ws-&gt;on("open",[$this,'onOpen']); $this-&gt;ws-&gt;on("message",[$this,'onMessage']); $this-&gt;ws-&gt;on("task",[$this,'onTask']); $this-&gt;ws-&gt;on("finish",[$this,'onFinish']); $this-&gt;ws-&gt;on("close",[$this,'onClose']); $this-&gt;ws-&gt;start(); &#125; /** * 监听ws连接事件 * User: 30no2 * Date: 2019/11/26 * Time: 17:01 */ public function onOpen($ws,$request)&#123; var_dump($request-&gt;fd); //每两秒执行//新增 if($request-&gt;fd == 1)&#123; swoole_timer_tick(2000,function ($timer_id)&#123; echo "2s:timerId:&#123;$timer_id&#125;\n"; &#125;); &#125; &#125; /** * 监听ws消息事件 * User: 30no2 * Date: 2019/11/26 * Time: 17:01 */ public function onMessage($ws,$frame)&#123; echo "ser-push-message:&#123;$frame-&gt;data&#125;\n"; //todo 10s $data = [ 'task'=&gt;1, 'fd'=&gt;$frame-&gt;fd ];// $ws-&gt;task($data); //新增 swoole_timer_after(5000,function () use($ws,$frame)&#123; echo "5s-after:\n"; $ws-&gt;push($frame-&gt;fd,"server-time-after"); &#125;); $ws-&gt;push($frame-&gt;fd,"server-push:".date('Y-m-d H:i:s')); &#125; /** * task任务 * @param $serv * @param $taskId * @param $workerId * @param $data * @return string */ public function onTask($serv, $taskId, $workerId, $data)&#123; print_r($data); //耗时场景10秒 sleep(10); return "on task finish";//告诉worker进程 &#125; /** * finish任务 * @param $serv * @param $taskId * @param $data: task进程return的内容 */ public function onFinish($serv, $taskId, $data)&#123; echo "taskId:&#123;$taskId&#125;\n"; echo "finish-data-sucess：&#123;$data&#125;\n"; &#125; /** * ws关闭事件 * User: 30no2 * Date: 2019/11/26 * Time: 17:06 */ public function onClose($ws,$fd)&#123; echo "clientid:&#123;$fd&#125;\n"; &#125;&#125;$obj = new Ws(); 2、结果 十、linux 安装mysql并且网络上的安装教程也非常多，但是对于新手来说，各种不同形式的安装教程，又给新手们带来了要选择哪种方式进行安装的难题，而且很多时候按照教程也没有能够安装成功，安装过程出现各种各样的错误。 下面记录了我在Linux环境下安装Mysql的完整过程，如有错误或遗漏，欢迎指正。 （一） 安装前准备1、检查是否已经安装过mysql，执行命令1[root@localhost /]# rpm -qa | grep mysql 从执行结果，可以看出我们已经安装了mysql-libs-5.1.73-5.el6_6.x86_64，执行删除命令 1[root@localhost /]# rpm -e --nodeps mysql-libs-5.1.73-5.el6_6.x86_64 再次执行查询命令，查看是否删除 1[root@localhost /]# rpm -qa | grep mysql 2、查询所有Mysql对应的文件夹12345[root@localhost /]# whereis mysqlmysql: /usr/bin/mysql /usr/include/mysql[root@localhost lib]# find / -name mysql/data/mysql/data/mysql/mysql 删除相关目录或文件 1[root@localhost /]# rm -rf /usr/bin/mysql /usr/include/mysql /data/mysql /data/mysql/mysql 验证是否删除完毕 1234[root@localhost /]# whereis mysqlmysql:[root@localhost /]# find / -name mysql[root@localhost /]# 3、检查mysql用户组和用户是否存在，如果没有，则创建12345[root@localhost /]# cat /etc/group | grep mysql[root@localhost /]# cat /etc/passwd |grep mysql[root@localhost /]# groupadd mysql[root@localhost /]# useradd -r -g mysql mysql[root@localhost /]# 4、从官网下载是用于Linux的Mysql安装包下载命令： 1[root@localhost /]# wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.24-linux-glibc2.12-x86_64.tar.gz 也可以直接到mysql官网选择其他版本进行下载。 （二）安装Mysql1、在执行wget命令的目录下或你的上传目录下找到Mysql安装包：mysql-5.7.24-linux-glibc2.12-x86_64.tar.gz 执行解压命令： 1234[root@localhost /]# tar -xzvf mysql-5.7.28-linux-glibc2.12-x86_64.tar.gz[root@localhost /]# lsmysql-5.7.28-linux-glibc2.12-x86_64mysql-5.7.28-linux-glibc2.12-x86_64.tar.gz 解压完成后，可以看到当前目录下多了一个解压文件，移动该文件到/usr/local/mysql 执行移动命令： 1[root@localhost /]# mv mysql-5.7.28-linux-glibc2.12-x86_64 /usr/local/mysql 2、在/usr/local/mysql目录下创建data目录1[root@localhost /]# mkdir /usr/local/mysql/data 3、更改mysql目录下所有的目录及文件夹所属的用户组和用户，以及权限12[root@localhost /]# chown -R mysql:mysql /usr/local/mysql[root@localhost /]# chmod -R 755 /usr/local/mysql 4、编译安装并初始化mysql,务必记住初始化输出日志末尾的密码（数据库管理员临时密码）12[root@localhost /]# cd /usr/local/mysql/bin[root@localhost bin]# ./mysqld --initialize --user=mysql --datadir=/usr/local/mysql/data --basedir=/usr/local/mysql 补充说明：\ 此时可能会出现错误： 出现该问题首先检查该链接库文件有没有安装使用 命令进行核查 12[root@localhost bin]# rpm -qa|grep libaio [root@localhost bin]# 运行命令后发现系统中无该链接库文件 1[root@localhost bin]# yum install libaio-devel.x86_64 安装成功后，继续运行数据库的初始化命令，此时可能会出现如下错误： 执行如下命令后，再次运行数据库的初始化命令： 1[root@localhost bin]# yum -y install numactl 5、运行初始化命令成功后，输出日志如下： 记录日志最末尾位置root@localhost:后的字符串，此字符串为mysql管理员临时登录密码。 6、编辑配置文件my.cnf，添加配置如下1234567891011[root@localhost bin]# vi /etc/my.cnf[mysqld]datadir=/usr/local/mysql/dataport = 3306sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLESsymbolic-links=0max_connections=400innodb_file_per_table=1#表名大小写不明感，敏感为lower_case_table_names=1 7、启动mysql服务器1[root@localhost /]# /usr/local/mysql/support-files/mysql.server start 显示如下结果，说明数据库安装成功 如果出现如下提示信息 1Starting MySQL... ERROR! The server quit without updating PID file 查看是否存在mysql和mysqld的服务，如果存在，则结束进程，再重新执行启动命令 123456789#查询服务ps -ef|grep mysqlps -ef|grep mysqld#结束进程kill -9 PID#启动服务 /usr/local/mysql/support-files/mysql.server start 8、添加软连接，并重启mysql服务123[root@localhost /]# ln -s /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql [root@localhost /]# ln -s /usr/local/mysql/bin/mysql /usr/bin/mysql[root@localhost /]# service mysql restart 9、登录mysql，修改密码(密码为步骤5生成的临时密码)123[root@localhost /]# mysql -u root -pEnter password:mysql&gt;set password for root@localhost = password('yourpass'); 10、开放远程连接123mysql&gt;use mysql;msyql&gt;update user set user.Host='%' where user.User='root';mysql&gt;flush privileges; 11、设置开机自动启动123456781、将服务文件拷贝到init.d下，并重命名为mysql[root@localhost /]# cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld2、赋予可执行权限[root@localhost /]# chmod +x /etc/init.d/mysqld3、添加服务[root@localhost /]# chkconfig --add mysqld4、显示服务列表[root@localhost /]# chkconfig --list 十一、异步redis——服务安装 redis 服务 hiredis库 编译swoole 需要加入——enable-async-redis 1、编译安装redis 官网下载源码包 解压缩 ​ tar -zxvf redis-5.0.7.tar.gz 进入redis目录 12makemake install 测试——表示成功 1redis-server 2、新版本的redis不再支持异步redis——推荐使用携程 4.2.6版本及以后不再需要手动安装和启用async-redis, 而是swoole自带 需要安装一个第三方的异步Redis库hiredis 123sudo makesudo make installsudo ldconfig v4.3.0以后不再需要添加编译参数, 内置了此依赖 需要在编译时增加--enable-async-redis来开启此功能 请勿同时使用异步回调和协程Redis 1) 代码示例123$redis = new Swoole\Coroutine\Redis();$redis-&gt;connect('127.0.0.1', 6379);$val = $redis-&gt;get('key'); 2）defer特性1234567891011121314151617181920const REDIS_SERVER_HOST = '127.0.0.1';const REDIS_SERVER_PORT = 6379;go(function () &#123; $redis = new Swoole\Coroutine\Redis(); $redis-&gt;connect(REDIS_SERVER_HOST, REDIS_SERVER_PORT); $redis-&gt;setDefer(); $redis-&gt;set('key1', 'value'); $redis2 = new Swoole\Coroutine\Redis(); $redis2-&gt;connect(REDIS_SERVER_HOST, REDIS_SERVER_PORT); $redis2-&gt;setDefer(); $redis2-&gt;get('key1'); $result1 = $redis-&gt;recv(); $result2 = $redis2-&gt;recv(); var_dump($result1, $result2);&#125;); 3、设定开机启动1）创建存储redis文件目录1mkdir -p /usr/local/redis 2）进入src目录，复制redis-server redis-cli到新建立的文件夹12cp ./redis-server /usr/local/redis/cp ./redis-cli /usr/local/redis/ 3）复制redis的配置文件12cd ..cp redis.conf /usr/local/redis/ 4）编辑配置文件12cd /usr/local/redis/vim redis.conf 改为yes 后台运行 5）添加开机启动服务1vim /etc/systemd/system/redis-server.service 12345678910111213 1 [Unit] 2 Description=The redis-server Process Manager 3 After=syslog.target network.target 4 5 [Service] 6 Type=simple 7 PIDFile=/var/run/redis_6379.pid 8 ExecStart=/usr/local/redis/redis-server /usr/local/redis/redis.conf 9 ExecReload=/bin/kill -USR2 $MAINPID10 ExecStop=/bin/kill -SIGINT $MAINPID11 12 [Install]13 WantedBy=multi-user.target 6）设置开机启动1231 systemctl daemon-reload2 systemctl start redis-server.service3 systemctl enable redis-server.service 7）检查是否安装成功 8）创建redis命令软连接1ln -s /usr/local/redis/redis-cli /usr/bin/redis 9）测试redis 完成安装！ 10）如果不成功12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455561.编写配置脚本 [** vim /etc/init.d/redis** ]#!/bin/sh# chkconfig: 2345 10 90# Simple Redis init.d script conceived to work on Linux systems# as it does use of the /proc filesystem.REDISPORT=6379EXEC=/usr/local/redis/redis-server #redis-server路径CLIEXEC=/usr/local/redis/redis-cli #redis-cli路径PIDFILE=/var/run/redis_$&#123;REDISPORT&#125;.pid #redis_$&#123;REDISPORT&#125;.pid路径CONF=&quot;/usr/local/redis/redis.conf&quot; #redis.conf路径AUTH=&quot;School1502&quot; #redis 密码case &quot;$1&quot; instart)if [ -f $PIDFILE ]thenecho &quot;$PIDFILE exists, process is already running or crashed&quot;elseecho &quot;Starting Redis server...&quot;$EXEC $CONFfi;;stop)if [ ! -f $PIDFILE ]thenecho &quot;$PIDFILE does not exist, process is not running&quot;elsePID=$(cat $PIDFILE)echo &quot;Stopping ...&quot;$CLIEXEC -p $REDISPORT shutdownwhile [ -x /proc/$&#123;PID&#125; ]doecho &quot;Waiting for Redis to shutdown ...&quot;sleep 1doneecho &quot;Redis stopped&quot;fi;;*)echo &quot;Please use start or stop as first argument&quot;;;esac2.修改redis.conf,打开后台运行选项daemonize yes3.修改文件执行权限chmod +x /etc/init.d/redis4.设置开机启动# 尝试启动或停止 redisservice redis startservice redis stop# 开启服务自启动chkconfig redis on5.reboot 11）如果还是不行的话123456789101112131415161718192021222324252627282930313233343536373839404142434445461. 解压缩tar -zxf redis-5.0.7.tar.gz2.移动到/usr/local/ (个人爱好)mv redis-5.0.7 /usr/localcd /usr/localmv redis-5.0.7/ rediscd redis/srcmakemake install3.到usr/local/redis目录下mkdir etcmkdir bin4.进入src目录mv mkreleasehdr.sh redis-benchmark redis-check-aof redis-check-rdb redis-cli redis-server /usr/local/redis/bin/5.启动rediscd /usr/local/redis/bin/redis-server6.修改redis.confcd etc/vim redis.confdaemonize no 改成daemonize yes7.再次启动redis并且指定服务配置文件redis-server /usr/local/redis/etc/redis.conf————————————————————上面的事情做完后#新建目录mkdir /etc/redis #移动配置文件并重命名 名字必须是 6379 和配置文件里一致（下面的配置文件不改，所以这里就必须写成6379）mv redis.conf /etc/redis/6379.conffind / -name redis_init_script#复制、移动文件并重命名cp redis_init_script /etc/init.d/redis#修改脚本vim /etc/init.d/redis 在首行注释!bin/sh下面添加如下两行注释：# chkconfig: 2345 10 90 # description: Start and Stop redis #修改redis服务路径，改成你自己的路径（上面说的把四个文件复制到一个目录里的那个路径）EXEC=/usr/local/redis/redis-serverCLIEXEC=/usr/local/redis/redis-cli 1234567#设置开机启动chkconfig redis on#然后可以使用命令 来开启或者关闭redis了service redis start/stopps -ef | grep redis /usr/local/redis/redis-cli//vi ~/.bash_profile 1source ~/.bash_profile 1234567891011121314151617# 将 Redis 注册成为服务[root@localhost init.d]# chkconfig --add redis 注意： 如果报 reids不支持chkconfig 错误 解决方案： vim /ect/init.d/redis 按i,进入编辑模式 在文档头部添加#chkconfig：2345 80 90 如： # chkconfig: 2345 90 10# description: Redis is a persistent key-value database保存后： 输入 [root@localhost init.d]# chkconfig --add redis kill redis || kill -9 0000 //停止redis//重启ps -ef | grep redis 12）关键由于我之前安装过redis配置了开机启动。后来就一直不成功 123find / -name redis-serverrm -rf /etc/systemd/system/multi-user.target.wants/redis.servicerm -rf /usr/lib/systemd/system/redis.service 终于成功了！ 十二、进程 进程就是正在运行的程序的一个实例 1、process.php123456789&lt;?php$process = new swoole_process(function (swoole_process $pro)&#123; //todo $pro-&gt;exec('/var/php/bin/php',[__DIR__.'/../server/http_server.php']);&#125;,true);$pid = $process-&gt;start();echo $pid.PHP_EOL;swoole_process::wait(); 2、查看进程数1yum install psmisc 1php process.php 1pstree -p 1753 1ps aft | grep http_server 3、使用场景 curl.php 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpecho "process_start_time".date('Ymd H:i:s').PHP_EOL;$workers = [];$urls = [ 'http://www.baidu.com', 'http://www.qq.com', 'https://www.baidu.com/s?wd=11', 'https://www.baidu.com/s?wd=22', 'https://www.baidu.com/s?wd=33', 'https://www.baidu.com/s?wd=44', 'https://www.baidu.com/s?wd=55',];//foreach ($urls as $url)&#123;// $content[] = file_put_contents($url);//&#125;for ($i=0;$i&lt;6;$i++)&#123; //子进程 $process = new swoole_process(function (swoole_process $worker) use($i,$urls)&#123; //curl $connect = curlData($urls[$i]); echo $connect.PHP_EOL; &#125;,true); $pid = $process-&gt;start(); $workers[$pid] = $process;&#125;foreach ($workers as $process)&#123; echo $process-&gt;read();&#125;/** * 模拟请求url内容 * User: 30no2 * Date: 2019/12/3 * Time: 17:22 */function curlData($url)&#123; sleep(1); return $url.'success'.PHP_EOL.'&lt;br/&gt;';&#125;echo "process_end_time".date('Ymd H:i:s').PHP_EOL; 结果 十三、swoole内存 lock buffer table atomic mmap channel serialize 1、swoole table swoole_table是一个基于共享内存和锁实现的超高性能，并发数据结构 1）table.php12345678910111213141516&lt;?php//创建内存表$table = new swoole_table(1024);//内存表增加一列$table-&gt;column('id',$table::TYPE_INT,8);$table-&gt;column('name',$table::TYPE_STRING,255);$table-&gt;column('age',$table::TYPE_INT,6);$table-&gt;create();$table-&gt;set('wwq_test',[ 'id'=&gt;1, 'name'=&gt;'wwq', 'age'=&gt;35,]);print_r($table-&gt;get('wwq_test')); 2）结果 3）一些基本操作12345678910111213141516171819202122232425&lt;?php//创建内存表$table = new swoole_table(1024);//内存表增加一列$table-&gt;column('id',$table::TYPE_INT,8);$table-&gt;column('name',$table::TYPE_STRING,255);$table-&gt;column('age',$table::TYPE_INT,6);$table-&gt;create();$table-&gt;set('wwq_test',[ 'id'=&gt;1, 'name'=&gt;'wwq', 'age'=&gt;35,]);$table['wwq_test2'] = [ 'id'=&gt;2, 'name'=&gt;'wwq2', 'age'=&gt;36,];//$table-&gt;incr('wwq_test2','age',3);//加操作$table-&gt;decr('wwq_test2','age',3);//减操作print_r($table['wwq_test2']);print_r('del starting....');$table-&gt;del('wwq_test2');//删除操作print_r($table['wwq_test2']); 十四、swoole 携程 swoole 携程只能在回调函数中使用。 1、coroutine redis.php123456789101112131415&lt;?php$http = new swoole_http_server('0.0.0.0',8001);$http-&gt;on('request',function ($request,$response)&#123; //redis $redis = new Swoole\Coroutine\Redis(); $redis-&gt;connect('127.0.0.1',6379); $value = $redis-&gt;get($request-&gt;get['a']); //mysql....等等 //总用时为以上逻辑用时的最大值 $response-&gt;header("Content-Type","text/plain"); $response-&gt;end($value);&#125;);$http-&gt;start(); 2、结果 十五、swoole 实战1、知识点 框架——thinkphp5.1 swoole特性使用 赛事直播平台 nginx负载均衡 redis 系统监控+性能优化]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swoole学习笔记]]></title>
    <url>%2F2019%2F11%2F18%2Fswoole%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[swoole学习笔记一、linux安装swoole环境1、安装php扩展1yum install php php-pear php-devel httpd gcc 2、安装swoole1pecl install swoole 3、修改php.ini1extension=swoole.so 4、说明如果安装了宝塔面板，可以在php版本扩展中找到swoole的扩展，一键安装 二、swoole服务搭建1、TCP连接123456789101112131415161718192021222324252627282930313233343536&lt;?php//TCP$host = '0.0.0.0';$port = 9501;// $model = SWOOLE_PROCESS； //多进程// $sock_type = SWOOLE_SOCK_TCP;//// $serv = new swoole_server($host,$port,$mode,$sock_type);$serv = new swoole_server($host,$port);/** $host = 127.0.0.1 本地ip* 192.168.72.2* 0.0.0.0* ipv4/ipv6* $port = 端口号* 1024端口以下需要root* 9501* //使用* bool $swoole_server-&gt;on(string $envent,mixed $callback);* $event;* connect:当建立连接的时候 $serv:服务器信息 $fd客户端信息* receive:当接受到数据 $serv:服务器信息 $fd:客户端信息$from_id:Id。$data:数据* close:关闭链接*/$serv-&gt;on('connect',function ($serv,$fd)&#123;//var_dump($serv);//var_dump($fd);echo '建立连接成功';&#125;);$serv-&gt;on('receive',function ($serv,$fd,$from_id,$data)&#123;echo '接收到数据';var_dump($data);&#125;);$serv-&gt;on('close',function ()&#123;echo '连接关闭';&#125;);$serv-&gt;start();//启动服务 2、UDP连接12345678910111213141516&lt;?php//UDP$host = '0.0.0.0';$port = 9502;$serv = new swoole_server($host,$port,SWOOLE_PROCESS,SWOOLE_SOCK_UDP);/* * $serv: 服务器信息 * $data: 数据，接受到的数据 * $fd: 客户端信息 */$serv-&gt;on('packet',function ($serv,$data,$fd)&#123; //发送数据到相应的客户端，反馈信息 $serv-&gt;sendto($fd['address'],$fd['port'],"server: $data"); var_dump($fd);&#125;);$serv-&gt;start();//启动服务 3、http12345678910111213141516&lt;?php//HTTP$host = &apos;0.0.0.0&apos;;$port = 9501;$serv = new swoole_http_server($host, $port);/* * $request:请求信息，get post * $response:返回信息 */$serv-&gt;on(&apos;request&apos;, function ($request, $response) &#123; //发送数据到相应的客户端，反馈信息 var_dump($request); $response-&gt;header(&quot;Content-type&quot;, &quot;text/html;charset=utf-8&quot;);//设置返回头信息 $response-&gt;end(&quot;hello world&quot; . rand(100, 999));&#125;);$serv-&gt;start();//启动服务 4、websocket new swoole_websocket_server() //实例化websocket swoole_websocket_server //继承自swoole_http_server on/start函数 open/message/close 建立连接/获取信息/关掉链接 push()发送数据//发送信息给客户端 1234567891011121314151617181920&lt;?php//websocket//创建websocket服务器$ws = new swoole_websocket_server("0.0.0.0",9501);//on//open 建立连接 $ws 服务器 $request:客户端信息$ws-&gt;on('open',function ($ws,$request)&#123; var_dump($request); $ws-&gt;push($request-&gt;fd,"welcome \n");&#125;);//message 接受信息$ws-&gt;on('message',function ($ws,$request)&#123; echo 'message: '.$request-&gt;data; $ws-&gt;push($request-&gt;fd,"get it message");&#125;);//close 关闭连接$ws-&gt;on('close',function ($ws,$request)&#123; echo 'close \n';&#125;);$ws-&gt;start(); 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;websocket&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; // webSocket用户端 var wsServer = "ws://192.168.72.2:9501"; var webSocket = new WebSocket(wsServer); webSocket.onopen = function (evt) &#123; console.log('链接成功'); &#125; webSocket.onclose = function (evt) &#123; console.log('关闭'); &#125; webSocket.onmessage = function (evt) &#123; console.log(evt.data); &#125; webSocket.onerror = function (evt,e) &#123; console.log('error'); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5、测试工具NetAssist 三、]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git log 详解]]></title>
    <url>%2F2019%2F11%2F15%2Fgit-log-%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[git log 详解​ git log 可以让我们查看提交commit history,接下来我们来一起探索git log提供的参数。 123456789101112131415161718192021222324$ git logcommit 584f5efe98641504ff422068783ae12683801a22 (HEAD -&gt; master, origin/master, origin/HEAD)Author: mr-9 &lt;1421122102@qq.com&gt;Date: Fri Nov 15 10:20:44 2019 +0800 swoole学习笔记第三天commit 73254660421e7a237152299cb3c7fea913d604f3Author: mr-9 &lt;1421122102@qq.com&gt;Date: Tue Oct 29 09:31:57 2019 +0800 新增电影commit acb429bfbc98803aeac030938c59c9baa8d18940Author: mr-9 &lt;1421122102@qq.com&gt;Date: Tue Oct 29 09:24:24 2019 +0800 影视链接更新commit c7fa89d84c5796959aa8942e9c704d6eb2e69911Author: mr-9 &lt;1421122102@qq.com&gt;Date: Thu Oct 10 23:00:45 2019 +0800 禁忌女孩电视剧 git log默认会输出commit hash, author, date, commit message. 1 –oneline 这个命令简化git log的默认的输出，仅仅输出commit hash 前7个字符串和commit message. 12345678$ git log --oneline584f5ef (HEAD -&gt; master, origin/master, origin/HEAD) swoole学习笔记第三天7325466 新增电影acb429b 影视链接更新c7fa89d 禁忌女孩电视剧07e2ee7 python学习0d02e63 python学习f3ce343 人民的名义电视剧改1 2 –stat --stat:是在git log 的基础上输出文件增删改的统计数据。 123456789101112131415161718$ git log --statcommit 584f5efe98641504ff422068783ae12683801a22 (HEAD -&gt; master, origin/master, origin/HEAD)Author: mr-9 &lt;1421122102@qq.com&gt;Date: Fri Nov 15 10:20:44 2019 +0800 swoole学习笔记第三天 source/_posts/swoole学习笔记.md | 345 ++++++++++++++++++++++++++++++++++++ 1 file changed, 345 insertions(+)commit 73254660421e7a237152299cb3c7fea913d604f3Author: mr-9 &lt;1421122102@qq.com&gt;Date: Tue Oct 29 09:31:57 2019 +0800 新增电影 source/_posts/攀登者.md | 11 +++++++++++ 1 file changed, 11 insertions(+) 3 -p -p:控制输出每个commit具体修改的内容，输出的形式以diff的形式给出。 1234567891011121314151617181920212223242526272829$ git log -pcommit 584f5efe98641504ff422068783ae12683801a22 (HEAD -&gt; master, origin/master, origin/HEAD)Author: mr-9 &lt;1421122102@qq.com&gt;Date: Fri Nov 15 10:20:44 2019 +0800 swoole学习笔记第三天diff --git a/source/_posts/swoole学习笔记.md b/source/_posts/swoole学习笔记.mdnew file mode 100644index 0000000..559740f--- /dev/null+++ b/source/_posts/swoole学习笔记.md@@ -0,0 +1,345 @@+---+title: swoole学习笔记+date: 2019-11-13+tags: php+categories: 学习+---++# swoole++## 一、设计思路++### 1. 设计分析++- 用户：量大，正常用户，恶意用户（数据清洗）+- 地区：全国范围内各地区都要访问到（cdn加速）+- 业务流程：前台（用户能看 4 –git show git show命令同git log -p输出类似，只不过它只显示一个commit的内容，如果不指定commit hash, 它默认输出HEAD指向commit的内容. 12345678910111213141516171819202122232425$ git showcommit 584f5efe98641504ff422068783ae12683801a22 (HEAD -&gt; master, origin/master, origin/HEAD)Author: mr-9 &lt;1421122102@qq.com&gt;Date: Fri Nov 15 10:20:44 2019 +0800 swoole学习笔记第三天diff --git a/source/_posts/swoole学习笔记.md b/source/_posts/swoole学习笔记.mdnew file mode 100644index 0000000..559740f--- /dev/null+++ b/source/_posts/swoole学习笔记.md@@ -0,0 +1,345 @@+---+title: swoole学习笔记+date: 2019-11-13+tags: php+categories: 学习+---++# swoole++## 一、设计思路++### 1. 设计分析 5 git shortlog 这个命令用来输出汇总信息，以作者进行分类。 123456789101112131415161718192021222324$ git shortlog30no2 (5): 新加一条测试用的日记 删了一条测试用的日记 添加about remove .idea 修改名称mr-9 (52): my first private hexo 11 修改git地址 添加日记 修改title 修改title 修改aboutme 添加常用函数文件 markdown注册吗 markdown注册吗 新增phpstorm快捷键文章 q linux 学习 linux 学习 linux 学习 git shortlog -s：可以用来统计每个作者的commit数量 git shortlog -n：可以用来对统计的量进行倒序排列 6 –gretty 我们可以用–pretty来自定义输出的信息 1234$ git log --pretty=&quot;%cn committed %h on $cd&quot;mr-9 committed 584f5ef onmr-9 committed 7325466 onmr-9 committed acb429b on 7 –author 加--author用来过滤commit,限定输出给定的用户 123456789101112$ git log --author=&quot;mr-9&quot;commit 584f5efe98641504ff422068783ae12683801a22 (HEAD -&gt; master, origin/master, origin/HEAD)Author: mr-9 &lt;1421122102@qq.com&gt;Date: Fri Nov 15 10:20:44 2019 +0800 swoole学习笔记第三天commit 73254660421e7a237152299cb3c7fea913d604f3Author: mr-9 &lt;1421122102@qq.com&gt;Date: Tue Oct 29 09:31:57 2019 +0800 新增电影 8 -n输出log数量 123456789101112$ git log -2commit 584f5efe98641504ff422068783ae12683801a22 (HEAD -&gt; master, origin/master, origin/HEAD)Author: mr-9 &lt;1421122102@qq.com&gt;Date: Fri Nov 15 10:20:44 2019 +0800 swoole学习笔记第三天commit 73254660421e7a237152299cb3c7fea913d604f3Author: mr-9 &lt;1421122102@qq.com&gt;Date: Tue Oct 29 09:31:57 2019 +0800 新增电影 9 –after和–before限定指定日期范围的log 123456789101112$ git log --after &apos;10-1-2019&apos;commit 584f5efe98641504ff422068783ae12683801a22 (HEAD -&gt; master, origin/master, origin/HEAD)Author: mr-9 &lt;1421122102@qq.com&gt;Date: Fri Nov 15 10:20:44 2019 +0800 swoole学习笔记第三天commit 73254660421e7a237152299cb3c7fea913d604f3Author: mr-9 &lt;1421122102@qq.com&gt;Date: Tue Oct 29 09:31:57 2019 +0800 新增电影 10 –merges和–no-merges控制是否显示merge的commit 123456789101112$ git log --no-mergescommit 584f5efe98641504ff422068783ae12683801a22 (HEAD -&gt; master, origin/master, origin/HEAD)Author: mr-9 &lt;1421122102@qq.com&gt;Date: Fri Nov 15 10:20:44 2019 +0800 swoole学习笔记第三天commit 73254660421e7a237152299cb3c7fea913d604f3Author: mr-9 &lt;1421122102@qq.com&gt;Date: Tue Oct 29 09:31:57 2019 +0800 新增电影 11 –decoreate 该参数用来控制log输出时，显示对应commit所属的branch和tag信息 123456789$ git log --decorate --oneline584f5ef (HEAD -&gt; master, origin/master, origin/HEAD) swoole学习笔记第三天7325466 新增电影acb429b 影视链接更新c7fa89d 禁忌女孩电视剧07e2ee7 python学习0d02e63 python学习f3ce343 人民的名义电视剧改1de5e578 人民的名义电视剧]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[千万级秒杀项目实战]]></title>
    <url>%2F2019%2F11%2F13%2F%E5%8D%83%E4%B8%87%E7%BA%A7%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[千万级秒杀项目实战一、设计思路1. 设计分析 用户：量大，正常用户，恶意用户（数据清洗） 地区：全国范围内各地区都要访问到（cdn加速） 业务流程：前台（用户能看到的部分）后台（商家或者管理者使用） 2. 设计分层 第一层：商品展示层（负责对应商品的展示） 第二层：用户登记层（用户登记相关信息，秒杀准备） 第三次：数据接入（将用户的信息接入到数据库或者处理层） 第四层：数据处理层（接入层数据没有问题，存入处理层） 3. 导图 二、代码分析1. 秒杀第一层（展示页面）1）页面优化 页面 图片 css js 压缩 2）cnd网络加速 阿里云cdn(推荐)–oss开放存储 解决全国各地访问不均衡的问题 内容刷新 3）隐藏跳转页面（重点） 修改页面信息 修改js 修改页面 双页面 展示页面 倒计时 1、用服务器时间（推荐设置成东9区） 2、考虑网络传输耗时（不是很明显，但是需要考虑） 3、获取时间可以冲ajax响应头中获取（通过getResponsetHeader(“Date”)来获取，服务器不需要写时间生成脚本） 倒计时实现方案 1、原则：尽量减少服务器请求 2、处理方式 刷新就获取服务器时间，然后自己累加 获取服务器时间 js实现递减效果 购买页面 12345678//第一步--删除文件$file_path = 'a.txt';$f = file_exists($file_path)&amp;&amp;unlink($file_path);//第二部--生成自己需要的文件$file_path = 'b.html';$myfile = fopen($file_path,'w');$txt = "&lt;h1&gt;大家好&lt;/h1&gt;";fwrite($myfile,$txt); 4）端口/最大连接数 关闭没用的端口 最大连接数设置 内存 cpu 默认150个设置512个 5）电脑性能监控 cpu 内存 网络 硬盘 版本推荐 php7 apache2.4 推荐理由 新品 缺点：很多扩展不全 服务器配置 1、选择unbuntu 14.04 2、安装ssh 3、apt-get update 4、tasksel install lmap-server 6）特点 应对高并发/高可用(主要cnd–阿里是6台机器回源，所有我们只要抗住6台机器请求就可以了) 7）构想 展示状态 三种 秒杀等待倒计时页面 秒杀进行中、秒杀按钮可用状态 秒杀结束提示页面 技术难点 秒杀等待页面与秒杀按钮可用状态页面，切换的时候，不至于让秒杀登记的地址提前曝光！ 方案：用linux定时任务crontab 执行shell脚本，进行文件的替换 高并发/高可用 技术关键点 高可用 双活 云解析（推荐+负载均衡） 高并发 负载均衡 cdn加速 单台调优 最大连接数 可靠性能 结合当前页面的思考 页面特点 纯静态：html标签/css属性/js 如果是纯静态：高并发–cnd加速 8）具体实施 页面 1.商品展示页 2.商品秒杀进行中 3.秒杀结束 知识点 切换 1-2切换 a. linux cron定时任务 b. shell脚本知识 2-3切换 .php文件 秒杀倒计时 js实现 服务器部署 2.秒杀第二层（用户登记）1）目的 登记用户信息 简单的小白过滤 肉鸡方案 控制多台计算机同时抢 ajax数据发送 手机号/验证码之类 2）知识点 静态页面/服务器（同第一层） 简单的数据验证 ajax跨域 3）代码实现3.秒杀数据接入层1）任务 数据校验 存入队列 检测订单商品数量 2）知识点 数据校验 ajax跨域安全 数据源验证 类似token数据校验 加密算法（类似序列号） 队列 why——高并发流浪数据插入 排队 微观角度 —— 其实从硬件IP可以排序！单一排序 linux底层驱动，也是从缓存池中，获取数据 去重 如何选择 多次任务存储 队列 链表 数组 堆栈 nosql memcache 简单 php控制逻辑+memcache控制数据 redis php引擎 PRdies：纯php完成 phpredis：c扩展 命令选择 列表 ——无自动去重 集合 快速 随机无序 有序集合 过期时间 mysql —— 消息队列插件 代码实现 test_redis.php 本地 阿里 效果展示——流程演示 类封装——兼容本地以及远程的类封装 最终效果封装——基于阿里 商品数量检测 关键点： redis封装 序列号生成 4.秒杀第四层1）数据处理 任务——转存nosql数据到mysql 知识点——无 三、具体代码实现1.第一层代码实现1）关键点： 倒计时： css——背景图足够大，将倒计时固定 js 倒计时js 根据剩余秒数显示时间 1234567891011121314151617function getNewSyTime(sec)&#123; var s = sec % 60; sec = (sec - s)/60;//min var m - sec % 60; sec = (sec - m)/60;//hour var h = sec % 24; var d = (sec - h) / 24;//day var syTimeStr = ""; if(d &gt; 0)&#123; syTimeStr += d.toString() + "天"; &#125; syTimeStr = ("0"+h.toString()).substr(-2)+"时" +("0"+m.toString()).substr(-2)+"分" +("0"+s.toString()).substr(-2)+"秒; return syTimeStr; &#125; - 秒杀结束替换脚本 1. 秒杀替换脚本 1234#!/user/bin/env bashdate&gt;&gt;/root/456.txtrm -rf &apos;/alidata/www/deault/index.html&apos;cp &apos;/alidata/www/deault/index_sale.html&apos; &apos;/alidata/www/deault/index.html&apos; 2. 服务器定时任务 10 12 * * * root /bin/51miao.sh 3. php代码实现 12345678910//第一步删除文件$file_path = 'index.html';$f = file_exists($file_path)&amp;&amp;unlink($file_path);//第二步：生成自己需要的文件$file_path = 'index.html';$myfile = fopen($file_path,"w");//获取文件内容$file_path = 'index_over.html';$txt = file_get_contents(file_path);fwrite($myfile,$txt); 2.第二层1）js 对用户名手机号进行判断——value值 value值序列号加密 正则手机号判断 jsonp发送后台验证通过，则登记记录 3.第三层 php 创建token 检验token 给1，2，4层发送通知 redis插入数值 插入数值 flag+1 安全过滤 4.第四层 redis获取数据插入到mysql中 四、演示]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[攀登者]]></title>
    <url>%2F2019%2F10%2F29%2F%E6%94%80%E7%99%BB%E8%80%85%2F</url>
    <content type="text"><![CDATA[攀登者HD高清 http://www.7639616.com/hls/20191008/4214743b9ab30abb805e113d2eca511d/1570523585/index.m3u8 HD高清 http://qiaozhen.com.cn/share/MjY2MDc2JEhE6auY5riF]]></content>
      <categories>
        <category>影视</category>
      </categories>
      <tags>
        <tag>攀登者</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F10%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[python学习--头部解析]]></title>
    <url>%2F2019%2F10%2F10%2Fpython%E5%AD%A6%E4%B9%A0--%E5%A4%B4%E9%83%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[python 头部解析 参数 说明 Accept 表示浏览器可接受的MIME类型 Accept-Encoding 表示浏览器能够进行的编码方式 Accept-Language 表示浏览器的语言种类 Cache-Control 表示控制网页的缓存 Connection 表示是否可以处理持久的链接 Cookie 将cookies返回到服务器 Host 初始化url的主机和端口 Upgrade-Insecure-Requests: 通知服务器可以处理https协议 User-Agent 用于识别浏览器的类型]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[禁忌女孩]]></title>
    <url>%2F2019%2F10%2F10%2F%E7%A6%81%E5%BF%8C%E5%A5%B3%E5%AD%A9%2F</url>
    <content type="text"><![CDATA[第1集 http://cn3.download05.com/hls/20190624/a3a02dddc849682e6c8de889548cac43/1561348123/index.m3u8 第2集 http://cn3.download05.com/hls/20190624/aadff48273e8eb36b3b8a2eb708f006d/1561350356/index.m3u8 第3集 http://cn3.download05.com/hls/20190624/498ef016fd2fc232a178369d45469548/1561350801/index.m3u8 第4集 http://cn3.download05.com/hls/20190624/08683106a7b6b69c91610f30e77b1307/1561351300/index.m3u8 第5集 http://cn3.download05.com/hls/20190624/bbafc0d27eafae9e2a3008ef9a708980/1561351815/index.m3u8 第6集 http://cn3.download05.com/hls/20190624/04070b1e83cf393160d5ce8832ac96aa/1561352270/index.m3u8 第7集 http://cn3.download05.com/hls/20190624/8736c5e8b1efc971785a3c00caedeb6d/1561352723/index.m3u8 第8集 http://cn3.download05.com/hls/20190624/cb316c076770e241ad6f7e5bbf1a6264/1561353169/index.m3u8 第9集 http://cn3.download05.com/hls/20190624/47d5b7382149c74152ec6df0bb9fe24e/1561353595/index.m3u8 第10集 http://cn3.download05.com/hls/20190624/481af83ca176bc96dd86dd6389481d34/1561348599/index.m3u8 第11集 http://cn3.download05.com/hls/20190624/fcdcb97b2923845e8400520ec8d2e66b/1561349031/index.m3u8 第12集 http://cn3.download05.com/hls/20190624/281f0b075ed476da70bb5767ee05f5d8/1561349484/index.m3u8 第13集 http://cn3.download05.com/hls/20190624/87ede760c2171df20a1de975649203d3/1561349949/index.m3u8 第1集 http://qiaozhen.com.cn/share/MTk1NDMzJOesrDHpm4Y= 第2集 http://qiaozhen.com.cn/share/MTk1NDMzJOesrDLpm4Y= 第3集 http://qiaozhen.com.cn/share/MTk1NDMzJOesrDPpm4Y= 第4集 http://qiaozhen.com.cn/share/MTk1NDMzJOesrDTpm4Y= 第5集 http://qiaozhen.com.cn/share/MTk1NDMzJOesrDXpm4Y= 第6集 http://qiaozhen.com.cn/share/MTk1NDMzJOesrDbpm4Y= 第7集 http://qiaozhen.com.cn/share/MTk1NDMzJOesrDfpm4Y= 第8集 http://qiaozhen.com.cn/share/MTk1NDMzJOesrDjpm4Y= 第9集 http://qiaozhen.com.cn/share/MTk1NDMzJOesrDnpm4Y= 第10集 http://qiaozhen.com.cn/share/MTk1NDMzJOesrDEw6ZuG 第11集 http://qiaozhen.com.cn/share/MTk1NDMzJOesrDEx6ZuG 第12集 http://qiaozhen.com.cn/share/MTk1NDMzJOesrDEy6ZuG 第13集 http://qiaozhen.com.cn/share/MTk1NDMzJOesrDEz6ZuG]]></content>
      <categories>
        <category>影视</category>
      </categories>
      <tags>
        <tag>电视剧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习--翻译]]></title>
    <url>%2F2019%2F10%2F08%2Fpython%E5%AD%A6%E4%B9%A0--%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[python 翻译（学习for循环）12345678910111213141516171819letter = &#123; "hello" : "你好", "world" : "世界", "python" : "PYTHON"&#125;def mytranslate(phrase): translatetion = '' for ii in phrase.split(): if ii in letter: for index in letter: if ii ==index: translatetion = translatetion + letter[index]+" " else: translatetion = translatetion + ii+" " return translatetionprint(mytranslate("hello python I am Mr.w"))//你好 PYTHON I am Mr.w]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人民的名义]]></title>
    <url>%2F2019%2F09%2F30%2F%E4%BA%BA%E6%B0%91%E7%9A%84%E5%90%8D%E4%B9%89%2F</url>
    <content type="text"><![CDATA[人民的名义bjyun第1集 https://v2.szjal.cn/share/5BFFCL6LhvcJlSPn 第2集 https://v2.szjal.cn/share/cBAnWk9z2mZl1BLM 第3集 https://v2.szjal.cn/share/GyaFKw9QmIdXptEI 第4集 https://v2.szjal.cn/share/4MAm3pMCCprSvvTS 第5集 https://v2.szjal.cn/share/WWxrpKk2axNtMC7b 第6集 https://v2.szjal.cn/share/yrK7NdzNxiyhsGr0 第7集 https://v2.szjal.cn/share/sfZ0iaf9KIsomy7s 第8集 https://v2.szjal.cn/share/aKX2YmTItmFFlr7C 第9集 https://v2.szjal.cn/share/Ji00kySiZ6gpNg5w 第10集 https://v2.szjal.cn/share/X0TxDpALSuBL9TCd 第11集 https://v2.szjal.cn/share/Fuq7WrpbDhYLiiOY 第12集 https://v2.szjal.cn/share/CsE8sXn259kR0b57 第13集 https://v2.szjal.cn/share/4xGWU6EA5KnNMJ7q 第14集 https://v2.szjal.cn/share/43xeB1PDvJeZutAA 第15集 https://v2.szjal.cn/share/irlzGIwEQjYtUnDF 第16集 https://v2.szjal.cn/share/T8vwRoDHU6cbQfuk 第17集 https://v2.szjal.cn/share/voWIlVF3NpvFj1Gx 第18集 https://v2.szjal.cn/share/qMmAEfxWwbm1bnuC 第19集 https://v2.szjal.cn/share/pGBeRJXenq78Y9T4 第20集 https://v2.szjal.cn/share/BEx9djDqKfDMw0w1 第21集 https://v2.szjal.cn/share/MzudHEbRGKn9Va6p 第22集 https://v2.szjal.cn/share/LprV8q39UOw30oO5 第23集 https://v2.szjal.cn/share/4FB9TjwNpisoazVV 第24集 https://v2.szjal.cn/share/o47z4cI9Uc0a09X5 第25集 https://v2.szjal.cn/share/biQxOnTaSd8Bdexn 第26集 https://v2.szjal.cn/share/1EbZQKjCAcDgm5tf 第27集 https://v2.szjal.cn/share/afOiUHpOVGGB7Wg8 第28集 https://v2.szjal.cn/share/eYf3IhjCQNdPEFj9 第29集 https://v2.szjal.cn/share/E46OSIyqj3N6Zz0X 第30集 https://v2.szjal.cn/share/b19JirmvhPVrrsD3 第31集 https://v2.szjal.cn/share/gsA7McF9Td4u9wGf 第32集 https://v2.szjal.cn/share/KATutZOJJv11lPxd 第33集 https://v2.szjal.cn/share/cmYIXN62KhaYeCNJ 第34集 https://v2.szjal.cn/share/uxbpdNhcUpAiDT97 第35集 https://v2.szjal.cn/share/AHLzYHULQuVvc3yk 第36集 https://v2.szjal.cn/share/0YNiz2P1SrPOtytv 第37集 https://v2.szjal.cn/share/fqZWYAhA7RS5v8jg 第38集 https://v2.szjal.cn/share/atDeKmIb3YhC4kPF 第39集 https://v2.szjal.cn/share/OqNYWBBlbOY15z6G 第40集 https://v2.szjal.cn/share/9ToZDg0wgGNIoTUV 第41集 https://v2.szjal.cn/share/pUQSlB3dqxMVRGGv 第42集 https://v2.szjal.cn/share/Ey0zqWOSiDS7ss23 第43集 https://v2.szjal.cn/share/rKbSofS56I8n6m6T 第44集 https://v2.szjal.cn/share/iv6PGaIxavwndWs6 第45集 https://v2.szjal.cn/share/N0AzREmU2f5x3Hm4 第46集 https://v2.szjal.cn/share/9RnJvHE0e0sN3dD5 第47集 https://v2.szjal.cn/share/Ic3u45VFyqewIZB0 第48集 https://v2.szjal.cn/share/mZ9SjxZLhtsywNcA 第49集 https://v2.szjal.cn/share/8lebEPFKWLy6XBiZ 第50集 https://v2.szjal.cn/share/VvRDpt0h7WQqoWsz 第51集 https://v1.szjal.cn/share/kQDTBpqZNY4P5vYy 第52集 https://v1.szjal.cn/share/1zmk90R5LI2hSB4v 第53集 https://v1.szjal.cn/share/SzzD4SXth1ia2qXA 第54集 https://v1.szjal.cn/share/htAE0SxksJOoZosN 第55集 https://v1.szjal.cn/share/GEF49rk97pDyXjhi bjm3u8第1集 https://v2.szjal.cn/20190718/cWPM48ml/index.m3u8 第2集 https://v2.szjal.cn/20190718/5zFsMZJY/index.m3u8 第3集 https://v2.szjal.cn/20190718/XqpoQUgm/index.m3u8 第4集 https://v2.szjal.cn/20190718/xeJBvtsf/index.m3u8 第5集 https://v2.szjal.cn/20190718/v758ii2q/index.m3u8 第6集 https://v2.szjal.cn/20190718/DVTVihyr/index.m3u8 第7集 https://v2.szjal.cn/20190718/M6hznCzl/index.m3u8 第8集 https://v2.szjal.cn/20190718/3xBUmevB/index.m3u8 第9集 https://v2.szjal.cn/20190718/CU5nXG7S/index.m3u8 第10集 https://v2.szjal.cn/20190718/jvH29jfK/index.m3u8 第11集 https://v2.szjal.cn/20190718/tmxjStye/index.m3u8 第12集 https://v2.szjal.cn/20190718/MsZLLj1A/index.m3u8 第13集 https://v2.szjal.cn/20190718/dNRVSYqP/index.m3u8 第14集 https://v2.szjal.cn/20190718/6BrQAR7f/index.m3u8 第15集 https://v2.szjal.cn/20190718/i6MWmaay/index.m3u8 第16集 https://v2.szjal.cn/20190718/dwWo2UEZ/index.m3u8 第17集 https://v2.szjal.cn/20190718/bkewM9i8/index.m3u8 第18集 https://v2.szjal.cn/20190718/8RsgqHQL/index.m3u8 第19集 https://v2.szjal.cn/20190718/J4PAEDaZ/index.m3u8 第20集 https://v2.szjal.cn/20190718/o8EVdXkB/index.m3u8 第21集 https://v2.szjal.cn/20190718/QdAN6roK/index.m3u8 第22集 https://v2.szjal.cn/20190718/Isgjlkis/index.m3u8 第23集 https://v2.szjal.cn/20190718/iubOvBh0/index.m3u8 第24集 https://v2.szjal.cn/20190718/w4InhT3H/index.m3u8 第25集 https://v2.szjal.cn/20190718/WzJiQXCg/index.m3u8 第26集 https://v2.szjal.cn/20190718/MDZantxT/index.m3u8 第27集 https://v2.szjal.cn/20190718/4RsuwKcx/index.m3u8 第28集 https://v2.szjal.cn/20190718/kZEjs42v/index.m3u8 第29集 https://v2.szjal.cn/20190718/JgAG4J2d/index.m3u8 第30集 https://v2.szjal.cn/20190718/WFJSJcWm/index.m3u8 第31集 https://v2.szjal.cn/20190718/IHAzBVWB/index.m3u8 第32集 https://v2.szjal.cn/20190718/FnwujJu2/index.m3u8 第33集 https://v2.szjal.cn/20190718/r6ATwqlz/index.m3u8 第34集 https://v2.szjal.cn/20190718/yQxj9odp/index.m3u8 第35集 https://v2.szjal.cn/20190718/oNixraWK/index.m3u8 第36集 https://v2.szjal.cn/20190718/8nNVb5F7/index.m3u8 第37集 https://v2.szjal.cn/20190718/V9S8kKtX/index.m3u8 第38集 https://v2.szjal.cn/20190718/5vHzinp5/index.m3u8 第39集 https://v2.szjal.cn/20190718/EqfyJCUy/index.m3u8 第40集 https://v2.szjal.cn/20190718/o3sAM3q2/index.m3u8 第41集 https://v2.szjal.cn/20190718/gJUW7QyW/index.m3u8 第42集 https://v2.szjal.cn/20190718/B0ToQl2n/index.m3u8 第43集 https://v2.szjal.cn/20190718/E3CUOX6k/index.m3u8 第44集 https://v2.szjal.cn/20190718/ClKimIPt/index.m3u8 第45集 https://v2.szjal.cn/20190718/uq9gxA1f/index.m3u8 第46集 https://v2.szjal.cn/20190718/8Cj1HJpV/index.m3u8 第47集 https://v2.szjal.cn/20190718/LFA6tNih/index.m3u8 第48集 https://v2.szjal.cn/20190718/dYReblCO/index.m3u8 第49集 https://v2.szjal.cn/20190718/rYjCjDBA/index.m3u8 第50集 https://v2.szjal.cn/20190718/dAZR6NCJ/index.m3u8 第51集 https://v1.szjal.cn/20190718/as0NhAQx/index.m3u8 第52集 https://v1.szjal.cn/20190718/Ho4b1x0f/index.m3u8 第53集 https://v1.szjal.cn/20190718/eqcSUkwh/index.m3u8 第54集 https://v1.szjal.cn/20190718/AvCgXnKr/index.m3u8 第55集 https://v1.szjal.cn/20190718/IjtWzEZ7/index.m3u8]]></content>
      <categories>
        <category>影视</category>
      </categories>
      <tags>
        <tag>人民的名义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python编译器pytharm激活码到2020年]]></title>
    <url>%2F2019%2F09%2F28%2Fpytharm%E6%BF%80%E6%B4%BB%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1K6IXATEF43-eyJsaWNlbnNlSWQiOiJLNklYQVRFRjQzIiwibGljZW5zZWVOYW1lIjoi5o6I5p2D5Luj55CG5ZWGOiBodHRwOi8vaWRlYS5oay5jbiIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0wNi0wNSIsInBhaWRVcFRvIjoiMjAyMC0wNi0wNCJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0wNi0wNSIsInBhaWRVcFRvIjoiMjAyMC0wNi0wNCJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDYtMDUiLCJwYWlkVXBUbyI6IjIwMjAtMDYtMDQifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDYtMDUiLCJwYWlkVXBUbyI6IjIwMjAtMDYtMDQifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDYtMDUiLCJwYWlkVXBUbyI6IjIwMjAtMDYtMDQifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDYtMDUiLCJwYWlkVXBUbyI6IjIwMjAtMDYtMDQifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDYtMDUiLCJwYWlkVXBUbyI6IjIwMjAtMDYtMDQifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA2LTA1IiwicGFpZFVwVG8iOiIyMDIwLTA2LTA0In0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA2LTA1IiwicGFpZFVwVG8iOiIyMDIwLTA2LTA0In0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA2LTA1IiwicGFpZFVwVG8iOiIyMDIwLTA2LTA0In0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA2LTA1IiwicGFpZFVwVG8iOiIyMDIwLTA2LTA0In0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA2LTA1IiwicGFpZFVwVG8iOiIyMDIwLTA2LTA0In0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA2LTA1IiwicGFpZFVwVG8iOiIyMDIwLTA2LTA0In0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA2LTA1IiwicGFpZFVwVG8iOiIyMDIwLTA2LTA0In0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA2LTA1IiwicGFpZFVwVG8iOiIyMDIwLTA2LTA0In0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0wNi0wNSIsInBhaWRVcFRvIjoiMjAyMC0wNi0wNCJ9XSwiaGFzaCI6IjEzMjkyMzQwLzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-f8GvMiFGxAImRG8KKudyJDmZkDYD5fQiMOSFnBEMuAkeHjkq3rcj19hqQ1OS9nLCO4RvhRMINgYtKi3jVeZADAf6HKMnzDisWECB7ms8EgZoWOzTdKi3vw2pCpck5k6U6RXJmFlebIIbjA/KrzlPCPt9BfMZQ9NN5OdXDYXN9ZCvgG3vt5S0ZShPDNMQllSJt8OSerE1daj+nOP8f6WiUpgrYkHwydzF/NBlejdjvkMZp3iCk+ylKhYW5OgfnChCwWEyEmmIaNj4xYyeL3WMLqHm82Uo3bQnKkUU8eO0WOmJPfO2NGrVIeM5SEl1iu8odKX4fes5u+duTRCKjbDLAg==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow==]]></content>
      <tags>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpbase64图片转码]]></title>
    <url>%2F2019%2F09%2F27%2Fphpbase64%E5%9B%BE%E7%89%87%E8%BD%AC%E7%A0%81%2F</url>
    <content type="text"><![CDATA[phpBase64图片转换1234567891011121314151617181920212223242526272829303132public function testBase64() &#123; $img = "http://pic13.nipic.com/20110409/7119492_114440620000_2.jpg"; $imageInfo = getimagesize($img); //不带头的base64编码 $base64 = "" . chunk_split(base64_encode(file_get_contents($img))); //带头的base64编码 echo 'data:' . $imageInfo['mime'] . ';base64,' . chunk_split(base64_encode(file_get_contents($img)));; $imageName = "25220_" . date("His", time()) . "_" . rand(1111, 9999) . '.png'; $image = $base64; if (strstr($image, ",")) &#123; $image = explode(',', $image); $image = $image[1]; &#125; // 定义文件保存路径为网站根目录下upload目录 $path = "./upload/" . date("Ymd", time()); if (!is_dir($path)) &#123; //判断目录是否存在 不存在就创建 mkdir($path, 0777, true); &#125; $imageSrc = $path . "/" . $imageName; //图片名字 $r = file_put_contents($imageSrc, base64_decode($image));//返回的是字节数 if (!$r) &#123; $tmparr1 = array('data' =&gt; null, "code" =&gt; 1, "msg" =&gt; "图片生成失败"); echo json_encode($tmparr1); &#125; else &#123; $tmparr2 = array('data' =&gt; 1, "code" =&gt; 0, "msg" =&gt; "图片生成成功"); echo json_encode($tmparr2); &#125; &#125;]]></content>
      <categories>
        <category>常用方法</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最新激活visio2013密钥]]></title>
    <url>%2F2019%2F09%2F17%2F%E6%9C%80%E6%96%B0%E6%BF%80%E6%B4%BBvisio2013%E5%AF%86%E9%92%A5%2F</url>
    <content type="text"><![CDATA[最新激活visio2013密钥viso 66DNF-28W69-W4PPV-W3VYT-TJDBQ N4M7D-PD46X-TJ2HQ-RPDD7-T28P9 ND3G9-KQHY4-8P3W2-VGXVY-B4D73 K6NC7-KMX7G-TC6RR-FDM23-8K6YQ 安装过程中出现提示时，您可以使用此产品密钥来激活 Microsoft Visio Professional 2013 的评估版本。 为您的产品密钥： J7G2X-WNGK4-VTHJX-G4DTX-YDTY2]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑袍纠察队 第一季]]></title>
    <url>%2F2019%2F09%2F09%2F%E9%BB%91%E8%A2%8D%E7%BA%A0%E5%AF%9F%E9%98%9F%20%E7%AC%AC%E4%B8%80%E5%AD%A3%2F</url>
    <content type="text"><![CDATA[第1集 http://cn4.download05.com/hls/20190726/2b31ff0cb63f6ce593b80b72d0599c06/1564131899/index.m3u8 第2集 http://cn3.ruioushang.com/hls/20190726/e680130397be98cbb30bfc384fbb3f60/1564137476/index.m3u8 第3集 http://cn3.ruioushang.com/hls/20190726/62804110a09b32ffc918f2574e66a4c2/1564138007/index.m3u8 第4集 http://cn4.download05.com/hls/20190726/b10c1ba99573b8fdf0e4f361b20bc814/1564135064/index.m3u8 第5集 http://cn4.download05.com/hls/20190726/68375eb5a21122aaf216626144d4919a/1564128035/index.m3u8 第6集 http://cn4.download05.com/hls/20190726/6946c0aa076f8cdeb93e22f43990ad0e/1564136041/index.m3u8 第7集 http://cn4.download05.com/hls/20190726/7cb95c6ac4bfdb3488fd35505c3b9cc4/1564137093/index.m3u8 第8集 http://cn4.download05.com/hls/20190726/8c2806d175f8050e09dc88abaa90c2eb/1564129436/index.m3u8 第1集 http://qiaozhen.com.cn/share/MjIwODc4JOesrDHpm4Y= 第2集 http://qiaozhen.com.cn/share/MjIwODc4JOesrDLpm4Y= 第3集 http://qiaozhen.com.cn/share/MjIwODc4JOesrDPpm4Y= 第4集 http://qiaozhen.com.cn/share/MjIwODc4JOesrDTpm4Y= 第5集 http://qiaozhen.com.cn/share/MjIwODc4JOesrDXpm4Y= 第6集 http://qiaozhen.com.cn/share/MjIwODc4JOesrDbpm4Y= 第7集 http://qiaozhen.com.cn/share/MjIwODc4JOesrDfpm4Y= 第8集 http://qiaozhen.com.cn/share/MjIwODc4JOesrDjpm4Y=]]></content>
      <categories>
        <category>影视</category>
      </categories>
      <tags>
        <tag>黑袍纠察队 第一季</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[切尔诺贝利日记]]></title>
    <url>%2F2019%2F09%2F01%2F%E5%88%87%E5%B0%94%E8%AF%BA%E8%B4%9D%E5%88%A9%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[切尔诺贝利日记第1集 https://v2.szjal.cn/share/Z5SamlNVisau8Okc]]></content>
      <categories>
        <category>影视</category>
      </categories>
      <tags>
        <tag>切尔诺贝利日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[权利的游戏]]></title>
    <url>%2F2019%2F09%2F01%2F%E6%9D%83%E5%88%A9%E7%9A%84%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[权利的游戏 第一季第1集 http://cn4.5311444.com/hls/20181119/f906b9b89a74c9135f5cdd89f5c5c1f2/1542620202/index.m3u8 第2集 http://cn4.5311444.com/hls/20181119/937781e8abc19e475252f78effdf279c/1542621076/index.m3u8 第3集 http://cn4.5311444.com/hls/20181119/eba43ae971d8986de26f23a34192ce91/1542621432/index.m3u8 第4集 http://cn4.5311444.com/hls/20181119/f62aeb60f54a0345f3d35b1738b4044d/1542621800/index.m3u8 第5集 http://cn4.5311444.com/hls/20181119/a9f604bc18fb930f861040b9ad8dddee/1542622153/index.m3u8 第6集 http://cn4.5311444.com/hls/20181119/84ee4716dcd695ff9377b589ff1d47ef/1542622495/index.m3u8 第7集 http://cn4.5311444.com/hls/20181119/415a00477e2a7a479c946740be350607/1542622841/index.m3u8 第8集 http://cn4.5311444.com/hls/20181119/b7b9b3d3ce8859ba57502c83d4bd1054/1542623216/index.m3u8 第9集 http://cn4.5311444.com/hls/20181119/5153a49290d4d015e5945189ebac2f0d/1542623596/index.m3u8 第10集 http://cn4.5311444.com/hls/20181119/364e2ac930da508a17bf9e48c627fbde/1542620635/index.m3u8 第1集 http://qiaozhen.com.cn/share/NzUzNTUk56ysMembhg== 第2集 http://qiaozhen.com.cn/share/NzUzNTUk56ysMumbhg== 第3集 http://qiaozhen.com.cn/share/NzUzNTUk56ysM+mbhg== 第4集 http://qiaozhen.com.cn/share/NzUzNTUk56ysNOmbhg== 第5集 http://qiaozhen.com.cn/share/NzUzNTUk56ysNembhg== 第6集 http://qiaozhen.com.cn/share/NzUzNTUk56ysNumbhg== 第7集 http://qiaozhen.com.cn/share/NzUzNTUk56ysN+mbhg== 第8集 http://qiaozhen.com.cn/share/NzUzNTUk56ysOOmbhg== 第9集 http://qiaozhen.com.cn/share/NzUzNTUk56ysOembhg== 第10集 http://qiaozhen.com.cn/share/NzUzNTUk56ysMTDpm4Y= 权力的游戏 第二季第1集 http://cn4.5311444.com/hls/20181119/ea37ee3ca922d0260608cd7e550e8e6c/1542623964/index.m3u8 第2集 http://cn4.5311444.com/hls/20181119/fc9ffe6ff0a26fa17539efc5c7e5405c/1542624678/index.m3u8 第3集 http://cn4.5311444.com/hls/20181119/5c2aee3e7b131f3715a8e32c6b100460/1542624994/index.m3u8 第4集 http://cn4.5311444.com/hls/20181119/b171eb487db0b825148e87290d287309/1542625307/index.m3u8 第5集 http://cn4.5311444.com/hls/20181119/94b59df63982298c89729b21cac3cecc/1542625613/index.m3u8 第6集 http://cn4.5311444.com/hls/20181119/d97f5da76e62bf53ea4ca45ba195d928/1542625933/index.m3u8 第7集 http://cn4.5311444.com/hls/20181119/39a9356e091b27f02572ac6ea574001e/1542626256/index.m3u8 第8集 http://cn4.5311444.com/hls/20181119/d27a45219a6fa6434509fc964d64d2b3/1542626606/index.m3u8 第9集 http://cn4.5311444.com/hls/20181119/2cd842fc0f1086561af3ce7d1609869f/1542626933/index.m3u8 第10集 http://cn4.5311444.com/hls/20181119/ae63dd5ff760893b22bfdb7a1f96c949/1542624295/index.m3u8 第1集 http://qiaozhen.com.cn/share/NzUzODMk56ysMembhg== 第2集 http://qiaozhen.com.cn/share/NzUzODMk56ysMumbhg== 第3集 http://qiaozhen.com.cn/share/NzUzODMk56ysM+mbhg== 第4集 http://qiaozhen.com.cn/share/NzUzODMk56ysNOmbhg== 第5集 http://qiaozhen.com.cn/share/NzUzODMk56ysNembhg== 第6集 http://qiaozhen.com.cn/share/NzUzODMk56ysNumbhg== 第7集 http://qiaozhen.com.cn/share/NzUzODMk56ysN+mbhg== 第8集 http://qiaozhen.com.cn/share/NzUzODMk56ysOOmbhg== 第9集 http://qiaozhen.com.cn/share/NzUzODMk56ysOembhg== 第10集 http://qiaozhen.com.cn/share/NzUzODMk56ysMTDpm4Y= 权力的游戏 第三季第1集 http://cn4.5311444.com/hls/20181119/ed2999c6f799a1106719d7990c255178/1542627286/index.m3u8 第2集 http://cn4.5311444.com/hls/20181119/ad477d153ddc8ae6ce9bc67648f54048/1542628026/index.m3u8 第3集 http://cn4.5311444.com/hls/20181119/6863d535b038e3903e3bd2cfe517bdbd/1542628411/index.m3u8 第4集 http://cn4.5311444.com/hls/20181119/e281c1e36fdce1570b606e3995cf4e62/1542628790/index.m3u8 第5集 http://cn4.5311444.com/hls/20181119/1382179a569e17de9018ed26f4991db8/1542629227/index.m3u8 第6集 http://cn4.5311444.com/hls/20181119/86dd39fe65625bb235028a41007701d0/1542629667/index.m3u8 第7集 http://cn4.5311444.com/hls/20181119/2d05f8e161f0d28bc973e7a9bdf36c26/1542630018/index.m3u8 第8集 http://cn4.5311444.com/hls/20181119/325c73e41e313c236b22a627b9efa841/1542630414/index.m3u8 第9集 http://cn4.5311444.com/hls/20181119/b37aa2a7309ffb0a1007fb3e4c66b757/1542630814/index.m3u8 第10集 http://cn4.5311444.com/hls/20181119/127ff4bdebb8b257ea686d499e137c72/1542627630/index.m3u8 第1集 http://qiaozhen.com.cn/share/NzU0MDYk56ysMembhg== 第2集 http://qiaozhen.com.cn/share/NzU0MDYk56ysMumbhg== 第3集 http://qiaozhen.com.cn/share/NzU0MDYk56ysM+mbhg== 第4集 http://qiaozhen.com.cn/share/NzU0MDYk56ysNOmbhg== 第5集 http://qiaozhen.com.cn/share/NzU0MDYk56ysNembhg== 第6集 http://qiaozhen.com.cn/share/NzU0MDYk56ysNumbhg== 第7集 http://qiaozhen.com.cn/share/NzU0MDYk56ysN+mbhg== 第8集 http://qiaozhen.com.cn/share/NzU0MDYk56ysOOmbhg== 第9集 http://qiaozhen.com.cn/share/NzU0MDYk56ysOembhg== 第10集 http://qiaozhen.com.cn/share/NzU0MDYk56ysMTDpm4Y= 权力的游戏 第四季第1集 http://cn4.5311444.com/hls/20181119/14c068eed0af3e15fcffd0ca35c10cf8/1542639097/index.m3u8 第2集 http://cn4.5311444.com/hls/20181119/bca92e7b7865fbe35b2a1cbb55bbb416/1542639881/index.m3u8 第3集 http://cn4.5311444.com/hls/20181119/f1aa79b52c63fde7e179ea7683bfaf34/1542640208/index.m3u8 第4集 http://cn4.5311444.com/hls/20181119/c58078f8d7222b37f0aab6b4ca2b3aa5/1542640562/index.m3u8 第5集 http://cn4.5311444.com/hls/20181119/356806f3f59d1f44781ed6de25f74a52/1542640906/index.m3u8 第6集 http://cn4.5311444.com/hls/20181119/9f2cd3234103a1679cd41094de277041/1542641238/index.m3u8 第7集 http://cn4.5311444.com/hls/20181119/7a0be6228f7a1973a98e5bb4f1be53f8/1542641563/index.m3u8 第8集 http://cn4.5311444.com/hls/20181119/3d5fa1cbd6f590e95ae93ce9dfee4d68/1542641878/index.m3u8 第9集 http://cn4.5311444.com/hls/20181119/8e71932479ab65327836f36db9e7057a/1542642206/index.m3u8 第10集 http://cn4.5311444.com/hls/20181119/f6b030f89695c7422c92460644a42475/1542639472/index.m3u8 第1集 http://qiaozhen.com.cn/share/NzU1MTIk56ysMembhg== 第2集 http://qiaozhen.com.cn/share/NzU1MTIk56ysMumbhg== 第3集 http://qiaozhen.com.cn/share/NzU1MTIk56ysM+mbhg== 第4集 http://qiaozhen.com.cn/share/NzU1MTIk56ysNOmbhg== 第5集 http://qiaozhen.com.cn/share/NzU1MTIk56ysNembhg== 第6集 http://qiaozhen.com.cn/share/NzU1MTIk56ysNumbhg== 第7集 http://qiaozhen.com.cn/share/NzU1MTIk56ysN+mbhg== 第8集 http://qiaozhen.com.cn/share/NzU1MTIk56ysOOmbhg== 第9集 http://qiaozhen.com.cn/share/NzU1MTIk56ysOembhg== 第10集 http://qiaozhen.com.cn/share/NzU1MTIk56ysMTDpm4Y= 权力的游戏 第五季第1集 http://cn4.5311444.com/hls/20181119/330b632f0198cac8aa04a02020fe0ae8/1542631296/index.m3u8 第2集 http://cn4.5311444.com/hls/20181119/d088bea3655e3801c7267f25dc65106d/1542632020/index.m3u8 第3集 http://cn4.5311444.com/hls/20181119/76b28f396e94179c2331e4c8a5f199f3/1542632396/index.m3u8 第4集 http://cn4.5311444.com/hls/20181119/c3d19ce16e9f82204a1758e5dbf5ac66/1542632796/index.m3u8 第5集 http://cn4.5311444.com/hls/20181119/c8af98e8680217c332461e45d40974b6/1542633112/index.m3u8 第6集 http://cn4.5311444.com/hls/20181119/32d641b5aac6c8d1c6cd0a429a2b5dbd/1542633509/index.m3u8 第7集 http://cn4.5311444.com/hls/20181119/d36f8e78dc51438877a0a97d77016fc5/1542633860/index.m3u8 第8集 http://cn4.5311444.com/hls/20181119/d1911d9ed851e79f17f63f60914ae438/1542634272/index.m3u8 第9集 http://cn4.5311444.com/hls/20181119/a2b376e25f6d9a30822e35c04f2a5ca6/1542634737/index.m3u8 第10集 http://cn4.5311444.com/hls/20181119/db56245c3ad866853f9900aa276fb735/1542631646/index.m3u8 第1集 http://qiaozhen.com.cn/share/NzU0Mjck56ysMembhg== 第2集 http://qiaozhen.com.cn/share/NzU0Mjck56ysMumbhg== 第3集 http://qiaozhen.com.cn/share/NzU0Mjck56ysM+mbhg== 第4集 http://qiaozhen.com.cn/share/NzU0Mjck56ysNOmbhg== 第5集 http://qiaozhen.com.cn/share/NzU0Mjck56ysNembhg== 第6集 http://qiaozhen.com.cn/share/NzU0Mjck56ysNumbhg== 第7集 http://qiaozhen.com.cn/share/NzU0Mjck56ysN+mbhg== 第8集 http://qiaozhen.com.cn/share/NzU0Mjck56ysOOmbhg== 第9集 http://qiaozhen.com.cn/share/NzU0Mjck56ysOembhg== 第10集 http://qiaozhen.com.cn/share/NzU0Mjck56ysMTDpm4Y= 权力的游戏 第六季第1集 http://cn4.5311444.com/hls/20181119/0970251005bec7ae29d58040db89e7e9/1542635078/index.m3u8 第2集 http://cn4.5311444.com/hls/20181119/68fa0dee0320d99004109fe15ce65aa2/1542635969/index.m3u8 第3集 http://cn4.5311444.com/hls/20181119/77a19994564c37d414df7e7836a8177c/1542636322/index.m3u8 第4集 http://cn4.5311444.com/hls/20181119/2a5c755d486e5c7c75295b843292204e/1542636669/index.m3u8 第5集 http://cn4.5311444.com/hls/20181119/d5448c2ddab3ab017045d7d652b2f8de/1542637078/index.m3u8 第6集 http://cn4.5311444.com/hls/20181119/76e3eeb6443509b30b07042ee20bc677/1542637537/index.m3u8 第7集 http://cn4.5311444.com/hls/20181119/c2555f2a7e150b068d1b8df3d7ecb39a/1542637873/index.m3u8 第8集 http://cn4.5311444.com/hls/20181119/429df7c335b73ecc401c3f3ee9dc7a62/1542638251/index.m3u8 第9集 http://cn4.5311444.com/hls/20181119/71165bd7e6abbe96e0b5e62dba9a66ae/1542638709/index.m3u8 第10集 http://cn4.5311444.com/hls/20181119/9719fb1cced5a168259b0cae20fdb8f8/1542635418/index.m3u8 第1集 http://qiaozhen.com.cn/share/NzU0NzIk56ysMembhg== 第2集 http://qiaozhen.com.cn/share/NzU0NzIk56ysMumbhg== 第3集 http://qiaozhen.com.cn/share/NzU0NzIk56ysM+mbhg== 第4集 http://qiaozhen.com.cn/share/NzU0NzIk56ysNOmbhg== 第5集 http://qiaozhen.com.cn/share/NzU0NzIk56ysNembhg== 第6集 http://qiaozhen.com.cn/share/NzU0NzIk56ysNumbhg== 第7集 http://qiaozhen.com.cn/share/NzU0NzIk56ysN+mbhg== 第8集 http://qiaozhen.com.cn/share/NzU0NzIk56ysOOmbhg== 第9集 http://qiaozhen.com.cn/share/NzU0NzIk56ysOembhg== 第10集 http://qiaozhen.com.cn/share/NzU0NzIk56ysMTDpm4Y= 权力的游戏 第七季第1集 http://cn4.5311444.com/hls/20181017/732bdc26af2ac90dca38b2ae9a8a565b/1539761542/index.m3u8 第2集 http://cn4.5311444.com/hls/20181017/b71052127506427e925eaac34e5cd878/1539761977/index.m3u8 第3集 http://cn4.5311444.com/hls/20181017/465b7adbaaaf4f535b4a15970a09dabf/1539762419/index.m3u8 第4集 http://cn4.5311444.com/hls/20181017/3ddf3a5c1077a57bdb1d85858e4bcecd/1539762871/index.m3u8 第5集 http://cn4.5311444.com/hls/20181017/9a264a435afa5ec81d5582aaf6c93ce1/1539763255/index.m3u8 第6集 http://cn4.5311444.com/hls/20181017/8ccefff5bf6a75065b98c5f1053b6e8a/1539763690/index.m3u8 第7集 http://cn4.5311444.com/hls/20181017/349147f6f2f824e36cd75b3b819cbd75/1539764234/index.m3u8 第1集 http://qiaozhen.com.cn/share/NjMxNjEk56ysMembhg== 第2集 http://qiaozhen.com.cn/share/NjMxNjEk56ysMumbhg== 第3集 http://qiaozhen.com.cn/share/NjMxNjEk56ysM+mbhg== 第4集 http://qiaozhen.com.cn/share/NjMxNjEk56ysNOmbhg== 第5集 http://qiaozhen.com.cn/share/NjMxNjEk56ysNembhg== 第6集 http://qiaozhen.com.cn/share/NjMxNjEk56ysNumbhg== 第7集 http://qiaozhen.com.cn/share/NjMxNjEk56ysN+mbhg== 权力的游戏 第八季第1集 http://cn4.5311444.com/hls/20190415/b4019448604e9fa86fe74b14afd5021b/1555304455/index.m3u8 第2集 http://cn4.5311444.com/hls/20190422/3d6b06bb662fcc08d8b0a90eeb9b44eb/1555907785/index.m3u8 第3集 http://cn4.ruioushang.com/hls/20190429/846d1f6411588f3645afba8e2dd94eef/1556510464/index.m3u8 第4集 http://cn4.merrytime.cc/hls/20190506/8c637de4e3711265834945ddd1b56e72/1557119917/index.m3u8 第5集 http://cn2.ruioushang.com/hls/20190513/49f612bc59279ad792a183fe9e6ecefc/1557721445/index.m3u8 第6集 http://cn1.5311444.com/hls/20190520/ab534970cd11a0b6e5779b54c092e944/1558328022/index.m3u8 第1集 http://qiaozhen.com.cn/share/MTM4OTQ2JOesrDHpm4Y= 第2集 http://qiaozhen.com.cn/share/MTM4OTQ2JOesrDLpm4Y= 第3集 http://qiaozhen.com.cn/share/MTM4OTQ2JOesrDPpm4Y= 第4集 http://qiaozhen.com.cn/share/MTM4OTQ2JOesrDTpm4Y= 第5集 http://qiaozhen.com.cn/share/MTM4OTQ2JOesrDXpm4Y= 第6集 http://qiaozhen.com.cn/share/MTM4OTQ2JOesrDbpm4Y=]]></content>
      <categories>
        <category>影视</category>
      </categories>
      <tags>
        <tag>权利的游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[切尔诺贝利]]></title>
    <url>%2F2019%2F08%2F31%2F%E5%88%87%E5%B0%94%E8%AF%BA%E8%B4%9D%E5%88%A9%20%E7%AC%AC%E4%B8%80%E5%AD%A3%2F</url>
    <content type="text"><![CDATA[切尔诺贝利 第一季第1集 https://v2.szjal.cn/share/XWH1eZs2dmgX0Jjc 第2集 https://v2.szjal.cn/share/4JtZb57eoT4TMRW8 第3集 https://v2.szjal.cn/share/0OFmNM0fUTFtkwLz 切尔诺贝利·禁区-无人原样而归 第二季第1集 https://v2.szjal.cn/share/XWH1eZs2dmgX0Jjc 第2集 https://v2.szjal.cn/share/4JtZb57eoT4TMRW8 第3集 https://v2.szjal.cn/share/0OFmNM0fUTFtkwLz 第4集 https://v2.szjal.cn/share/RvaoqHNRBBRqKxbi 第5集 https://v2.szjal.cn/share/sE0OFNJEurQDPkn6]]></content>
      <categories>
        <category>影视</category>
      </categories>
      <tags>
        <tag>切尔诺贝利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svn使用思路]]></title>
    <url>%2F2019%2F08%2F27%2Fsvn%E4%BD%BF%E7%94%A8%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[svn使用思路 新建版本库，①trunk文件夹存放基础版本 ②branches开发新功能分支 ③tags版本完成分支 主分支开始开发 并完成提交版本v1.0-测试版本并且提交 主分支继续开发中 这时上线版本需要进行一些修改bug，以及功能的完善 branches上建立分支，并且切换到该分支下进行开发。 开发测试完成后，则于线上版本v1.0进行合并。 切换回主分支trunk下，将branches上的功能进行合并。遇到有冲突的文件需要右键点击冲突文件后编辑冲突，手动合并代码后保存，并且更改为已经解决 编辑好后重新上传到新的版本库中，完成一个合并操作。]]></content>
      <categories>
        <category>svn</category>
      </categories>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全职高手]]></title>
    <url>%2F2019%2F08%2F27%2F%E5%85%A8%E8%81%8C%E9%AB%98%E6%89%8B%2F</url>
    <content type="text"><![CDATA[全职高手第1集 https://v1.szjal.cn/share/dzbqI8LyjuGIuOWo 第2集 https://v1.szjal.cn/share/MDQY4D4DDdGnqsKp 第3集 https://v1.szjal.cn/share/SdqBYrKCCUIkt1uc 第4集 https://v1.szjal.cn/share/BN23x1O0FnDcibGM 第5集 https://v1.szjal.cn/share/Y7xpl3RNH8isYJgE 第6集 https://v1.szjal.cn/share/mTuhJVeRYvSGc62c 第7集 https://v1.szjal.cn/share/kQMclMSK2m0bkNFt 第8集 https://v1.szjal.cn/share/bzfSkPYgTa6zPqI1 第9集 https://v1.szjal.cn/share/HnsLGwaK5RIzNv3P 第10集 https://v1.szjal.cn/share/QJegmxEZV6rN4hIR 第11集 https://v1.szjal.cn/share/8AQAZ0hlUkgkNQJz 第12集 https://v1.szjal.cn/share/AFCgoo7tD3jQ9bzB 第13集 https://v1.szjal.cn/share/Vdw150QC6IYsmPv4 第14集 https://v1.szjal.cn/share/kVTinZeIv0T5HLJ8 第15集 https://v1.szjal.cn/share/fecZAd0vx0G7BzKa 第16集 https://v1.szjal.cn/share/ukcy1HYgCk7qkh47 第17集 https://v1.szjal.cn/share/d97kSoZY07jFqiDk 第18集 https://v1.szjal.cn/share/6Sedqd1PdNcxF9nR 第19集 https://v3.szjal.cn/share/gE6DCE49rwlCguxs 第20集 https://v3.szjal.cn/share/aNbWWcZO2iqGEs2t 第21集 https://v3.szjal.cn/share/bQbUUlEf4vJxv1Jo 第22集 https://v3.szjal.cn/share/VDs8BLBQ9H1F6wdw 第23集 https://v3.szjal.cn/share/xuCFtxsQK8pMzTmL 第24集 https://v3.szjal.cn/share/WGZ88UnSa8O0usVF 第25集 https://v3.szjal.cn/share/NWge6veyqzfjOAG0 第26集 https://v3.szjal.cn/share/stUQ5L8MBVvp2NUD 第27集 https://v3.szjal.cn/share/MJydiBhb6eXdIqA4 第28集 https://v3.szjal.cn/share/k31HCIZYKncuK8Ny 第29集 https://v3.szjal.cn/share/i5GqrSQuB2TjJLrQ 第30集 https://v3.szjal.cn/share/iRdmEYzVWJeMdniR 第31集 https://v3.szjal.cn/share/YVHysnIDTUcdqSVV 第32集 https://v3.szjal.cn/share/s8CbdJJ3OAXgDlPe 第33集 https://v3.szjal.cn/share/CMkT8XUjFKqNGsMP 第34集 https://v3.szjal.cn/share/HNdcyIVjj8XelKKO 第35集 https://v3.szjal.cn/share/lwlHh7HTxXv10uFM 第36集 https://v3.szjal.cn/share/9ptanp85IO7fieqD 第37集 https://v3.szjal.cn/share/uwJ7xesXy8CJoULE 第38集 https://v3.szjal.cn/share/X72XD0HKIW45vHtN 第39集 https://v3.szjal.cn/share/4fuIBvBE2kTWhFtB 第40集 https://v3.szjal.cn/share/mP1diPDXQjEMFHB8]]></content>
      <categories>
        <category>影视</category>
      </categories>
      <tags>
        <tag>全职高手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库映射]]></title>
    <url>%2F2019%2F08%2F27%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[数据库映射代码123456789101112CREATE TABLE `organization_chart` ( `organization_chart_id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &apos;部门ID&apos;, `organization_chart_name` varchar(255) DEFAULT &apos;&apos; COMMENT &apos;部门名称&apos;, `time` int(11) DEFAULT &apos;0&apos; COMMENT &apos;添加时间&apos;, `organization_chart_level` int(11) DEFAULT &apos;0&apos; COMMENT &apos;部门等级&apos;, `organization_chart_pid` int(11) DEFAULT &apos;0&apos; COMMENT &apos;上级部门ID&apos;, `stor` int(11) DEFAULT &apos;0&apos; COMMENT &apos;排序&apos;, `organization_chart_content` varchar(600) DEFAULT &apos;&apos; COMMENT &apos;部门描述&apos;, `infos_id` int(11) DEFAULT &apos;0&apos; COMMENT &apos;关联平台ID&apos;, PRIMARY KEY (`organization_chart_id`)) ENGINE=FEDERATED CONNECTION=&apos;mysql://root:123456@192.168.2.210:3306/zhypt/organization_chart&apos; COMMENT &apos;部门映射表&apos;; 修改数据库配置文件 my.ini 数据库配置文件 开启映射 12[mysqld]federated]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown.css]]></title>
    <url>%2F2019%2F07%2F31%2Fmarkdown.css%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224body&#123; margin: 0 auto; font-family: "ubuntu", "Tahoma", "Microsoft YaHei", arial,sans-serif; color: #444444; line-height: 1; padding: 30px;&#125;img &#123; max-width: 100%;&#125;@media screen and (min-width: 1000px) &#123; body &#123; width: 842px; margin: 10px auto; &#125; &#125;h1, h2, h3, h4 &#123; color: #111111; font-weight: 400; margin-top: 1em;&#125;h1, h2, h3, h4, h5 &#123; font-family: Georgia, Palatino, serif;&#125;h1, h2, h3, h4, h5, dl&#123; margin-bottom: 16px; padding: 0;&#125;p &#123; margin-top: 8px; margin-bottom: 3px;&#125;h1 &#123; font-size: 48px; line-height: 54px;&#125;h2 &#123; font-size: 36px; line-height: 42px;&#125;h1, h2 &#123; border-bottom: 1px solid #EFEAEA; padding-bottom: 10px;&#125;h3 &#123; font-size: 24px; line-height: 30px;&#125;h4 &#123; font-size: 21px; line-height: 26px;&#125;h5 &#123; font-size: 18px; line-height: 23px;&#125;a &#123; color: #0099ff; margin: 0 2px; padding: 0; vertical-align: baseline; text-decoration: none;&#125;a:hover &#123; text-decoration: none; color: #ff6600;&#125;a:visited &#123; /*color: purple;*/&#125;ul, ol &#123; padding: 0; padding-left: 18px; margin: 0;&#125;li &#123; line-height: 24px;&#125;p, ul, ol &#123; font-size: 16px; line-height: 24px;&#125;ol ol, ul ol &#123; list-style-type: lower-roman;&#125;code, pre &#123; font-family: Consolas, Monaco, Andale Mono, monospace; background-color:#f7f7f7; color: inherit;&#125;code &#123; font-family: Consolas, Monaco, Andale Mono, monospace; margin: 0 2px;&#125;pre &#123; font-family: Consolas, Monaco, Andale Mono, monospace; line-height: 1.7em; overflow: auto; padding: 6px 10px; border-left: 5px solid #6CE26C;&#125;pre &gt; code &#123; font-family: Consolas, Monaco, Andale Mono, monospace; border: 0; display: inline; max-width: initial; padding: 0; margin: 0; overflow: initial; line-height: 1.6em; font-size: .95em; white-space: pre; background: 0 0;&#125;code &#123; color: #666555;&#125;aside &#123; display: block; float: right; width: 390px;&#125;blockquote &#123; border-left:.5em solid #eee; padding: 0 0 0 2em; margin-left:0;&#125;blockquote cite &#123; font-size:14px; line-height:20px; color:#bfbfbf;&#125;blockquote cite:before &#123; content: '\2014 \00A0';&#125;blockquote p &#123; color: #666;&#125;hr &#123; text-align: left; color: #999; height: 2px; padding: 0; margin: 16px 0; background-color: #e7e7e7; border: 0 none;&#125;dl &#123; padding: 0;&#125;dl dt &#123; padding: 10px 0; margin-top: 16px; font-size: 1em; font-style: italic; font-weight: bold;&#125;dl dd &#123; padding: 0 16px; margin-bottom: 16px;&#125;dd &#123; margin-left: 0;&#125;table &#123; *border-collapse: collapse; /* IE7 and lower */ border-spacing: 0; width: 100%;&#125;table &#123; border: solid #ccc 1px;&#125;table thead &#123; background: #f7f7f7;&#125;table thead tr:hover &#123; background: #f7f7f7&#125;table tr:hover &#123; background: #fbf8e9; -o-transition: all 0.1s ease-in-out; -webkit-transition: all 0.1s ease-in-out; -moz-transition: all 0.1s ease-in-out; -ms-transition: all 0.1s ease-in-out; transition: all 0.1s ease-in-out;&#125;table td, .table th &#123; border-left: 1px solid #ccc; border-top: 1px solid #ccc; padding: 10px; text-align: left;&#125;table th &#123; border-top: none; text-shadow: 0 1px 0 rgba(255,255,255,.5); padding: 5px; border-left: 1px solid #ccc;&#125;table td:first-child, table th:first-child &#123; border-left: none;&#125;]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux学习--实操2.0]]></title>
    <url>%2F2019%2F07%2F29%2Flinux%E5%AD%A6%E4%B9%A0--%E5%AE%9E%E6%93%8D%E7%AF%872.0%2F</url>
    <content type="text"><![CDATA[1、crond任务调度1.1 概述：1.1.1任务调度：是指系统在某个时间执行的特定的命令或者程序。 任务调度分类：1. 系统工作：一些系统的工作必须周而复始的执行。如病毒扫描。 2. 个别用户的工作：个别用户可能希望执行某些程序，比如对mysql的数据库备份等。 1.2 基本语法crontab [选项] 1.3 常用选项 -e：编辑crontab定时任务 -l：查询crontab定时任务 -r：删除当前用户所有的crontab定时任务 1.4 快速入门案例 设置任务调度文件 /etc/crontab,设置个人任务调度。执行crontab -e命令。接着输入任务到调度文件如： /1 * ls -l /etc/&gt;&gt;/tmp/to.txt命令12crontab -e //开启任务编辑器*/1 * * * * ls -l /etc/&gt;&gt;/tmp/to.txt命令 1.5 说明 如果是简单的任务，可以不用写脚本，直接在crontab中加入任务即可 对于比较复杂的任务需要写脚本来完成（shell编程） 1.6 参数说明1.6.1 *的说明 项目 含义 范围 第一个“*” 一小时当中的第几分钟 0-59 第二个“*” 一天当中的第几小时 0-23 第三个“*” 一个月当中的第几天 1-31 第四个“*” 一年当中的第几个月 1-12 第五个“*” 一周当中的星期几 0-70和7都是表示星期天 1.6.2 特殊符号说明 特殊符号 含义 * 代表任何时间。比如第一个*就是每分钟执行一次 , 代表不连续时间。比如0 8,12,16 * 命令表示每天8点0分12点0分16点0分都执行一次 - 代表连续时间。比如0 5 1-6 命令表示每周一到周五5点0分都执行一次 */n 代表每隔多久执行一次。比如/10 * 命令表示每间隔10分钟都执行一次 1.6.3 案例说明 时间 含义 45 22 * 命令 每天22点45执行一次命令 0 2 1 命令 每周一的2点0分执行一次命令 0 2 1,15 命令 每月1到15号的2点0分执行一次命令 40 2 1-5 命令 每周一到周五的2点40分执行一次命令 /10 4 命令 每天4点,每间隔10分钟执行一次命令到5点就不执行了 0 0 1,15 * 1 命令 每月的1号15号0点0分执行一次命令，每周一的0点0分执行一次命令。都会执行。注意：星期几和几号最好不要同时出现，因为他们都是天。非常容易让管理员混淆 1.7 任务调度的几个应用实例1.7.1 案例一：每隔1分钟，将当前的日期信息追加到/home/date.txt文件中123456789//1.编写一个文件，并写入代码touch mytash1.shvim mytash1.sh date&gt;&gt;/home/date.txt//2.给mytash1.sh一个权限 chmod 744 mytash1.sh//3.crontab -e//4.*/1 * * * * /home/mytash1.sh//5.成功 1.7.2 案例二：每间隔一分钟，将当前日期和日历都追加到/home/date.txt文件中1234//修改mytash1.sh vim mytash1.sh date&gt;&gt;/home/date.txt cal&gt;&gt;/home/date.txt 1.7.3 案例三：每天凌晨2:00将mysql数据库testdb，备份到文件中mydb.bak123456789//1.编写一个文件，并写入代码touch mytash2.shvim mytash1.sh /usr/local/mysql/bin/mysqldump -u root -proot testbd &gt; /tmp/mydb.bak//2.给mytash2.sh一个权限 chmod 744 mytash2.sh//3.crontab -e//4.0 2 * * * /home/mytash2.sh//5.成功 1.8 crond 相关指令 1）crontab -r:终止任务调度。（删除） 2）crontab -l:列出当前用户的任务调度 3）service crond restart [重启任务调度] 2、linux 磁盘分区和挂载2.1 分区基本概念2.1.1 mbr分区 最多支持4个主分区 系统只能安装到主分区 扩展分区要占一个主分区 MBR最大只支持2TB，但是拥有最好的兼容性 2.1.2 gpt分区 支持无限多个主分区（但操作系统可能限制，比如windows下最多128个分区） 最大支持18EB的大容量（1EB=1024PB ，1PB=1024TB） windows7 64位以后支持gtp 2.2 linux 分区2.2.1 原理介绍 linux来说无论有几个分区，分给哪一个目录使用，它归根结底就只有一个根目录，一个du’li且唯一的文件结构，Linux中每一个分区都是用来组成整个文件系统的一部分 Linux 采用了一种载入的方式，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。 linux硬盘通过mount(挂载)umount(卸载)操作和linux文件系统联系起来 2.2.2 硬盘分区 linux硬盘分ide硬盘和scsl硬盘，目前基本上是scsl硬盘，scsl的性能更好。 对于ide硬盘，驱动器标识符为“hdx”,其中“hd”表明分区所在设备类型，这里是指IDE硬盘了。“x”为盘号（a为基本盘，b为基本从盘，c为辅助主盘，d为辅助从属盘），“~”代表分区，前四个分区用数字1到4表示，他们是主分区或扩展分区，从5开始就是逻辑分区，例如hda3表示第一个ide磁盘上的第三个主分区或者扩展分区，hdb2表示为第二个IDE硬盘上的第二个主分区或扩展分区。 对于SCSL硬盘则标识为“sdx”,SCSL硬盘是用“sd”来表示分区所在的设备类型的，其余则和IDE硬盘的表示方法一样。 2.2.3 指令(查看系统分区和挂载的情况)12lsblk -f lsblk 2.3 挂在的经典案例2.3.1 需求是给我们的Linux系统增加一个新的硬盘 虚拟机添加硬盘 分区 代码：fdisk /dev/sdb 开始对/sdb分区 m显示命令列表 p显示磁盘分区 同fdisk -l n新增分区 d删除分区 w写入并退出 说明： 开始分区后输入n,新增分区，然后选择p,分区类型为主分区。两次回车默认剩余全部空间。最后输入w写入分区并退出，若不保存则退出输入q 格式化 代码：mkfs -t ext4 /dev/sdb1 ext4是分区类型 挂载 先创建一个目录 mkdir /home/newdisk 挂载 mount 设备名称 挂在目录 mount /dev/sdb1 /home/newdisk 设置可以自动挂载(永久挂载，即重启后仍然可以自动挂载) vim /etc/fstab /dev/sdb1 home/newdisk ext4 defaults 0 0 卸载 umount 设备名称或者挂载目录 例如：umount /dev/sdb1 或者umount /newdiskT 3、磁盘使用情况3.1 指令：查询磁盘整体的使用情况df1df -lh 3.2 查询指定目录的磁盘占用情况3.2.1 基本语法：du -h /目录 3.2.2 查询指定目录的磁盘占用情况，默认为当前目录 -s：指定目录占用大小汇总 -h：带计量单位 -a：含文件 –max-depth=1 子目录深度 -c 列出明细的同时，增加汇总量 3.2.3 应用实例查询 /home目录的磁盘占用情况，深度为11du -ach --max-depth=1 /home 3.3 工作中常用指令3.3.1 统计/home文件夹下文件的个数1ls -l /home | grep &quot;^-&quot; |wc -l 3.3.2 统计/home文件夹下目录的个数1ls -l /home | grep &quot;^d&quot;|wc -l 3.3.3 统计/home文件夹下文件的个数，包括子文件夹里面的1ls -lR /home | grep &quot;^-&quot; |wc -l 3.3.4 统计/home文件夹下目录的个数，包括子目录的1ls -lR /home |grep &quot;^d&quot;|wc -l 3.3.5 以树状显示/home目录默认显示当前目录 12yum install treetree /home 4、网络配置4.1 网络配置原理图 4.2 虚拟网络4.2.1 查看虚拟网络编辑器 4.2.2 查看网关 4.2.3 查看设置window下的vmnet8的网络配置 4.2.4 设置好后ping测试4.3 linux 网络的环境配置4.3.1 第一种方式 自动获取缺点，每次获取的ip不一样 4.3.2 第二种方式 指定固定ip地址1) 说明：直接修改配置文件来指定ip地址，并连接到外网，编辑1vi /etc/sysconfig/network-scripts/ifcfg-ens33 1234567891011121314151617181920TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;BOOTPROTO=&quot;static&quot; DEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens33&quot;UUID=&quot;774b3c34-0110-46e3-b78d-0d3b644ddd6b&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;IPV6_PRIVACY=&quot;no&quot;DNS1=114.114.114.114IPADDR=192.168.72.2NETMASK=255.255.255.0GATEWAY=192.168.72.1 2) 修改完后重启服务1service network restart 5、进程管理5.1 基本介绍 在linux中，每个执行的程序（代码）就是一个进程，每一个进程都分配一个id号。 每一个进程都对应一个父进程，而这个父进程可以复制多个子进程，例如www服务器 每个进程都可以以两种方式存在，前台和后台，所谓的前台就是用户在自己的屏幕上可以进行操作的，后台进程则是实际在操作，但是屏幕上面无法看到的，通常使用后台方式执行。 一般系统的进程都是以后台方式存在的，而且会常驻系统中，关机才会结束。 5.2 常用操作5.2.1 显示系统中执行的指令 ps ps显示的字段信息 字段 说明 PID 进程识别号 TTY 终端机号 TIME 此进程所消耗的cpu时间 CMD 正在执行的命令或者进程名 5.2.2 常用参数 ps -a:显示当前终端的所有进程信息 ps -u:以用户的格式显示进程信息 ps -x:显示后台进程运行的参数 ps -aux5.2.3 指令详解 5.2.4 实例 查看系统中有没有sshd进程 1ps -aux | grep sshd 查看进程的父进程 1ps -ef | more -e显示所有进程 -f全格式 查看sshd父进程1ps -ef | grep sshd 5.3 终止进程 kill 或者 killall5.3.1 介绍：如果进程执行一半需要停止时，或者已消耗了很大的系统资源时，此时可以考虑停止该进程。使用kill命令来完成此项目。 5.3.2 基本语法： kill [选项] 进程号 （功能描述：通过进程号杀死进程） killall 进程名称 （功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载较大时而变慢时很有用）5.3.3 常用语法： -9：表示强迫进程立即停止5.3.4 案例 踢掉某个非法用户 查看当前用户 1ps -aux |grep sshd 根据进程号杀死用户 1kill 7192 终止远程登陆服务sshd 在适当的时候再次重启sshd服务 kill掉sshd的进程号 终止多个gedit编辑器 1killall gedit 强制杀掉一个终端 1kill -9 4090 5.4查看进程树 常用参数 -p:显示进程的pid -u:显示进程的所属用户12pstree -ppstree -u 6、服务管理6.1 介绍 服务的本质就是进程，但是运行在后台，通常会监听某个端口，等待其他的请求，比如(mysql，sshd,防火墙等),因此我们又称为守护进程，是linux非常重要的知识点。 6.2 service管理指令 service 服务名 start|stop|restart|reload|status|在CentOS 7.0后,不再使用service,而是用systemctl 6.3 使用案例 1）查看当前防火墙的状态，关闭防火墙，重启防火墙 123systemctl status firewalld.servicesystemctl start firewalldsystemctl stop firewalld - 补充：锁定防火墙 12345//解除锁定systemctl unmask firewalldRemoved symlink /etc/systemd/system/firewalld.service.//锁定防火墙systemctl mask firewalld 2）查看当前启动的服务 12345678910111213141516 ls -l /etc/init.d/ ``` #### 6.4 运行级别![q2.jpg](https://i.postimg.cc/HLNB1xw5/q2.jpg)#### 6.5 chkconfig指令- 介绍 通过chkconfig 命令可以给每个服务的各个运行级别设置自启动/关闭- 基本语法 - 1）查看服务 chkconfig --list|gerp xxx - 2）chkconfig 服务名 --list ```markdown //constOS7指令 systemctl list-unit-files |grep sshd 3）修改sshd在运行级别5的时候不自启动1chkconfig --level 5 ssdh off 6.6 监控网络状态6.6.1 查看网络状态 基本语法 netstat [选项] 选项说明 -an 按一定顺序排列输出 -p 显示哪个进程在调用 应用案例 查看服务名为sshd的服务信息1netstat -p | grep sshd 6.6.2 动态监控进程 介绍 top与ps相似，它们都是用来显示正在执行的进程。Top与ps最大的不同之处就是，top在执行中可以更新正在运行的进程 基本语法 top [选项] 选项说明 |选项|说明| |—|—| |-d 秒数|指定top命令每隔几秒更新，默认是3秒更新| |-i|使top不显示任何闲置或者僵尸进程| |-p|通过指定监控进程id来仅仅监控某个进程的状态| 交互操作 |操作|功能| |—|—| |p|已cpu使用率排序，默认就是此项| |m|已内存使用率排序| |n|已pid排序| |q|退出top| 应用实例 监视特定的用户 12top输入u回车后再输入指定的用户名 终止指定的进程 123top输入k后回车再输入指定的id号sigterm 指定系统的更新时间（默认是3秒刷新一次） 1top -d 10 6.7 监控网络状态6.7.1 查看系统网络情况 基本语法 netstat [选项] 选项说明 -an：按一定顺序排列输出 -p：显示哪个进程在调用 应用案例 查看所有的网络服务1netstat -anp | more 7、linux RPM与YUM7.1 rpm包的管理 介绍 一种互联网下载包的打包工具和下载工具它包含在某些linux分发版中。它生成具有RPM扩展名的文件。RPM是RedHat Package Manager (RedHat软件包管理工具)的缩写，类似windows的setup.exe 这一文件格式名称虽然打上了RedHat的标志，但理念是通用的。 rpm包的简单查询指令 1rpm -qa | grep XX rpm包基本格式的讲解 一个rpm包名：firefox-45.0.1-1.el6.centos.x86-64.rpm 名称：firefox 版本号：45.0.1-1 适用操作系统：el6.centos.x86-64 表示centos6.x的64位系统 如果是i686、i386表示32位系统，noarch表示通用 rpm包的其它查询指令 rpm -qa 查询所有安装的rpm包 1）rpm -qa | more 2）rpm -qa | grep XX (rpm-qa | grep sudo) rpm -q XX 查询软件包是否安装 1）rpm -q sudo rpm -qi XX 查询软件包信息 1）rpm -qi sudo rpm -ql XX 查询软件包中的文件 1）rpm -ql sudo rpm -qf XX 文件全路径名 查询文件所属的软件包 1) rpm -qf /var/db/sudo 卸载rpm包 基本语法rpm -e RPM包的名称 应用案例 1）删除firefox 软件包 细节：（1）如果其他软件包依赖于您要预载的软件包，预载时则会产生错误信息（2）强制删除foo这个包则增加参数–nodeps,但是一般不这么做，防止依赖的包不能使用 1rpm -r --nodeps foo 安装rpm包 基本语法rpm -ivh RPM包的名称 参数说明 1）i=install 安装 2）v=verbose 提示 3）h=hash 进度条 案例 1）安装firefox 121.先找到firefox的rpm安装包rpm -ivm firefox-45.0.1.el6.centos.x86-64.rpm 7.2 yum 介绍 yum是一个shell前端软件包管理器，基于RPM包管理，能够从指定的服务器自动下载RPM包，并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。 yum的基本指令 查询yum的服务器是否有安装的软件 1yum list|grep xx(软件列表) 安装指定的yum包 123456 yum install xxx(下载安装) ``` - yum应用实例 - 使用yum安装firefox ```markdown yum install firefox 8 Linux之JavaEE定制篇 搭建开发环境8.1 概述]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux学习--实操篇]]></title>
    <url>%2F2019%2F07%2F27%2Flinux%E5%AD%A6%E4%B9%A0-%E5%AE%9E%E6%93%8D%E7%AF%87%2F</url>
    <content type="text"><![CDATA[一、组管理和权限管理linux组基本介绍 linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者，所在组，其他组的概念。 所有者 所在组 其他组 改变用户所在组文件目录的所有者 一般谁创建了该文件谁就是文件的所有者 查看文件的所有者 指令： ls -ahl 应用实例： 创建一个组的police,再创建一个用户tom,然后使用tom来创建一个文件，看看情况如何。tory 1234567891. 创建组 groupadd police2. 创建用户 groupadd user -g police tom3. 更新密码 passwd tom4. ls -ahl drwx------. 2 tom police 75 7月 28 01:20 tom tom 就是文件的所有者，police就是文件的所属组 改变文件所有者 指令： chown 用户名 文件名 应用案例 要求：使用root创建一个文件，然后将所有者改成tom 12touch b.txtchown tom b.txt 组的创建 基本 指令 groupadd 组名 应用实例 创建一个组，monster 创建一个用户fox,并放到monster中 1234groupadd monsteruseradd -g monster foxpasswd foxid fox]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux学习--指令篇]]></title>
    <url>%2F2019%2F07%2F22%2Flinux%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[linux实用指令帮助指令1.man查找函数的详细帮助文档，获得帮助信息 1man ls 2.help获得shell内置命令的帮助信息 1help cd 文档目录类1.pwd显示当前工作目录的绝对路径 2.ls显示目录或者文件 常用选项 -a:显示当前目录的所有文件和目录，包括隐藏的 -l:以列表的方式显示信息 -al:以列表的方式显示信息 3.cd切换到指定目录 常用选项 绝对路径/相对路径 121. 绝对路径：/home 即从根目录开始定位2. 相对路径： ../home 从当前工作目录开始定位到需要的目录中去 cd ~或者cd 回到自己的家目录 cd .. 回到当前目录的上一级目录 4.mkdir创建目录 1mkdir /home/dog 常用选项 -p 创建多级目录用1mkdir -p /home/cat/cat1 5.rmdir删除目录 1rmdir /home/dog 说明 不能删除非空目录 删除非空目录 则 rm -rf /home/cat 6.touch创建空文件 1touch hello.txt 说明 一次性创建多个文件 空格间隔1touch hello.txt hello1.txt 7.cp拷贝到指定目录 -- cp [参数] 源目录 目标目录 常用选项 -r 递归拷贝文件夹 123cp -r aaa/ bbb/cp -r hello.txt bbb/ \cp 强制覆盖 当目标目录有同名文件强制覆盖操作 1\cp -r aaa/ bbb/ 说明强制覆盖的时候，有同名的会覆盖不同名则会复制 8.rm删除文件或文件夹 常用选项 -r:递归删除整个文件夹 -f:强制删除不提示 12rm -rf aaa/rm -f hello.txt 9.mv移动文件目录或者重命名 12mv hello.txt good.txt 重命名mv good.txt aaa/ 移动 说明移动如果当前目录有这个文件则会认为是重命名如果没有则认为是移动相当于windows中的剪切 10.cat查看文件内容 cat [选项] 文件名 1cat -n /etc/profile | more 常用选项 -n :显示行号 说明|more 分页显示 11.more基于vi编辑器的文本过滤器，它以全屏的方式按页显示文本 常用选项 空格翻页 ctrl+b 向上滚动一屏 ctrl+f 向下滚动一屏 = 输出当前行号 :f 输出文件名和当前行号 12.less跟more类似，但是并不是整个加载后显示，根据需要显示 1less book.txt 常用选项 空格 向下翻页 pagedown /pageup 翻页 /字串 向下查找关键字 ?子串 向上查找关键字 q 退出文档 13.&gt;指令和&gt;&gt;指令&gt; 输出重定向（覆盖） &gt;&gt; 追加 基本语法 ls -l&gt;文件 （功能描述：列表中的内容写入文件a.txt中（覆盖写）） ls -al&gt;&gt;文件 （功能描述：列表中的内容追加到文件aa.txt的末尾） cat 文件1&gt;文件2 （将文件1的内容覆盖到文件2） echo “内容”&gt;&gt;文件 cal &gt; a.txt(覆盖) cal &gt;&gt; a.txt(尾部追加)14.echo 输出内容到控制台 语法 echo [选项] 输出内容 应用实例 输出环境变量：echo $PATH 输出hello world： echo hello word. 15.head显示文件开头几行的内容 1head -n 5 hello.txt 16.tail用于输出文件尾部的几行 基本语法 tail 文件 （功能：查看文件后10行内容） tail -n 5 文件 （功能描述，查看文件后5行的内容） tail -f 文件 （功能描述：实施追踪该文件所有更新）重点 17.ln创建软连接，也叫符号链接，类似window中的快捷方式 基本语法 ln -s [源文件或者目录][软链接名] 应用实例 创建root的软连接1ln -s /root linktoroot 注意删除的时候一定不要加/ 例如linktoroot/这样会把目录下的文件都删掉不是删除这个快捷方式 18.history查看执行过的历史命令 案例 查看所有历史指令 1history 查看最后10条指令 1history 10 执行历史第5条历史指令 1!5 文件目录类1.date显示当前日期 参数 date 显示时间信息 2019年 07月 24日 星期三 18:14:32 CST date “+%Y-%m-%d” 2019-07-24 date -s “2018-11-11 11:22:22” 设置时间2.cal 查看日历 搜索查找类1.find 语法 find [搜索范围] [选项] 选项说明 -name &lt;查询方式&gt; -user&lt;用户名&gt; -size&lt;文件大小&gt; 按照文件名查找/home目录下的hello.txt文件 1find /home -name hello.txt 按照拥有者查找/home目录下,用户名为root的文件 1find /home -user root 查找整个linux系统下大于20兆的文件（+n大于 -n小于 n等于） 1find / -size +20M 查找整个linux系统下.txt文件 1find / -name *.txt 2.locate快速定位文件路径 语法 locate 搜索文件 特别说明 在第一次运行之前，必须使用updatedb指令创建locate数据库 12updatedblocate hello.txt 压缩解压类1.grep指令和管道符 | 语法 grep [选项] 查找内容源文件 常用选项 -n 显示匹配行及行号 -i 忽略字母大小写 案例1.在hello.txt中查找yes所在行，并显示行号123cat hello.txt | grep -n yescat hello.txt | grep -i yescat hello.txt | grep -n -i yes 2.gzip/gunzip gzip 用于压缩文件 gunzip用于解压缩 语法gzip 文件 (只能将文件压缩为gz)gunzip 文件.gz 12gzip hello.txtgunzip hello.txt.gz 3.zip/unzipzip用于压缩文件，unzip用于解压 语法zip [选项] 文件名unzip [选项] 文件名 选项 zip -r 递归压缩 unzip -d&lt;目录&gt;：指定解压后的目录 案例 将/home下的文件压缩成mypackage.zip 1zip -r mypackage.zip /home/ 将mypackage.zip 解压到/opt/tmp目录下 1unzip -d /opt/tmp/ mypackage.zip 4.tartar指令是打包指令，最后打包后的文件是.tar.gz的文件 基本语法 tar [选项] XXX.tar.gz 选项 -c 产生.tar的打包文件 -v 显示详细信息 -f 指定压缩后的文件名 -z 打包同时压缩 -x 解包。tar文件 实例 压缩多个文件a.txt b.txt 压缩成为a.tar.gz 1tar -zcvf a.tar.gz a.txt b.txt 将home文件夹整体打包成myhome.tar.gz 1tar -zvcf myhome.tar.gz /home/ 将a.tar.gz解压到当前目录 1tar -zxvf a.tar.gz 将a.tar.gz解压到aaa目录下 12tar -zxvf a.tar.gz -C aaa//-C 必须要有否则报错]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpstorm快捷键]]></title>
    <url>%2F2019%2F06%2F20%2Fphpstorm%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Esc键编辑器（从工具窗口）F2（Shift+F2） 下/上高亮错误或警告快速定位F3 向下查找关键字出现位置F4 查找变量来源F5 复制文件/文件夹F6 移动F11 切换书签F12 返回到以前的工具窗口注意：部分快捷键，必须在没有更改快捷键的情况下才可以使用 查询快捷键CTRL+N 查找类CTRL+SHIFT+N 查找文件，打开工程中的文件(类似于eclipse中的ctrl+shift+R)，目的是打开当前工程下任意目录的文件CTRL+SHIFT+ALT+N 查 找类中的方法或变量(JS)CIRL+B 找变量的来源，跳到变量申明处CTRL+ALT+B 找所有的子类CTRL+SHIFT+B 找变量的 类CTRL+G 定位行，跳转行CTRL+F 在当前窗口查找文本CTRL+SHIFT+F 在指定路径查找文本CTRL+R 当前窗口替换文本CTRL+SHIFT+R 在指定路径替换文本ALT+SHIFT+C 查找修改的文件，最近变更历史CTRL+E 最近打开的文件F3 查找下一个SHIFT+F3 查找上一个F4 查找变量来源CTRL+ALT+F7 选 中的字符 查找工程出现的地方ALT+F7 直接查询选中的字符Ctrl+F7 文件中查询选中字符 自动代码ALT+回车 导入包,自动修正CTRL+ALT+L 格式化代码CTRL+ALT+I 自动缩进CTRL+ALT+O 优化导入的类和包CTRL+E 最近更改的文件/代码CTRL+SHIFT+SPACE 切换窗口CTRL+SPACE空格 代码自动完成，代码提示,一般与输入法冲突CTRL+ALT+SPACE 类 名或接口名提示（与系统冲突）CTRL+P 方法参数提示，显示默认参数CTRL+J 自动代码提示，自动补全CTRL+ALT+T 把选中的代码放在 TRY{} IF{} ELSE{} 里ALT+INSERT 生成代码(如GET,SET方法,构造函数等) 复制快捷方式F5 复制文件/文件夹CTRL+C 复制CTRL+V 粘贴CTRL+X 剪 切,删除行CTRL+D 复制行Ctrl + Y 删除行插入符号CTRL+SHIFT+V 可以复制多个文本 高亮CTRL+F 选中的文字,高亮显示 上下跳到下一个或者上一个F2（Shift+F2） 高亮错误或警告快速定位SHIFT+F2 高亮错误或警告快速定位CTRL+SHIFT+F7 高亮显示多个关键字.本地历史VCS/SVNAlt +反引号（’） 快速弹出VCS菜单Ctrl + K 提交项目VCSCtrl + T 更新项目从VCSAlt + Shift + C 查看最近发生的变化 其他快捷方式CTRL+Z 倒退(代码后悔)CTRL+SHIFT+Z 向前CTRL+H 显 示类结构图Ctrl +F12 文件结构弹出Ctrl+Shift+H 方法的层次结构Ctrl+Alt+H 呼叫层次CTRL+Q 显示代码注释CTRL+W 选中代码，连续按会 有其他效果Ctrl+Shift+W 减少当前选择到以前的状态CTRL+B 转到声明，快速打开光标处的类或方法说明注释(CTRL + 鼠标单击 也可以)CTRL+O 魔术方法CTRL+/ 注释//取消注释CTRL+SHIFT+/ 注释/…/CTRL+ [] 光标移动到 {}[]开头或结尾位置CTRL+SHIFT+[] 选中块代码，可以快速复制ctrl + ‘-/+’: 可以折叠项目中的任何代码块,包括htm中的任意nodetype=3的元素，function,或对象直接量等等。它不是选中折叠，而是自动识别折叠。 ctrl + ‘.’: 折叠选中的代码的代码Ctrl+Shift+U 选中的字符大小写转换ctrl+shift+i 快速查看变量或方法定义源CTRL+ALT+F12 资源管理器打开文件夹，跳转至当前文件在磁盘上的位置ALT+F1 选择当前文件或菜单中的任何视图工具栏SHIFT+ALT+INSERT 竖编辑模式 CTRL+ALT ←/→ 返回上次编辑的位置ALT+ ←/→ 切换代码视图，标签切换ALT+ ↑/↓ 在方法间快速移动定位alt + ‘7’: 显示当前的类/函数结构。类似于eclipse中的outline的效果。试验了一下，要比aptana的给力一些，但还是不能完全显示prototype下面的方法名。SHIFT+F6 重命名,重构 当前区域内变量重命名/重构不但可以重命名文件名，而且可以命名函数名，函数名可以搜索引用的文件，还可以重命名局部变量。还可以重命名标签名。在sublime text中有个类似的快捷键：ctrl+shift+d。 ctrl+shift+enter(智能完善代码 如 if())ctrl+shift+up/down(移动行、合并选中行，代码选中区域 向上/下移动)CTRL+UP/DOWN 光标跳转到编辑器显示区第一行或最后一行下ESC 光标返回编辑框SHIFT+ESC 光 标返回编辑框,关闭无用的窗口CTRL+F4 关闭当前的编辑器或选项卡 Ctrl + Alt + V引入变量Ctrl + Alt + F 类似引入变量Ctrl + Alt + C引入常量 Ctrl + Tab 键切换选项卡和工具窗口Ctrl + Shift + A 查找快捷键Alt + ＃[0-9] 打开相应的工具窗口Ctrl + Shift + F12 切换最大化编辑器Alt + Shift + F 添加到收藏夹Alt + Shift + I 检查当前文件与当前的配置文件Ctrl +反引号（`） 快速切换目前的配色/代码方案/快捷键方案/界面方案Ctrl + Alt + S 打开设置对话框（与QQ冲突） 运行Alt + Shift + F10 选择的配置和运行Alt + Shift + F9 选择配置和调试Shift + F10 运行Shift + F9调试Ctrl + Shift + F10运行范围内配置编辑器Ctrl + Shift + X运行命令行 调试F8步过F7步入Shift + F7智能进入Shift + F8步骤ALT + F9运行到光标Alt + F8计算表达式F9恢复程序Ctrl + F8切换断点Ctrl + Shift + F8查看断点 导航Shift + Esc键隐藏活动或最后一个激活的窗口Ctrl + Shift + F4关闭活动运行/消息/ / …选项卡Ctrl + Shift +Backspace键导航到最后编辑的位置Ctrl + Alt+B 到实施（S）Ctrl + Shift+I 打开快速定义查询Ctrl + U 转到super-method/super-classAlt + Home 组合显示导航栏 书签Ctrl + F11切换书签助记符Ctrl +＃[0-9]转到编号书签Shift + F11显示书签 编辑Ctrl + Q 快速文档查询ALT + INSERT 生成的代码…器（getter，setter方法，构造函数）Ctrl + O 覆盖方法Ctrl + I 实现方法 Alt + Enter 显示意图的行动和快速修复Shift + Tab 键缩进/取消缩进选中的行 Ctrl + Shift + J 智能线连接（仅适用于HTML和JavaScript）Ctrl + Enter 智能线分割（HTML和JavaScript）Shift + Enter 开始新的生产线 Ctrl + Delete 删除字（word）Ctrl + Backspace删除字开始Ctrl +小键盘+ / - 展开/折叠代码块Ctrl + Shift +小键盘+展开全部Ctrl + Shift +数字键盘关闭全部 界面中文方框问题Settings-&gt;Appearance中Theme 设置 Windows勾选Override default fonts by (not recommended)，设置字体为宋体 显示行号Settings-&gt;Editor-&gt;Appearance标签项，勾选Show line numbers 光标不随意定位Settings-&gt;Editor中去掉Allow placement of caret after end of line。 启动的时候不打开工程文件Settings-&gt;General去掉Reopen last project on startup. 无法起动Tomcat（ IntelliJ IDEA）请使用ZIP版的Tomcat 快捷键问题可以使用其他软件的快捷键，Settings-&gt;Keymap 快捷键冲突（自己修改）默认代码提示和补全快捷键跟输入法冲突，如何解决：Settings-&gt;Keymap 在上面面的图中，点击COPY ，自己新建一个方案，如 T1 然后开始设置快捷键，修改时，右击会弹出菜单，如下图，改成你想要的快捷键 用*标识编辑过的文件Editor –&gt; Editor Tabs选中Mark modifyied tabs with asterisk 编码设置：编辑器中中文乱码问题这个是项目字符编码设置错误FILE -&gt;Settings-&gt; 有3处设置根据自己需要设置IDE Encondings：IDE编码 ，选择 IDE Encoding为GBK。这边要自己去调整了Project Encoding：项目编码Default encoding for properties files：默认文件编码 编辑器中字体和大小FILE -&gt; Settings&gt; Editor-&gt;Colors &amp; Fonts -&gt; Font -&gt; 右侧Size：字体大小Line spacing：行间距下框中是字体，左侧-&gt;可选择字体，右侧-&gt;实际应用字体 显示文件夹或文件过滤File-&gt;Setting-&gt;File Types-&gt;Ignore file and folders里面填写你要的过滤不显示的注意大小写哦 当前编辑文件定位方法1) 在编辑的所选文件按ALT+F1, 然后选择PROJECT VIEW 方法2) 左侧 项目列表框 顶部的 定位图标 优化文件保存File-&gt;Settings-&gt;General-&gt;Synchronize file on frame activation：个人需要是否取消同步文件Save files on framedeactivation：取消Save files automatically：选中，设置自动保存，设置 30秒自动保存时间，这样IDEA依然可以自动保持文件,所以在每次切换时，你需要按下Ctrl+S保存文件]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>phpstorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkdownPad2安装汉化与注册码]]></title>
    <url>%2F2019%2F05%2F23%2Fmarkdown%E6%B3%A8%E5%86%8C%E6%BF%80%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[1、markdown下载地址http://www.markdownpad.com/ 2、破解密码点击 Enter KeyEmail address: Soar360@live.comLicense Key: 1GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== 3、汉化选择Option-&gt;选择设置中文重启后生效]]></content>
      <tags>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php常用方法]]></title>
    <url>%2F2019%2F05%2F23%2Fphp%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[*test1]]></content>
      <categories>
        <category>常用方法</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日记]]></title>
    <url>%2F2019%2F05%2F23%2F%E6%97%A5%E8%AE%B02019-05-23%2F</url>
    <content type="text"><![CDATA[天气：晴 &emsp;&emsp;最近工作不忙，决定提升下自己，网上下载了一些书籍，准备温习下英语，毕竟想要提升下自己的水平，英语确实是一个短板。确定一下计划，一周之后看成果吧。&emsp;&emsp;学习这种东西，最难的就是坚持。基本上一件事情要是能坚持一个月的话，就算是养成习惯了。&emsp;&emsp;打气中。。。。。。]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019/04/30]]></title>
    <url>%2F2019%2F04%2F30%2F%E6%97%A5%E8%AE%B02019-04-30%2F</url>
    <content type="text"><![CDATA[测试用的不知道好不好用]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《php和mysql Web开发》stu]]></title>
    <url>%2F2018%2F11%2F08%2F%E3%80%8Aphp%E5%92%8Cmysql%20Web%E5%BC%80%E5%8F%91%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一章 PHP快速入门1.1 安装php运行环境使用wamp安装包一间安装 1.2 创建示例web应用 Bob汽车部件商店创建一个html表单来开始学习php 1.2.1 创建订单12345&lt;form action = &quot;processorder.php&quot; method = &quot;post&quot;&gt;&lt;input type = &quot;text&quot; name = &quot;car_name&quot;/&gt;&lt;input type = &quot;text&quot; name = &quot;car_size&quot;/&gt;&lt;input type = &quot;submit&quot; value = &quot;提交&quot;/&gt;&lt;/form&gt; 这里action属性被设定为可以处理客户订单的php脚本，提交方式为post 提交方式由get(符加在url中使用)post（以单独消息的形式发送） 表单域的名称：“car_name”“car_size”将在php脚本中复用1.2.2 表单的处理 处理html页面提交过来的信息12345678&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Bob Order&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Bob Order&lt;/h1&gt;&lt;h2&gt;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 1.3 在html中嵌入php在上述代码中的h2标签中添加 123&lt;?php echo '&lt;p&gt;Order Process&lt;/p&gt;';?&gt; 这里并没有原样输出，因为php脚本解析器已经运行了php脚本1.3.1 php标记 XML风格 123&lt;?php echo '&lt;p&gt;Order Process&lt;/p&gt;';?&gt; 简短风格 123&lt;? echo '&lt;p&gt;Order Process&lt;/p&gt;';?&gt; 简短风格需要配置环境。不推荐使用1.3.2 PHP语句 将php语句放在php标记之间，就可以告诉php解析器进行何种操作，语句结束用分号表示1.3.3 空格 在php中空格tab键换行都会被认为是空格1.3.4 注释 php支持c,c++,shell脚本的注册风格123456/* * 这是c风格 */// 这是C++风格# 这是shell脚本风格 1.4 添加动态内容可以为用户提供动态的信息，下面的例子是输出当前的时间 123&lt;?php echo date('Y-m-d H:i:s');?&gt; 1.4.1 调用函数上面这个函数中引号里面的就是date函数的变量，函数根据变量内容来进行相应的输出 1.4.2 使用date()函数Y是年 m是月 d是日 H是小时 i是分钟 s是秒 1.5 访问表单变量在php中，获得客户输入的数据非常简单，但是还依赖你所使用的php版本以及php.ini文件 1.5.1 简短，中等及冗长php脚本以$符号开始，其中php变量名称必须与表单域的名称一致。 根据php版本和设置不同，通过变量访问表单数据。这些方法。 简短风格 $car_name 需要配置register_globals配置为on,不推荐使用 中等风格 $_POST[‘car_name’]比较容易使用 冗长风格 $HTTP_POST_VARS[‘car_name’] 已经被弃用 1.5.2 字符串的链接 用“.”来链接 1.5.3 变量和文本 变量是表示数据的符号，字符串是数据本身。 当我们使用原始数据时是文本，而当我们用$car_name来表示文本时则是变量 1.6 理解标识符 标识符是变量的名称 标识符可以是任何长度 标识符不能以数字开头 在php中表示符是区分大小写的 一个变量名可以与一个函数名相同，但是容易造成混淆，建议不这么写 不能建立一个已有函数同名的函数1.7 检查变量类型1.7.1 PHP的数据类型 integer(整形)————用来表示整数 Float(浮点数)————用来表示所有实数 String(字符数)————用来表示字符串 Boolean(布尔值)————用来表示true或者false Array(数组)————用来保存具有相同类型的多个数据项 Object(对象)————用来保存类的实例1.7.2 类型强度 php是弱类型强度。php将自动的落去输入的数据类型。一旦从变量中检索变量值，它将返回具有相同数据类型的数据1.7.3 类型转换 使用类型转换可以直接将一个变量或值转换成另一种类型。这种转换只需要希望进行类型转换的变量之前的圆括号中插入需要转换的零食数据 也可以用php的内置函数来测试并设置类型。1.7.4 可变变量 就是可以动态的改变变量的名称name 就是可以动态的改变变量的名称name]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>php和mysql Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php封装一个接口类]]></title>
    <url>%2F2018%2F06%2F26%2Fphp%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[php封装一个接口类 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 &lt;?php Class Response &#123; //返回数据 public static function show($code,$message=&apos;&apos;,$data=&apos;&apos;,$type = &apos;json&apos;,$callback=&apos;&apos;) &#123; if($type==&apos;json&apos;) &#123; echo self::jsonEncode($code,$message,$data); &#125;elseif($type == &apos;xml&apos;) &#123; echo self::xmlEncode($code,$message,$data); &#125;elseif($type == &apos;jsonp&apos;) &#123; echo $callback.&apos;(&apos;.self::jsonEncode($code,$message,$data).&apos;)&apos;; &#125; &#125; //json接口 public static function jsonEncode($code,$message=&apos;&apos;,$data=&apos;&apos;) &#123; if(!is_numeric($code)) &#123; return &apos;&apos;; &#125; $result = array( &apos;code&apos; =&gt; $code, &apos;message&apos; =&gt; $message, &apos;data&apos; =&gt; $data, ); header(&quot;Content-type:text/json;chaset=utf-8&quot;); return json_encode($result); &#125; //xml接口 public static function xmlEncode($code,$message,$data=array()) &#123; if(!is_numeric($code)) &#123; return &apos;&apos;; &#125; $result = array( &apos;code&apos; =&gt; $code, &apos;message&apos; =&gt; $message, &apos;data&apos; =&gt; $data, ); header(&quot;Content-type:text/xml;chaset=utf-8&quot;); $xml = &quot;&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos; ?&gt;\n&quot;; $xml .= &quot;&lt;root&gt;\n&quot;; $xml .= self::xmlToEncode($result); $xml .= &quot;&lt;/root&gt;\n&quot;; return $xml; &#125; //xml内容循环 public static function xmlToEncode($data) &#123; if(empty($data)) &#123; return &apos;&apos;; &#125; $xml = $attr = &apos;&apos;; foreach ($data as $key =&gt; $value) &#123; if(is_numeric($key)) &#123; $attr = &quot;id=&apos;&#123;$key&#125;&apos;&quot;; $key = &quot;item&quot;; &#125; $xml .= &quot;&lt;&#123;$key&#125; &#123;$attr&#125;&gt;&quot;; $xml .= is_array($value) ? self::xmlToEncode($value) : $value ; $xml .= &quot;&lt;/&#123;$key&#125;&gt;\n&quot;; &#125; return $xml; &#125; &#125; //二维数据 $type = isset($_GET[&apos;type&apos;])? $_GET[&apos;type&apos;] : &apos;json&apos;; $callback = isset($_GET[&apos;callback&apos;])? $_GET[&apos;callback&apos;] : &apos;&apos;; $arr = array( &apos;id&apos;=&gt;1, &apos;name&apos;=&gt;&apos;jia&apos;, &apos;type&apos;=&gt;array(1,2,3) ); Response::show(200,&apos;数据返回成功&apos;,$arr,$type,$callback);]]></content>
      <tags>
        <tag>技术文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟域名配置]]></title>
    <url>%2F2018%2F05%2F25%2F%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[虚拟 域名配置httpd.conf12# Virtual hosts Include conf/extra/httpd-vhosts.conf 12345678&lt;Directory &quot;e:/wamp/www/&quot;&gt; Options FollowSymLinks AllowOverride All Require all granted Order Deny,Allow Require local Allow from All&lt;/Directory&gt; httpd-vhosts.conf1234567&lt;VirtualHost *:80&gt; DocumentRoot &quot;e:/wamp/www/xx&quot; ServerName www.new.com ServerAdmin admin@example.com ErrorLog &quot;logs/dummy-host2.example.com-error.log&quot; CustomLog &quot;logs/dummy-host2.example.com-access.log&quot; common&lt;/VirtualHost&gt; hosts路径：C:\Windows\System32\drivers\etc 127.0.0.1 www.new.com]]></content>
      <tags>
        <tag>技术文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php页面跳转]]></title>
    <url>%2F2018%2F05%2F22%2Fphp%E6%A0%B9%E6%8D%AEurl%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[php根据url不同，跳转不同页面代码：123456789101112131415161718192021222324252627282930313233&lt;?php switch ($_SERVER[&quot;HTTP_HOST&quot;]) &#123; case &quot;vip2.qijiketang.com&quot;: header(&quot;Location:https://view.csslcloud.net/api/view/index?roomid=9505ABDBD6F9F4649C33DC5901307461&amp;userid=974049F493DEEDAB&quot;);break; case &quot;qjktvip.com&quot;: header(&quot;location:/toutiao/&quot;); break; case &quot;jy.xamrkj.cn&quot;: $url = $_GET[&apos;url&apos;];header(&quot;location:http://tjcaihe.com/public/index.php/home/$url&quot;); break; case &quot;chinackmc.org&quot;: header(&quot;location:/dede/&quot;); break; // default: header(&apos;location:http://www.baidu.com&apos;);&#125;]]></content>
      <tags>
        <tag>技术文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格式化数据库]]></title>
    <url>%2F2018%2F05%2F14%2F%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[清空数据表 我们在做网站的时候，测试过后的数据上线后需要删除的，但是，我们设计的表中的id一般情况下是要自动增长的，那么即使清空了我们的表单后，自增的id也不是从1开始了，怎么办呢？方法就是。。。。代码truncate table 你的表名]]></content>
      <tags>
        <tag>技术文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网游特殊文字]]></title>
    <url>%2F2018%2F04%2F11%2F%E7%BD%91%E6%B8%B8%E7%89%B9%E6%AE%8A%E6%96%87%E5%AD%97%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[丨–hhl 丶–yyl 丿–ttl 灬–OYY 纟–xxx 阝–BNH 亻–WTH 氵–IYYG 冫–UYG 冖–PYN 辶–PYNY 扌–RGH 亻–wth 氵–IYYG 讠 –YYN 冖 –PYN 匚 –AGN 卜 –HHY 彡 –ETT 辶–PYNY 厶–CNY 艹–ACH 勹–QTN 宀–PYYN 亠–YYG 弓–XNG 彳–TTH 攵–TTY 忄–NYHY 礻–PYI 大家都知道，自由幻想起名是限制特殊符号的，那么那些有特殊符号的名字是怎么起的呢?现在就来教大家使用特殊名字: 能使用的特殊符号有: 乄 丨 丶 卍 尐 灬 卩 刂 阝 肀 忄 冫 丿 氵 彡 丬 有人要问，如何打出?其实很多都是用全拼输入法打出的 全拼 wu 乄 全拼 gun 丨 全拼 zhu 丶 全拼 wan 卍 全拼 ji 尐 全拼 pianpang 灬 卩 刂 阝 肀 忄 冫 丿 氵 彡 丬 (还有更多) 犭、礻、衤、革、骨、黑]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php学习导向]]></title>
    <url>%2F2018%2F03%2F22%2Fphp%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[路线图 THML5 PHP 3小时光速入门 PHP 基础 MYSQL 基础 PHP 操作MYSQL 案例 留言板 javascript 基础 许愿墙 PHP 加强 MYSQL 加强 Blog 项目实战 面向对象 Smarty 正则 HTTP协议 ThinkPHP商城实战 javascript AJAX jquery linux nginx svn git bootstrap HTML5深入 memcached 集群 设计模式 javascript 高级 mysql 优化 x框架]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解jq的each()遍历]]></title>
    <url>%2F2018%2F01%2F18%2F%E8%AF%A6%E8%A7%A3jq%E7%9A%84each()%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[html代码 123456789101112131415161718192021222324252627&lt;!doctype&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;遍历&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; integrity=&quot;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;content&quot;&gt; &lt;ul&gt; &lt;li&gt;一&lt;/li&gt; &lt;li&gt;二&lt;/li&gt; &lt;li&gt;三&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;四&lt;/li&gt; &lt;li&gt;五&lt;/li&gt; &lt;li&gt;六&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot; integrity=&quot;sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; js 依此点击li输出 0 1 2 3 4 5 12345678$(function()&#123; // 依次点击li 输出 0 1 2 3 4 5 $(&apos;li&apos;).each(function(index)&#123; $(this).click(function()&#123; console.log(index) &#125;) &#125;)&#125;) 依次点击li输出 0 1 2 0 1 2 12345678$(function()&#123; // 一次点击li输出 0 1 2 0 1 2 $(&apos;li&apos;).each(function()&#123; $(this).click(function()&#123; console.log($(this).index()); &#125;) &#125;)&#125;)]]></content>
      <tags>
        <tag>jq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5用户禁止缩放]]></title>
    <url>%2F2018%2F01%2F16%2Fhtml5%E7%A6%81%E6%AD%A2%20%E7%94%A8%E6%88%B7%E7%BC%A9%E6%94%BE%2F</url>
    <content type="text"><![CDATA[html5用户禁止缩放 代码 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt; 说明 width —— viewport的宽度 height —— viewport的高度 initial-scale —— 初始的缩放比例 minimum-scale —— 允许用户缩放到的最小比例 maximum-scale —— 允许用户缩放到的最大比例 user-scalable —— 用户是否可以手动缩放]]></content>
      <tags>
        <tag>技术文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js返回顶部]]></title>
    <url>%2F2018%2F01%2F12%2Fjs%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8%2F</url>
    <content type="text"><![CDATA[返回顶部js先加载jq1&lt;script src=&quot;http://libs.baidu.com/jquery/1.11.1/jquery.min.js&quot;&gt;&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;script&gt;var scrolltotop=&#123; setting:&#123; startline:100, //起始行 scrollto:0, //滚动到指定位置 scrollduration:400, //滚动过渡时间 fadeduration:[500,100] //淡出淡现消失 &#125;, controlHTML:&apos;&lt;img src=&quot;top.png&quot; style=&quot;width:53px; height:53px; border:0;&quot; /&gt;&apos;, //返回顶部按钮 controlattrs:&#123;offsetx:0,offsety:323&#125;,//返回按钮固定位置 anchorkeyword:&quot;#top&quot;, state:&#123; isvisible:false, shouldvisible:false &#125;,scrollup:function()&#123; if(!this.cssfixedsupport)&#123; this.$control.css(&#123;opacity:0&#125;); &#125; var dest=isNaN(this.setting.scrollto)?this.setting.scrollto:parseInt(this.setting.scrollto); if(typeof dest==&quot;string&quot;&amp;&amp;jQuery(&quot;#&quot;+dest).length==1)&#123; dest=jQuery(&quot;#&quot;+dest).offset().top; &#125;else&#123; dest=0; &#125; this.$body.animate(&#123;scrollTop:dest&#125;,this.setting.scrollduration); &#125;,keepfixed:function()&#123; var $window=jQuery(window); var controlx=$window.scrollLeft()+$window.width()-this.$control.width()-this.controlattrs.offsetx; var controly=$window.scrollTop()+$window.height()-this.$control.height()-this.controlattrs.offsety; this.$control.css(&#123;left:controlx+&quot;px&quot;,top:controly+&quot;px&quot;&#125;); &#125;,togglecontrol:function()&#123; var scrolltop=jQuery(window).scrollTop(); if(!this.cssfixedsupport)&#123; this.keepfixed(); &#125; this.state.shouldvisible=(scrolltop&gt;=this.setting.startline)?true:false; if(this.state.shouldvisible&amp;&amp;!this.state.isvisible)&#123; this.$control.stop().animate(&#123;opacity:1&#125;,this.setting.fadeduration[0]); this.state.isvisible=true; &#125;else&#123; if(this.state.shouldvisible==false&amp;&amp;this.state.isvisible)&#123; this.$control.stop().animate(&#123;opacity:0&#125;,this.setting.fadeduration[1]); this.state.isvisible=false; &#125; &#125; &#125;,init:function()&#123; jQuery(document).ready(function($)&#123; var mainobj=scrolltotop; var iebrws=document.all; mainobj.cssfixedsupport=!iebrws||iebrws&amp;&amp;document.compatMode==&quot;CSS1Compat&quot;&amp;&amp;window.XMLHttpRequest; mainobj.$body=(window.opera)?(document.compatMode==&quot;CSS1Compat&quot;?$(&quot;html&quot;):$(&quot;body&quot;)):$(&quot;html,body&quot;); mainobj.$control=$(&apos;&lt;div id=&quot;topcontrol&quot;&gt;&apos;+mainobj.controlHTML+&quot;&lt;/div&gt;&quot;).css(&#123;position:mainobj.cssfixedsupport?&quot;fixed&quot;:&quot;absolute&quot;,top:mainobj.controlattrs.offsety,right:mainobj.controlattrs.offsetx,opacity:0,cursor:&quot;pointer&quot;&#125;).attr(&#123;title:&quot;返回顶部&quot;&#125;).click(function()&#123;mainobj.scrollup();return false;&#125;).appendTo(&quot;body&quot;);if(document.all&amp;&amp;!window.XMLHttpRequest&amp;&amp;mainobj.$control.text()!=&quot;&quot;)&#123;mainobj.$control.css(&#123;width:mainobj.$control.width()&#125;);&#125;mainobj.togglecontrol(); $(&apos;a[href=&quot;&apos;+mainobj.anchorkeyword+&apos;&quot;]&apos;).click(function()&#123;mainobj.scrollup();return false;&#125;); $(window).bind(&quot;scroll resize&quot;,function(e)&#123;mainobj.togglecontrol();&#125;); &#125;); &#125;&#125;;scrolltotop.init();&lt;/script&gt; 用的时候直接复制到网页上就好了]]></content>
      <tags>
        <tag>技术文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机内存卡无法格式话]]></title>
    <url>%2F2017%2F12%2F28%2F%E6%89%8B%E6%9C%BA%E5%86%85%E5%AD%98%E5%8D%A1%E6%97%A0%E6%B3%95%E6%A0%BC%E5%BC%8F%E8%AF%9D--%E8%9B%8B%E7%96%BC%E7%9A%84%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[真心蛋疼今天注定是一个不平凡的一天，耳边听着许巍的救赎之旅，心里一点都不平静。。。。。 这一切是从昨天开始的，支付宝红包周周乐，晚上八点开奖。我一脸期待的看着美女主播，在哪里介绍着开奖过程，突然眼前一黑，我的三星小5，终于在还有一半电的时候，又一次的黑屏了，之所以说又，那是因为之前很多次这样了，我轻车熟路的拿出充电器，把手机冲上电，开机。 一切都是那么的熟悉，熟悉的开机画面，熟悉的味道（正在吃饭）。可是让我没有想到的是，手机中的程序挂了一大半，我有点蒙了，赶忙放下筷子。仔细的拿起手机，找起了原因，果然当我看到内存卡那里的时候，显示已损坏。。。。 呵呵，因为以前遇到过这种问题，只要把他放到电脑里格式化一下就好了，so easy! 然而，理想是丰满的，现实是骨感的。当我看着眼前的电脑提示框，也是愣住了。“windows无法完成格式化”，这是什么鬼，难不成我一直崇拜的伟大的windows也有不行的时候吗？不，一定不是这样。 倔强的我，又一次进入的我们大家都嗤之以鼻，但是又不能没有的那个“度娘”，有点时候，没有答案并不可怕，可怕的是满山遍野的答案，结果没有一个管用的。就这样。。。。。折腾半天，时间已经到了半夜2点。带着一丝的不甘，最终还是睡去了。。 今天养精蓄锐，心里想着一定要把这个解决掉。因为心里还是觉得这个问题应该是可以解决的。果然，我心血来潮的手动删除了一下，竟然把内存卡中的内容删掉了。哈哈，赶紧格式化一下，这可是一个好的开头，但是，让我没想到的是，刚删掉的东西，在电脑提示了“windows无法完成格式化”之后，竟然有奇迹般的恢复了，好吧，于是又踏上了慢慢的百度之路。。。。 最终,好吧，再见我的手机内存卡。]]></content>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wget用法详解]]></title>
    <url>%2F2017%2F12%2F25%2Fwget%2F</url>
    <content type="text"><![CDATA[需要下载某个目录下面的所有文件。命令如下1wget -c -r -p -np -k 网址 参数说明 -c – 断点续传 -r – 会按照递归的方法，下载服务器上所有的目录和文件，要注意的是，下载网站指向的所有地址同样会被下载下来 -p – 下载网页所有文件，图片等 -np – 递归下载的时候不会下载上一级的目录 -k – 将目标网站的相对链接转为绝对链接 更多： 启动 -V, –version 显示wget的版本后退出 -h, –help 打印语法帮助 -b, –background 启动后转入后台执行 -e, –execute=COMMAND 执行`.wgetrc’格式的命令，wgetrc格式参见/etc/wgetrc或~/.wgetrc 记录和输入文件 -o, –output-file=FILE 把记录写到FILE文件中 -a, –append-output=FILE 把记录追加到FILE文件中 -d, –debug 打印调试输出 -q, –quiet 安静模式(没有输出) -v, –verbose 冗长模式(这是缺省设置) -nv, –non-verbose 关掉冗长模式，但不是安静模式 -i, –input-file=FILE 下载在FILE文件中出现的URLs -F, –force-html 把输入文件当作HTML格式文件对待 -B, –base=URL 将URL作为在-F -i参数指定的文件中出现的相对链接的前缀 –sslcertfile=FILE 可选客户端证书 –sslcertkey=KEYFILE 可选客户端证书的KEYFILE –egd-file=FILE 指定EGD socket的文件名 下载 –bind-address=ADDRESS 指定本地使用地址(主机名或IP，当本地有多个IP或名字时使用) -t, –tries=NUMBER 设定最大尝试链接次数(0 表示无限制). -O –output-document=FILE 把文档写到FILE文件中 -nc, –no-clobber 不要覆盖存在的文件或使用.#前缀 -c, –continue 接着下载没下载完的文件 –progress=TYPE 设定进程条标记 -N, –timestamping 不要重新下载文件除非比本地文件新 -S, –server-response 打印服务器的回应 –spider 不下载任何东西 -T, –timeout=SECONDS 设定响应超时的秒数 -w, –wait=SECONDS 两次尝试之间间隔SECONDS秒 –waitretry=SECONDS 在重新链接之间等待1…SECONDS秒 –random-wait 在下载之间等待0…2*WAIT秒 -Y, –proxy=on/off 打开或关闭代理 -Q, –quota=NUMBER 设置下载的容量限制 –limit-rate=RATE 限定下载输率 目录 -nd –no-directories 不创建目录 -x, –force-directories 强制创建目录 -nH, –no-host-directories 不创建主机目录 -P, –directory-prefix=PREFIX 将文件保存到目录 PREFIX/… –cut-dirs=NUMBER 忽略 NUMBER层远程目录 HTTP 选项 –http-user=USER 设定HTTP用户名为 USER. –http-passwd=PASS 设定http密码为 PASS. -C, –cache=on/off 允许/不允许服务器端的数据缓存 (一般情况下允许). -E, –html-extension 将所有text/html文档以.html扩展名保存 –ignore-length 忽略 Content-Length&#39;头域 --header=STRING 在headers中插入字符串 STRING --proxy-user=USER 设定代理的用户名为 USER --proxy-passwd=PASS 设定代理的密码为 PASS --referer=URL 在HTTP请求中包含Referer: URL’头 -s, –save-headers 保存HTTP头到文件 -U, –user-agent=AGENT 设定代理的名称为 AGENT而不是 Wget/VERSION. –no-http-keep-alive 关闭 HTTP活动链接 (永远链接). –cookies=off 不使用 cookies. –load-cookies=FILE 在开始会话前从文件 FILE中加载cookie –save-cookies=FILE 在会话结束后将 cookies保存到 FILE文件中 FTP 选项 -nr, –dont-remove-listing 不移走 `.listing’文件 -g, –glob=on/off 打开或关闭文件名的 globbing机制 –passive-ftp 使用被动传输模式 (缺省值). –active-ftp 使用主动传输模式 –retr-symlinks 在递归的时候，将链接指向文件(而不是目录) 递归下载 -r, –recursive 递归下载－－慎用! -l, –level=NUMBER 最大递归深度 (inf 或 0 代表无穷). –delete-after 在现在完毕后局部删除文件 -k, –convert-links 转换非相对链接为相对链接 -K, –backup-converted 在转换文件X之前，将之备份为 X.orig -m, –mirror 等价于 -r -N -l inf -nr. -p, –page-requisites 下载显示HTML文件的所有图片 递归下载中的包含和不包含(accept/reject) -A, –accept=LIST 分号分隔的被接受扩展名的列表 -R, –reject=LIST 分号分隔的不被接受的扩展名的列表 -D, –domains=LIST 分号分隔的被接受域的列表 –exclude-domains=LIST 分号分隔的不被接受的域的列表 –follow-ftp 跟踪HTML文档中的FTP链接 –follow-tags=LIST 分号分隔的被跟踪的HTML标签的列表 -G, –ignore-tags=LIST 分号分隔的被忽略的HTML标签的列表 -H, –span-hosts 当递归时转到外部主机 -L, –relative 仅仅跟踪相对链接 -I, –include-directories=LIST 允许目录的列表 -X, –exclude-directories=LIST 不被包含目录的列表 -np, –no-parent 不要追溯到父目录]]></content>
      <tags>
        <tag>技术文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown]]></title>
    <url>%2F2017%2F12%2F14%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[markdown自从知道了有markdown这个之后，突然觉得原来写东西可以这么的happy! 编辑器篇至于编辑器我用过一些，最终选择了markdownpad 2，因为他真的很好用啊。 下载地址 飞机 设置 刚安装完之后是英文版的。想更换成中文版则： 想设置代码样式，从这里更改： 修改markdown样式，则这样： 我就是按照这个样式修改的 破解 邮件地址Soar360@live.com 授权码 GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== 网页版markdown插件推荐一个好用的markdown插件：chorme有一个插件叫做markdown here，安装后，在图文消息区域，按下快捷键 CTRL+ALT+M 即可。 值得开心的一件事是火狐也有这个插件，直接火狐浏览器插件搜索]]></content>
      <tags>
        <tag>技术文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 常用操作（持续更新中。。。）]]></title>
    <url>%2F2017%2F11%2F22%2Fgit%E7%94%A8%E6%B3%95%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、git全局设置git config --global user.name &quot;用户名&quot; git config --global user.email &quot;用户邮箱&quot; 二、创建git仓库git init ----创建空白版本库 touch README.md ----创建readme文件 git commit -m &quot;first commit&quot; ----委托管理 git remote add origin https://gitee.com/mr-9/1121.git ----添加远程仓库地址 git push -u origin master ----将本地的master分支推送到origin主机，同时制定origin为默认主机，之后可以不加参数直接push 三、关于远程仓库和本地仓库代码冲突的问题1、使用强制push的方法git push -u origin master -f 这样会导致远程修改丢失，一般是不可取的，尤其是多人开发的时候 2、push前先将远程仓库的修改pull下来git pull origin master git push -u origin master 3、若不想合并远程和本地修改，可以先创建新的分支git branch [name] 然后push git push -u origin [name] 4、若远程仓库和本地仓库都有修改 把远程仓库master分支下载到本地并存为 test 分支 git fetch origin master:test 查看test分支和本地分支有什么不同 git diff test 将test分支和本地的master分支合并 git merge test 这个时候本地和远程仓库就没有冲突了 git push 删除test分支 git branch -d test]]></content>
      <tags>
        <tag>技术文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二级联动菜单]]></title>
    <url>%2F2017%2F11%2F20%2F%E4%BA%8C%E7%BA%A7%E8%81%94%E5%8A%A8%E8%8F%9C%E5%8D%95%20js%2F</url>
    <content type="text"><![CDATA[##二级联动菜单 js写二级联动菜单 html代码&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;表单联动&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;表单联动&lt;/h1&gt; &lt;form action=&quot;&quot;&gt; 请选择城市： &lt;select name=&quot;parent&quot; id=&quot;parent&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; 请选择区县： &lt;select name=&quot;child&quot; id=&quot;child&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;/select&gt; &lt;/form&gt; &lt;script&gt; var parent = document.getElementById(&apos;parent&apos;), parentData = [ {code: 0, value: &apos;请选择&apos;}, {code: 1, value: &apos;北京&apos;}, {code: 2, value: &apos;上海&apos;}, {code: 3, value: &apos;深圳&apos;} ], child = document.getElementById(&apos;child&apos;), childData = [ [&apos;请选择&apos;], [&apos;海淀区&apos;, &apos;朝阳区&apos;, &apos;丰台区&apos;, &apos;石景山区&apos;, &apos;通州区&apos;, &apos;顺义区&apos;], [&apos;黄埔区&apos;, &apos;浦东区 &apos;, &apos;长宁区&apos;, &apos;宝山区 &apos;, &apos;杨浦区&apos;, &apos;嘉定区&apos;,&apos;虹口区&apos;], [&apos;罗湖区&apos;, &apos;福田区 &apos;, &apos;南山区&apos;, &apos;保安新区 &apos;, &apos;光明新区&apos;] ]; add(parent,parentData,child, childData) function add(parent,parentData,child, childData){ var num=parentData.length for(var j=1;j&lt;num;j++){ var opt=document.createElement(&quot;option&quot;) opt.innerHTML=parentData[j].value opt.setAttribute(&apos;value&apos;,parentData[j].value) var i = parent.appendChild(opt) console.log(i); } } function linkage(j,elem,Data){ elem.innerHTML=&apos;&apos; var numchilad=Data[j].length for(var i=0;i&lt;numchilad;i++){ var opt=document.createElement(&quot;option&quot;) console.log(opt); opt.innerHTML=Data[j][i] opt.style.value=Data[j][i] elem.appendChild(opt) } } parent.setAttribute(&apos;onchange&apos;,&apos;linkage(this.selectedIndex,child,childData)&apos;) &lt;/script&gt; &lt;/body&gt;]]></content>
      <tags>
        <tag>技术文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片懒加载jq版]]></title>
    <url>%2F2017%2F11%2F16%2F%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%20jq%E7%89%88%2F</url>
    <content type="text"><![CDATA[图片懒加载jq版一. 引入jq文件 &lt;script src=&quot;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; 二. 引入jq代码 &lt;script type=&quot;text/javascript&quot;&gt; //调用 visibleImgLazyload(); //触发滚动 防止第一屏不加载 $(&quot;body,html&quot;).scrollTop(1); /** * 可视区域 img 加载 */ function visibleImgLazyload() { //当前窗口高度 var winHeight = $(window).height(); //整个文档高度 var bodyHeight = $(document).height(); //如果图片不满屏，直接加载 if(bodyHeight &lt;= winHeight) { $(&quot;img&quot;).each(function() { var $this = $(this); if($this.attr(&quot;data-url&quot;) != $this.attr(&quot;src&quot;)) { //如果为空，src设置为data-src if($this.attr(&quot;data-src&quot;)) { $this.attr(&quot;src&quot;, $this.attr(&quot;data-src&quot;)); } else { $this.attr(&quot;data-src&quot;, $this.attr(&quot;src&quot;)); } } }); } else { //容差值 预加载上下100像素内的图片 var phase = 100; $(document).on(&quot;scroll&quot;, function(e) { $(&quot;img&quot;).each(function() { var $this = $(this); //窗口的高度+看不见的顶部的高度=屏幕低部距离最顶部的高度 var thisButtomTop = parseInt($(window).height()) + parseInt($(window).scrollTop()); //屏幕顶部距离最顶部的高度 减去图片高度，上拉时也会点到图片就加载 var thisTop = parseInt($(window).scrollTop()) - parseInt($this.height()); var imgTop = parseInt($this.offset().top); if(imgTop &gt;= thisTop - phase &amp;&amp; imgTop &lt;= thisButtomTop + phase &amp;&amp; $this.attr(&quot;data-url&quot;) != $this.attr(&quot;src&quot;)) { //如果为空，src设置为data-src if($this.attr(&quot;data-src&quot;)) { $this.attr(&quot;src&quot;, $this.attr(&quot;data-src&quot;)); } else { $this.attr(&quot;data-src&quot;, $this.attr(&quot;src&quot;)); } } }); }); } } &lt;/script&gt; 用法比较简单 给图片地址赋给data-src，注意图片src不用为空。。。]]></content>
      <tags>
        <tag>技术文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一款好用的图片占位符]]></title>
    <url>%2F2017%2F11%2F10%2F%E4%B8%80%E6%AC%BE%E5%A5%BD%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E5%8D%A0%E4%BD%8D%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[一款好用的图片占位符&#12288;&#12288;前端开发的时候，很多情况下素材并没有准备好，或者说需要根据网站的显示效果给客户展示需要什么样的素材图片。而这个时候，图片占位符就很好用了。&#12288;&#12288;这里介绍一个非常好用的图片占位符插件–holder。加入图片soEasy 只需要引入jq和holder.js 然后再想要图片的地方按照下面这样来写 &lt;img data-src=&quot;holder.js/300x200&quot;&gt; 300*200表示插入图片大小，这里是单位是像素 想要换颜色等操作也是很简单的， 提供6个颜色可以选择 这里的颜色可以随机展示 这样我们想到好的布局，就不用为了没有图片而发愁了，当然。如果有设计图那么更好了哈。]]></content>
      <tags>
        <tag>技术文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[雪花飘落jq]]></title>
    <url>%2F2017%2F11%2F09%2F%E9%9B%AA%E8%8A%B1%E9%A3%98%E8%90%BDjq%2F</url>
    <content type="text"><![CDATA[html代码&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;飘雪轮播&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt; &lt;/head&gt; &lt;body class=&quot;wrap&quot;&gt; &lt;div class=&quot;igs&quot;&gt; &lt;div class=&quot;ig&quot;&gt;&lt;img src=&quot;1.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;ig&quot;&gt;&lt;img src=&quot;2.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;ig&quot;&gt;&lt;img src=&quot;3.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;ig&quot;&gt;&lt;img src=&quot;4.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;ig&quot;&gt;&lt;img src=&quot;5.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;http://ajax.aspnetcdn.com/ajax/jquery/jquery-1.11.3.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;style.js&quot;&gt;&lt;/script&gt; &lt;/html&gt; js代码$(function(){ var i = 0; $(&apos;.ig&apos;).eq(0).show().siblings().hide(); $(&apos;.ig&apos;).on(&apos;click&apos;,function(){ i++; if(i == $(&apos;.ig&apos;).length){ var back = &apos;&lt;div class=&quot;back&quot;&gt; \&gt;\&gt; &lt;/div&gt;&apos;; $(&apos;.igs&apos;).append(back); $(&apos;.back&apos;).on(&apos;click&apos;,function(){ i=0; $(&apos;.back&apos;).remove(); $(&apos;.ig&apos;).eq(i).fadeIn(100).siblings().fadeOut(100); }) } $(&apos;.ig&apos;).eq(i).fadeIn(100).siblings().fadeOut(100); }) var snow = &apos;&lt;div class=&quot;snow&quot;&gt;❅&lt;/div&gt;&apos;; setInterval(function(){ var f = $(window).width(); //获取浏览器宽度 var h = $(window).height(); //获取浏览器高度 var e = Math.random()*f; //获取根据浏览器的随机值 var fon = 50+Math.random()*50; //获取雪花的大小 var l = e - 200 + 400 * Math.random(); //结束后的距离 var k = 2000 + 5000 * Math.random(); //获取下落的速度 $(snow).clone().appendTo(&quot;body&quot;).css({ top:0, left:e+&quot;px&quot;, opacity:1, &quot;font-size&quot;:fon, }).animate({ top:h+&quot;px&quot;, left:l+&quot;px&quot;, opacity:0.1, },k,&quot;linear&quot;,function(){$(this).remove()}) },200) }) css代码*{ margin:0; padding:0; } body{ background:black; overflow: hidden; font-size: 14px; } .igs{ position:relative; width:500px; height:700px; top:10px; left:100px; } .igs img{ width:100%; display: block; position: absolute; border:2px solid #A8A6CA; } .ig{ position: relative; } .back { background: #3A3838; position: absolute; right: 10px; bottom: 10px; padding: 10px; width: 30px; text-align: center; font-size: inherit; color: #fff; } .snow{ position:absolute; text-align: center; color:#fff; }]]></content>
      <tags>
        <tag>技术文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js页面自动刷新，再也不用f5了]]></title>
    <url>%2F2017%2F11%2F07%2Fjs%E9%A1%B5%E9%9D%A2%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%EF%BC%8C%E5%86%8D%E4%B9%9F%E4%B8%8D%E7%94%A8f5%E4%BA%86%2F</url>
    <content type="text"><![CDATA[js页面自动刷新，再也不用f5了&#12288;&#12288;我们在前端开发的过程中，经常会遇到这种事情，修改完一处之后想要看到效果，不得不刷新页面,如果经常性的这样重复工作，不免会让人很烦躁。。。。。。前端怎么能这么无趣。 福利来了。。。用js就可以简单实现 页面自动刷新代码head部分&lt;meta http-equiv=&quot;refresh&quot; content=&quot;20&quot;&gt; 将上面代码加到head区，20是指20秒 页面跳转&lt;meta http-equiv=&quot;refresh&quot; content=&quot;20;url=http://www.xxxx.com&quot;&gt; 上面的代码是说20秒后跳转到xxxx的页面 js页面自动刷新&lt;script language=&quot;JavaScript&quot;&gt; function myrefresh() { window.location.reload(); } setTimeout(&apos;myrefresh()&apos;,1000); //指定1秒刷新一次 &lt;/script&gt; js刷新框架 刷新包含该框架的页面用 &lt;script language=JavaScript&gt; parent.location.reload(); &lt;/script&gt; 子窗口刷新父窗口 &lt;script language=JavaScript&gt; self.opener.location.reload(); &lt;/script&gt; 或者： &lt;a href=&quot;javascript:opener.location.reload()&quot;&gt;刷新&lt;/a&gt; 刷新另一个框架的页面 &lt;script language=JavaScript&gt; parent.另一FrameID.location.reload(); &lt;/script&gt; 关闭或者打开窗口的时候刷新 &lt;body onload=&quot;opener.location.reload()&quot;&gt;开窗时刷新 &lt;body onUnload=&quot;opener.location.reload()&quot;&gt;关闭时刷新 &lt;script language=&quot;javascript&quot;&gt; window.opener.document.location.reload() &lt;/script&gt; 小结：可能有人会说我用的sublime，有插件很好用LiveReload &#12288;&#12288;配置教程传送 可是有很多的人用的别的开发工具，用 记事本的飘过。。 ++最后要说我分享我快乐！！++]]></content>
      <tags>
        <tag>技术文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号分享&jssdk]]></title>
    <url>%2F2017%2F11%2F02%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%88%86%E4%BA%ABjssdk%2F</url>
    <content type="text"><![CDATA[微信公众号分享&amp;jssdk &#12288;&#12288;最近遇到了网页的分享到微信的需求，想着之前做过，所以就没有放在心上，可谁知鼓捣了半天，还是那丑陋的分享链接。没有办法，只能自己百度找各种原因，不出所料，很多都是垃圾，在众多垃圾中找一个自己需要的还真是不容啊。花费了半天，终于知道了什么原因。。。可是时间就是金钱啊，没有办法，自己决定总结一下，方便自己以后能够用起来有个参考。 一、登录自己的微信公众号平台，完成相应的配置 登录你的微信平台，点击“公众号设置”。 点击“功能设置”，然后点击“设置”。 填写js安全域名，这里填写的是一级域名，即不带www的，如xxx.com ==注意：js安全域名一个月只能修改三次，而且一个公众号最只能设置三个安全域名== 下载demo 将里面的jssdk.php access_token.php jsapi_ticket.php三个文件复制到引用文件的同目录根据demo的sample.php按照自己的appid 和appsecret引入到自己的文件中 12345&lt;?phprequire_once &quot;jssdk.php&quot;;$jssdk = new JSSDK(&quot;yourAppID&quot;, &quot;yourAppSecret&quot;);$signPackage = $jssdk-&gt;GetSignPackage();?&gt; 引入js文件，在需要调用接口的页面引入js文件 分享接口 wx.config({ debug: false, appId: &apos;&lt;?php echo $signPackage[&quot;appId&quot;];?&gt;&apos;, timestamp: &lt;?php echo $signPackage[&quot;timestamp&quot;];?&gt;, nonceStr: &apos;&lt;?php echo $signPackage[&quot;nonceStr&quot;];?&gt;&apos;, signature: &apos;&lt;?php echo $signPackage[&quot;signature&quot;];?&gt;&apos;, jsApiList: [ //需要使用的网页服务接口 &apos;checkJsApi&apos;, //判断当前客户端版本是否支持指定JS接口 &apos;onMenuShareTimeline&apos;, //分享给好友 &apos;onMenuShareAppMessage&apos;, //分享到朋友圈 &apos;onMenuShareQQ&apos;, //分享到QQ &apos;onMenuShareWeibo&apos; //分享到微博 ] }); wx.ready(function () { //ready函数用于调用API，如果你的网页在加载后就需要自定义分享和回调功能，需要在此调用分享函数。//如果是微信游戏结束后，需要点击按钮触发得到分值后分享，这里就不需要调用API了，可以在按钮上绑定事件直接调用。因此，微信游戏由于大多需要用户先触发获取分值，此处请不要填写如下所示的分享API wx.onMenuShareTimeline({ //例如分享到朋友圈的API title: &apos;&apos;, // 分享标题 link: &apos;&apos;, // 分享链接 imgUrl: &apos;&apos;, // 分享图标 success: function () { // 用户确认分享后执行的回调函数 }, cancel: function () { // 用户取消分享后执行的回调函数 } }); wx.onMenuShareAppMessage({ title: &apos;&apos;, // 分享标题 desc: &apos;&apos;, // 分享描述 link: &apos;&apos;, // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: &apos;&apos;, // 分享图标 type: &apos;&apos;, // 分享类型,music、video或link，不填默认为link dataUrl: &apos;&apos;, // 如果type是music或video，则要提供数据链接，默认为空 success: function () { // 用户确认分享后执行的回调函数 }, cancel: function () { // 用户取消分享后执行的回调函数 } }); });]]></content>
      <tags>
        <tag>技术文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jq获取连接参数]]></title>
    <url>%2F2017%2F10%2F27%2Fjq%E8%8E%B7%E5%8F%96%E8%BF%9E%E6%8E%A5%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[jq获取连接参数jq获取地址中的参数很简单 正则表达式获取地址栏参数function GetQueryString(name) { var reg = new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;=([^&amp;]*)(&amp;|$)&quot;); var r = window.location.search.substr(1).match(reg); if(r!=null)return unescape(r[2]); return null; } alert(GetQueryString(&quot;参数名1&quot;)); alert(GetQueryString(&quot;参数名2&quot;)); alert(GetQueryString(&quot;参数名3&quot;)); 下面举个例子若地址栏URL为：abc.html?id=123&amp;url=http://www.baidu.com那么，但你用上面的方法去调用：alert(GetQueryString(“url”));则会弹出一个对话框：内容就是 http://www.baidu.com如果用：alert(GetQueryString(“id”));那么弹出的内容就是 123 啦；当然如果你没有传参数的话，比如你的地址是abc.html后面没有参数，那强行输出调用结果有的时候会报错：所以我们要加一个判断 ，判断我们请求的参数是否为空，首先把值赋给一个变量： var myurl=GetQueryString(&quot;url&quot;); if(myurl !=null &amp;&amp; myurl.toString().length&gt;1) { alert(GetQueryString(&quot;url&quot;)); }]]></content>
      <tags>
        <tag>技术文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html空格占位符]]></title>
    <url>%2F2017%2F10%2F25%2Fhtml%20%E7%A9%BA%E6%A0%BC%E5%8D%A0%E4%BD%8D%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[&amp;#32; == 普通的英文半角空格 &amp;#160; == &amp;nbsp; == &amp;#xA0; == no-break space （普通的英文半角空格但不换行） &amp;#12288; == 中文全角空格 （一个中文宽度） &amp;#8194; == &amp;ensp; == en空格 （半个中文宽度） &amp;#8195; == &amp;emsp; == em空格 （一个中文宽度） &amp;#8197; == 四分之一em空格 （四分之一中文宽度）]]></content>
      <tags>
        <tag>技术文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oa系统1]]></title>
    <url>%2F2017%2F10%2F19%2F20171019%2F</url>
    <content type="text"><![CDATA[项目需求 1、无限极分类模块（开始隐藏，点击折叠展开）2、日志编写（点击目录弹出展示）3、具有录入，编辑，删除，展示功能4、需要有登录，注销功能5、个人用户只能看到自己添加的日志，可以对自己的日志进行编辑添加删除功能6、群主用户 包含上面所有功能，且可以进行栏目的添加，修改，删除。并且可以看到所有人的日志，并且可以修改，删除，添加。7、管理员 包括以上所有功能，且能够进行个人用户，管理员的级别调整，且可以备份数据库，等操作 20171019 完成 “分类编辑”的列表页面和添加页面 完成 “分类编辑”的添加控制器完成 -遍历上级栏目 完成 “分类编辑”的列表控制器 完成编辑页面控制器 遍历上级栏目 完善页面 完成删除栏目控制器]]></content>
      <tags>
        <tag>工作日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用git提交到码云]]></title>
    <url>%2F2017%2F10%2F18%2Fgit%E4%BD%BF%E7%94%A8%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[使用git提交到码云git的配置方法 一、git安装 下载安装git 二、配置方法 右键在文件夹上点击Git Bash 配置自己的用户名和邮箱git config –global uer.name “你的用户名”git config –global user.email “你的邮箱” 生成并部署SSH key公钥ssh-keygen -t rsa -C “xxxxx@xxxxx.com“输入之后，一直按回车。则生成在默认目录中。 查看生成的SSH keycat ~/.ssh/id_rsa.pub 在c:/Users/“你的用户名”/.ssh路径下，找到id_rsa.pub文件复制里面的全部内容 将SSH key添加到码云中进入码云，修改资料选项在左边找到SSH key公钥选项，标题随便写一个，例如key one 然后将复制的ssh key粘贴到ssh key中，点确定，就配置好了。 三、小试牛刀 码云上面新建一个仓库 获取git地址 在需要提交的文件夹上面右键，选择Git Bash Here 输入命令行 git init ———-初始化git仓库 git remote add origin 你的项目地址 git add . ——–将项目中的所有文件上传 git commit -m ‘对上传文件的注释’ git push origin master 正式上传至码云中，若上传有问题，可以试试git push origin master -f表示舍弃线上的文件，强制推送]]></content>
      <tags>
        <tag>笔记,git,码云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年10月17日]]></title>
    <url>%2F2017%2F10%2F17%2F20171017%2F</url>
    <content type="text"><![CDATA[开篇这是一个序 作为一个每天15个小时以上坐在电脑面前的人来说，第一次知道有mardown这个写作神器还真心不容易。心血来潮也来尝试一下，算是作为之前的不作为的一点补偿吧。 &emsp;&emsp;刚开始用还是有些不太习惯，很多的用法，还有一些标记不太会用。不知道什么时候能够习惯这种用法了。 &emsp;&emsp;看了一些文档，mark一下。 Markdown语法说明 Markdow新手指南 Markdown简介 Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 —— 百度百科 一些常用的用法文本样式 链接 :Title [Title](URL) 加粗 :Bold **Bold** 斜体字 :Italics *Italics* *删除线 :text ~~text~~ *高亮 :==text== ==text== 段落 : 段落之间空一行 换行符 : 一行结束时输入两个空格 列表 :* 添加星号成为一个新的列表项。 引用 :&gt; 引用内容 内嵌代码 : alert(&#39;Hello World&#39;); 画水平线 (HR) : ——– 制表123456dog | bird | cat----|------|----foo | foo | foobar | bar | barbaz | baz | baz dog bird cat foo foo foo bar bar bar baz baz baz 代码块1alert(&apos;hello word!&apos;); 引入图片 流程图12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 时序图:123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： 已完成事项 待办事项1 待办事项2 引用 注意： 今天工作不努力，明天努力找工作。 作者： mr-9来源：http://mr-9.gitee.io/blog/ 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>序</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
</search>
